
// IMPORT //////////////////////////////////////////////////////////////////////

import { inspect } from 'util';

// UTIL ////////////////////////////////////////////////////////////////////////

const red1 = '\x1b[31m';
const red2 = '\x1b[39m';

const problemText = (str, index) => {
	if (typeof index == 'string') {
		// It’s possible, though unlikely, that we may end up highlighting the
		// wrong bit. I’m not gonna sweat it much.

		index = str.indexOf(index);
	}

	if (index > 20) {
		str = str.substr(index - 20);
		index = 20;
	}

	if (str.length > 40)
		str.substr(0, 40);

	let caret, start, end;

	if (index + 1 == str.length) {
		caret = '<--';
		start = str;
		end   = '';
	} else {
		caret = '-->';
		start = str.substr(0, index);
		end   = str.substr(index);
	}

	return start + red1 + caret + red2 + end;
};

const serialize = val => inspect(val, { colors: true, showHidden: true });

// ERRORS //////////////////////////////////////////////////////////////////////

export class HardcoreSyntaxError extends SyntaxError {
	constructor(msg, text='', index=0) {
		super(msg);

		Error.captureStackTrace(this, this.constructor);

		this.name = 'HardcoreSyntaxError';

		if (text) {
			text = problemText(text, index);
			msg += ':\n\t';
		}

		this.message = `${ red1 }${ msg }${ red2 }${ text }`;
	}
}

export class HardcoreTypeError extends TypeError {
	constructor(msg, value) {
		super(msg);

		Error.captureStackTrace(this, this.constructor);

		value = serialize(value);

		this.name = this.constructor.name;
		this.message = `${ red1 }${ msg }${ red2 } (value was ${ value })`;
	}
}

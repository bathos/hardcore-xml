
import msg from 'error-messages';

import { unique } from 'brodash-thunderscore';

// RELATIONAL //////////////////////////////////////////////////////////////////

const ofChildren = predicate => node => {
  return node.findChildren(predicate);
}

const ofDescendents = predicate => node => {
  return node.findDescendents(predicate);
};

const ofDescendentsOrSelf = predicate => node => {
  const self = predicate(node);
  const desc = node.findDescendents(predicate);
  return self ? [ node, ...desc ] : desc;
};

const nextSibling = predicate => node => {
  const next = node.nextSibling && predicate(node.nextSibling);
  return next ? [ node ] : [];
};

const prevSibling = predicate => node => {
  const prev = node.prevSibling && predicate(node.prevSibling);
  return prev ? [ node ] : [];
};

// OF SELF /////////////////////////////////////////////////////////////////////

const butIsnt = predicate => node => {
  node = !predicate(node) && node;
  return node ? [ node ] : [];
}

const thoughMayBe = predicate => node => {
  node = predicate(node) && node;
  return node ? [ node ] : [];
}

const isElem = node => node instanceof HTMLElement;

// SELECTIONS //////////////////////////////////////////////////////////////////

const beingEmpty = () =>
  elem => !elem.length;

const beingFirst = () =>
  elem => !elem.parent || !elem.parent.filter(isElem).indexOf(elem);

const beingFirstOfName = () => elem =>
  !elem.parent ||
  !elem.parent
    .filter(isElem)
    .filter(ELEM => ELEM.name == elem.name)
    .indexOf(elem);

const beingLast = () => elem => {
  if (!elem.parent) return true;

  const generation = elem.parent.filter(isElem);

  return generation.indexOf(elem) == generation.length - 1;
};

const beingLastOfName = () => elem => {
  if (!elem.parent) return true;

  const generation = elem.parent
    .filter(isElem)
    .filter(ELEM => ELEM.name == elem.name);

  return generation.indexOf(elem) == generation.length - 1;
};

const beingNth = ([ , num ]) => elem =>
  ((num === 1) && !elem.parent) ||
  (elem.parent && (elem.parent.filter(isElem).indexOf(elem) == num - 1));

const beingNthOfName = ([ , num ]) => elem =>
  ((num === 1) && !elem.parent) ||
  (elem.parent &&
    (elem.parent
        .filter(isElem)
        .filter(ELEM => ELEM.name == elem.name)
        .indexOf(elem) == num - 1
    )
  );

const beingNthRight = ([ , num ]) => elem =>
  ((num === 1) && !elem.parent) ||
  (elem.parent &&
    (elem.parent.filter(isElem).reverse().indexOf(elem) == num - 1)
  );

const beingNthRightOfName = ([ , num ]) => elem => 
  ((num === 1) && !elem.parent) ||
  (elem.parent &&
    (elem.parent
      .filter(isElem)
      .filter(ELEM => ELEM.name == elem.name)
      .reverse()
      .indexOf(elem) == num - 1
    )
  );

const beingOnlyChild = () => elem => !elem.parent || elem.parent.length == 1;

const beingOnlyOfName = () => elem =>
  !elem.parent ||
  elem.parent.filter(ELEM => ELEM.name == elem.name).length == 1;

const havingClass = ([ , cl ]) =>
  elem => elem.hasClass(cl);

const havingID = ([ , id ]) =>
  elem => elem.id == id;

const havingName = ([ name ]) =>
  elem => elem.name == name;

const matchingAttribute = ([ , key, rel, val ]) => elem => {
  const VAL = elem.getAttributeValue(key);
  
  if (!VAL) return;

  switch (rel) {
    case '=':  return VAL == val;
    case '~=': return VAL.split(/\s+/gu).includes(val);
    case '^=': return VAL.startsWith(val);
    case '$=': return VAL.endsWith(val);
    case '*=': return VAL.includes(val);
    case '|=': return VAL.startsWith(val + '-') || VAL == val;
  }
};

const matchingLanguage = ([ , lang ]) =>
  elem => elem.lang == lang;

// TOKEN PATTERNS //////////////////////////////////////////////////////////////

const ASTER = /^\*/;
const ATTRB = /^\[\s*([^=~\^\$\*\|]+)\s*([\^\$\*\|~]?=)\s*["']?([^"'\]]*)["']?\s*\]/u;
const CHILD = /^\s*>\s*/;
const CLASS = /^\.([^\s\.\[\^\$\*\|\+\)>=:~]+)/u;
const EMPTY = /^:empty/;
const FIRST = /^:first-child/;
const FOFTY = /^:first-of-type/;
const FOLLO = /^\s*\+\s*/;
const IDVAL = /^#([^\s\.\[\^\$\*\|\+\)>=:~]+)/u;
const LANGU = /^:lang\([^\)]+\)/u;
const LASTC = /^:last-child/;
const LOFTY = /^:last-of-type/;
const NMTOK = /^[^\s\.\[\^\$\*\|\+\)>=:~]+/u;
const NOTCL = /^\s*\)/u;
const NOTOP = /^:not\(\s*/u;
const NTHCH = /^:nth-child\(([1-9][0-9]*)\)/;
const NTHRC = /^:nth-last-child\(([1-9][0-9]*)\)/;
const NTHRY = /^:nth-last-of-type\(([1-9][0-9]*)\)/;
const NTHTY = /^:nth-of-type\(([1-9][0-9]*)\)/;
const ONLYC = /^:only-child/;
const ONLYT = /^:only-of-type/;
const PREVI = /^\s*~\s*/;
const WHITE = /^\s+/u;

// INSTRUCTIONS ////////////////////////////////////////////////////////////////

const bits = [
  [ ASTER, false, isElem ],
  [ ATTRB, false, matchingAttribute ],
  [ CLASS, false, havingClass ],
  [ IDVAL, false, havingID ],
  [ NMTOK, false, havingName ],
  [ FIRST, false, beingFirst ],
  [ LASTC, false, beingLast ],
  [ NTHCH, false, beingNth ],
  [ NTHRC, false, beingNthRight ],
  [ EMPTY, false, beingEmpty ],
  [ LANGU, false, matchingLanguage ],
  [ FOFTY, false, beingFirstOfName ],
  [ LOFTY, false, beingLastOfName ],
  [ NTHTY, false, beingNthOfName ],
  [ NTHRY, false, beingNthRightOfName ],
  [ ONLYC, false, beingOnlyChild ],
  [ ONLYT, false, beingOnlyOfName ],
  [ CHILD, true, ofChildren ],
  [ FOLLO, true, nextSibling ],
  [ PREVI, true, prevSibling ],
  [ NOTOP, true, butIsnt ],
  [ NOTCL, true, thoughMayBe ],
  [ WHITE, true, ofDescendents ]
];

// READ SELECTOR ///////////////////////////////////////////////////////////////

const parseSelector = (str, orig, cur=[ ofDescendentsOrSelf ], acc=[]) => {
  for (const [ pattern, trans, predicator ] of bits) {
    const matches = str.match(pattern);

    if (!matches) continue;

    if (trans) {
      if ((cur[0] == butIsnt) && (pattern != NOTCL)) break;
      if (cur.length > 1) acc.push(cur);
      if (acc.length) cur = [ predicator ];
    } else {
      cur.push(predicator(matches));
    }

    str = str.slice(matches[0].length);

    if (str)
      return parseSelector(str, orig, cur, acc);
    else if (cur.length > 1)
      return [ ...acc, cur ];
    else
      return acc;
  }

  throw new TypeError(msg.invalidSelector(orig, str));
};

// SELECT //////////////////////////////////////////////////////////////////////

const finalize = ([ action, ...predicates ]) => node =>
  isElem(node) &&
  action(node => predicates.every(predicate => predicate(node)))(node);

export const select = (node, str) => {
  const parsed = str
    .split(/\s*,\s*/gu)
    .map(substr => parseSelector(substr, str).map(finalize));

  const baseNodes = [ node ];
  const allNodes = [];

  for (const selectors of parsed) {

    let nodes = baseNodes;

    for (const selector of selectors) {
      let newNodes = [];
      
      for (const node of nodes)
        newNodes = newNodes.push(...selector(node));
      
      nodes = newNodes::unique();
      
      if (!nodes.length) return [];
    }

    allNodes.push(...nodes);
  }

  return allNodes::unique();
};

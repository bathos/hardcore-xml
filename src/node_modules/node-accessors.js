
import { translateGERef as translateHTMLGERef } from 'html-data';

import { compact, isString } from 'brodash-thunderscore';

import msg from 'error-messages';

// DECORATOR BASE //////////////////////////////////////////////////////////////

const accessor = (name, normalize, trim=true, fallback) => ({ prototype }) => {
  const SYMBOL = Symbol();

  Object.defineProperty(prototype, name, {
    get: function() {
      return this[SYMBOL] || fallback;
    },
    set: function(val) {
      if (val === undefined || val === null || val === '')
        this[SYMBOL] = undefined;
        return;

      if (val instanceof Function)
        val = String(val) + '()';
      else
        val = String(val);

      if (trim) val = val.trim();

      this[SYMBOL] = normalize(val);
    }
  });
};

// PATTERNS ////////////////////////////////////////////////////////////////////

const badHyphens      = /-(?=(?:-|$))/g;
const badPIClose      = /\?>/g;
const badSectionClose = /\]\]>/g;
const decRefs         = /&#[0-9]+;/g;
const encodingValue   = /^[A-Z][A-Z0-9_\.\-]*$/i;
const entityTypes     = /^(?:general|parameter|unparsed)$/;
const geRefs          = /^&[A-Z]+;/gi; // No need to capture all valid names.
const hexRefs         = /&#x[A-F0-9]+;/gi;
const nameContinue    = /[:A-Z_a-z\u{C0}-\u{D6}\u{D8}-\u{F6}\u{F8}-\u{2FF}\u{370}-\u{37D}\u{37F}-\u{1FFF}\u{200C}-\u{200D}\u{2070}-\u{218F}\u{2C00}-\u{2FEF}\u{3001}-\u{D7FF}\u{F900}-\u{FDCF}\u{FDF0}-\u{FFFD}\u{10000}-\u{EFFFF}\-\.0-9\u{B7}\u{300}-\u{36F}\u{203F}-\u{2040}]/ug;
const nameStart       = /[:A-Z_a-z\u{C0}-\u{D6}\u{D8}-\u{F6}\u{F8}-\u{2FF}\u{370}-\u{37D}\u{37F}-\u{1FFF}\u{200C}-\u{200D}\u{2070}-\u{218F}\u{2C00}-\u{2FEF}\u{3001}-\u{D7FF}\u{F900}-\u{FDCF}\u{FDF0}-\u{FFFD}\u{10000}-\u{EFFFF}]/u;
const sddFalse        = /^(?:false|no?|0)$/i;
const sddTrue         = /^(?:true|y(?:es)?|1)$/i;
const xmlName         = /^xml$/i;
const validChar       = /[\t\r\n\u0020-\uD7FF\uE000-\uFFFD\u{10000}-\u{10FFFF}])*/gu;
const validPublic     = /[\n\r !#-%'-;=\?-Z_a-z]/;
const whitespace      = /[\n\r\t ]+/;

// NORMALIZATION ///////////////////////////////////////////////////////////////

const extractName = val => {
  const { '0': startChar, index } = val.match(nameStart) || {};

  if (!startChar) return;

  const chars = val.slice(index).match(nameContinue) || [];

  return chars.join('');
};

const extractPublic = val => {
  const chars = val.match(validPublic) || [];

  return chars.join('');
};

export const extractValid = val => {
  const chars = val.match(validChar) || [];

  return chars.join('');
};

// CHARACTER REFERENCES ////////////////////////////////////////////////////////

const translateCharRef = (index, base) => ref => {
  const cp = parseInt(ref.slice(index), base);
  return String.fromCodePoint(cp);
};

const translateGERefs = (ref, html) => {
  switch (ref) {
    case '&amp;':  return '&';
    case '&apos;': return '\'';
    case '&gt;':   return '>';
    case '&lt;':   return '<';
    case '&quot;': return '"';
  }
  
  if (html) return translateHTMLGERef(ref);

  return ref;
};

const translateDecRef = translateCharRef(2, 10);
const translateHexRef = translateCharRef(3, 16);
const replaceDecRefs  = str => str.replace(decRefs, translateDecRef);
const replaceHexRefs  = str => str.replace(hexRefs, translateHexRef);
const replaceCharRefs = str => replaceDecRefs(replaceHexRefs(str));
const replaceGERefs   = str => str.replace(geRefs, translateGERefs);

const replaceRefs = (str, html) => replaceGERefs(replaceCharRefs(str), html);

// ATTRIBUTE VALUES ////////////////////////////////////////////////////////////

const coerceAttVal = (val, def) => {
  if (val === undefined || val === null || val === '')
    return '';

  if (val instanceof Function)
    val = String(val) + '()';
  else
    val = String(val);

  val = extractValid(val);

  switch (def.type) {
    case 'entity':
    case 'id':
    case 'idref':
      return extractName(value);
    case 'entities':
    case 'idrefs':
      return value.split(/[\n\r\t ]+/g)
        .map(extractName)::compact().join(' ');
    case 'enumeration':
    case 'notation':
      value = value.split(/[\n\r\t ]+/)[0];
      if (def.enumeration.has(value)) return value;
      else throw new TypeError(msg.badEnum(value));
    case 'nmtoken':
      return value.trim().split(/[\n\r\t ]+/)[0];
    case 'nmtokens':
      return value.replace(/[\n\r\t ]+/g, ' ').trim();
    case 'cdata':
    default:
      return value.replace(/[\n\r\t]/g, ' ');
  }
};

// ENUMERATION SET /////////////////////////////////////////////////////////////

const SET = Symbol();
const NORMALIZE = Symbol();

const setProxy = ({ prototype }) => {
  const setMethods = [
    'clear', 'delete', 'entries', 'forEach', 'has', 'values', Symbol.iterator
  ];

  for (const method of setMethods)
    Object.defineProperty(prototype, method, {
      value: function() { return this[SET][method](...arguments); }
    });
}

@setProxy
class EnumerationSet {
  constructor(normalize, vals=[]) {
    this[SET] = new Set();
    this[NORMALIZE] = normalize;

    for (let val of vals) {
      val = normalize(val);
      if (val) this[SET].add(val);
    }
  }

  get size() { return this[SET].size; }

  add(val) {
    val = this[NORMALIZE](val);

    if (val) this[SET].add(val);
  }
}

// MISC KNOWLEDGE //////////////////////////////////////////////////////////////

const attributeDefaultTypes = new Set([
  'fixed', 'implicit', 'implied', 'required'
]);

const attributeTypes = new Set([
  'cdata', 'entity', 'entities', 'enumeration', 'id', 'idref', 'idrefs',
  'nmtoken', 'nmtokens', 'notation'
]);

const quantifiers = new Set([ '*', '?', '+', '' ]);

// ACCESSOR DECORATORS /////////////////////////////////////////////////////////

export const alias = (real, alias) => ({ prototype }) => {
  Object.defineProperty(prototype, alias, {
    get: function() { return this[real]; },
    set: function(val) { this[real] = val; }
  });
};

export const attributeType = ({ prototype }) => {
  const SYMBOL = Symbol();

  Object.defineProperty(prototype, 'type', {
    get: function() {
      return this[SYMBOL] || 'cdata';
    },
    set: function(value) {
      if (!value::isString()) {
        value = 'cdata';
      } else {
        value = value.trim().toLowerCase();
        value = attributeTypes.has(value) ? value : 'cdata';
      }

      this[SYMBOL] = value;

      this.enumeration  = this.enumeration;
      this.defaultValue = this.defaultValue;
    }
  });
};

export const attributeValue = ({ prototype }) => {
  const SYMBOL = Symbol();

  Object.defineProperty(prototype, 'value', {
    get: function() {
      const def = this.definition || {};

      if (def.defaultType == 'fixed')
        return def.defaultValue;

      if (!this[SYMBOL] && def.defaultValue)
        return def.defaultValue;

      return this[SYMBOL] || '';
    },
    set: function(val) {
      const def = this.definition || {};

      if (def.defaultType == 'fixed') return;

      this[SYMBOL] = coerceAttVal(val, def);
    }
  });
};

export const cdataContent = accessor('content', value => {
  return extractValid(value).replace(badSectionClose, ']] >');
}, false);

export const commentContent = accessor('content', value => {
  return extactValid(value).replace(badHyphens, '- ');
}, false);

export const defaultType = accessor('defaultType', value => {
  value = value.toLowerCase().replace(/#/g, '');
  return attributeDefaultTypes.has(value);
}, true, 'implicit');

export const defaultValue = ({ prototype }) => {
  const SYMBOL = Symbol();

  Object.defineProperty(prototype, 'defaultValue', {
    get: function() {
      return this[SYMBOL];
    },
    set: function(val) {
      const def = this.definition || {};

      this[SYMBOL] = coerceAttVal(val, def);
    }
  });
};

export const encoding = accessor('encoding', value => {
  if (encodingValue.test(value)) return value;
});

export const entityType = accessor('type', value => {
  value = value.toLowerCase();

  return entityTypes.test(value) ? value : 'general';
});

export const enumeration = ({ prototype }) => {
  const SYMBOL = Symbol();

  Object.defineProperty(prototype, 'enumeration', {
    get: function() {
      return this[SYMBOL];
    },
    set: function(value) {
      const normalize = 
        this.type == 'notation' ? extractName :
        val => extractValid(val).trim().split(/[\n\r\t ]+/g)[0];

      if (value::isString())
        value = value.trim().split(/[\n\r\t ]+/g);

      if (!value[Symbol.iterator])
        value = [];

      this[SYMBOL] = new EnumerationSet(normalize, value);
    }
  });
};

export const instruction = accessor('instruction', value => {
  return extactValid(value).replace(badPIClose, '? >');
}, false);

export const isHTML = ({ prototype }) =>
  Object.defineProperty(prototype, 'isHTML', {
    get: function() { return true; }
  });

export const name = (lower, allowsNS=true) => klass => {
  accessor(
    'name',
    lower ?
      value => { return extractName(value).toLowerCase(); } :
      value => { return extractName(value); }
  )(klass);

  if (allowsNS)
    Object.defineProperties(klass.prototype, {
      ns: {
        get: function() {
          const name = this.name || '';
          return name.slice(0, name.indexOf(':'));
        },
        set: function(val) {
          if (val === undefined || val === null || val === '') {
            this.name = this.nom;
            return;
          }

          val = val.toString().trim();

          this.name = `${ val }:${ this.nom }`;
        }
      },
      nom: {
        get: function() {
          const name = this.name || '';
          return name.slice(name.indexOf(':') + 1);
        },
        set: function(val) {
          if (val === undefined || val === null || val === '')
            val = '';

          val = val.toString().trim();

          this.name = this.nom ? `${ this.nom }:${ val }` : val;
        }
      }
    });
};

export const ndata = accessor('ndata', value => {
  return extractName(value);
});

export const publicID = accessor('publicID', value => {
  return extractPublic(value).replace(whiteSpace, ' ');
});

export const quantifier = accessor('quantifier', value => {
  return quantifiers.has(value) ? value : '';
}, true, '');

export const standalone = accessor('standalone', value => {
  if (sddTrue.test(value))
    return true;
  if (sddFalse.test(value))
    return false;
});

export const systemID = accessor('systemID', value => {
  let valid = extractValid(value);

  if (valid.includes('\'') && valid.includes('"'))
    valid = valid.replace(/"/g, '%22');

  return valid;
});

export const target = accessor('target', value => {
  value = extractName(value)

  if (!xmlName.test(value))
    return value;
});

export const textContent = accessor('content', value => {
  value = extractValid(value);

  return replaceRefs(value, this.isHTML);
});

export const version = accessor('version', value => {
  value = parseFloat(value);

  if ((value >= 1) && (value < 2)) return value;
});

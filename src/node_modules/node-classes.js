
// IMPORTS /////////////////////////////////////////////////////////////////////

import { MalformedError } from 'error-classes';
import { camel }          from 'transform-renamers';
import { isString }       from 'brodash-thunderscore';

import * as accessor      from 'node-accessors';
import { extractValid }   from 'node-accessors';

import msg                from 'error-messages';
import htmlData           from 'html-data';
import select             from 'html-select';

// SYMBOLS /////////////////////////////////////////////////////////////////////

const ATTRIBUTES          = Symbol();
const ATTRIBUTES_FULL     = Symbol();
const CHILDREN            = Symbol();
const CLASS_SET           = Symbol();
const JOINER              = Symbol();
const LEGAL_CHILDREN      = Symbol();
const LEGALIZE            = Symbol();
const PARENT              = Symbol();
const POST_MODIFY         = Symbol();
const SPEC                = Symbol();
const SUPPRESS_QUANTIFIER = Symbol();
const VALIDATE_CHILDREN   = Symbol();
const VALID_CONTENT_RECUR = Symbol();

const $KIDS               = Symbol();
const $NAME               = Symbol();
const $SELF               = Symbol();

const TAB                 = '  ';

// TOXML ESCAPING //////////////////////////////////////////////////////////////

const replaceApos = str => str.replace(/'/g, '&apos;');
const replaceAmp  = str => str.replace(/&/g, '&amp;');
const replaceLt   = str => str.replace(/</g, '&lt;');
const replaceQuot = str => str.replace(/"/g, '&quot;');
const replaceSect = str => str.replace(/\]\]>/g, ']]&gt;');

const escapeText = str => replaceAmp(replaceLt(replaceSect(str)));

const escapeAttr = (str, quote) => {
  const replaceDelim = (quote == '"') ? replaceQuot : replaceApos;
  return replaceDelim(replaceAmp(replaceLt(str)));
};

const ambigChars = /[\u2003\u2002\u200E\u00A0\u200F\u00AD\u2009\u200D\u200C]/g;

const percentNotPRef = /%(?![:A-Z_a-z\u{C0}-\u{D6}\u{D8}-\u{F6}\u{F8}-\u{2FF}\u{370}-\u{37D}\u{37F}-\u{1FFF}\u{200C}-\u{200D}\u{2070}-\u{218F}\u{2C00}-\u{2FEF}\u{3001}-\u{D7FF}\u{F900}-\u{FDCF}\u{FDF0}-\u{FFFD}\u{10000}-\u{EFFFF}][:A-Z_a-z\u{C0}-\u{D6}\u{D8}-\u{F6}\u{F8}-\u{2FF}\u{370}-\u{37D}\u{37F}-\u{1FFF}\u{200C}-\u{200D}\u{2070}-\u{218F}\u{2C00}-\u{2FEF}\u{3001}-\u{D7FF}\u{F900}-\u{FDCF}\u{FDF0}-\u{FFFD}\u{10000}-\u{EFFFF}\-\.0-9\u{B7}\u{300}-\u{36F}\u{203F}-\u{2040}]*;)/gu;

const escapeEntValue = str => str.replace(percentNotPRef, '&#x25;')

const escapeHTML = str => str.replace(ambigChars, char => {
  switch (char) {
    case '\u2003': return '&emsp;';
    case '\u2002': return '&ensp;';
    case '\u200E': return '&lrm;';
    case '\u00A0': return '&nbsp;';
    case '\u200F': return '&rlm;';
    case '\u00AD': return '&shy;';
    case '\u2009': return '&thinsp;';
    case '\u200D': return '&zwj;';
    case '\u200C': return '&zwnj;';
  }
});

const quotePID = (id, quote) => {
  if (quote == '\'' && id.includes('\'')) quote = '"';
  return `${ quote }${ id }${ quote }`;
};

const quoteSID = (id, quote) => {
  if (id.includes('\'')) quote = '"';
  else if (id.includes('"')) quote = '\'';

  return `${ quote }${ id }${ quote }`;
};

// TOXML PRETTIFYING ///////////////////////////////////////////////////////////

const prettyWidth = 80;
const prettyColumns = [ 20, 30, 0 ];

const prettify = function(pre='', outerPre='') {
  const text = this.trim();

  if (text.length <= prettyWidth)
    return outerPre ? ` ${ text } ` : text;

  const words = text.split(/\s+/g);
  const lines = [];

  let line = '';

  while (words.length) {
    if (line.length > prettyWidth) {
      lines.push(pre + line);
      line = '';
    }

    line = line ? line + ' ' + words.shift() : words.shift();
  }

  const prefix = outerPre ? '\n' : '';
  const suffix = outerPre ? '\n' + outerPre : '';

  return `${ prefix }${ lines.join('\n') }${ suffix }`;
};

const attDefColumns = (...vals) => {
  let offset = 0;

  return vals.map((val, index) => {
    const len = prettyColumns[index];

    let padLen = len - val.length + offset;

    if (padLen < 0) {
      offset = padLen;
      padLen = 0;
    }

    const pad = ' '.repeat(padLen);
    return val + pad;
  }).join(' ');
};

// TO OBJECT GETTERS ///////////////////////////////////////////////////////////

// SELF returns the initial base object of nodes which possess toObject

const selfObject = ({ prototype }) => {
  Object.defineProperty(prototype, SELF, {
    get: function() { return {}; }
  });
};

const selfContent = ({ prototype }) => {
  Object.defineProperty(prototype, SELF, {
    get: function() { return this.content; }
  });
};

const selfValue = ({ prototype }) => {
  Object.defineProperty(prototype, SELF, {
    get: function() { return this.value; }
  });
};

// TO STRING DECORATOR /////////////////////////////////////////////////////////

const toStringOpts = (target, name, descriptor) => {
  const toString = descriptor.value;

  descriptor.value =
    function({ d=0, tab='  ', pretty=true, quote='"', withNS=true }={}) {

      if (tab === undefined || tab === null)
        tab = '';
      else
        tab = String(tab);

      if (!/^[\n\r\t ]*$/.test(tab))
        throw new TypeError(msg.badTab);

      if (quote === undefined || quote === null)
        quote = '"';
      else
        quote = String(quote);

      if (!/^["']$/.test(quote))
        throw new TypeError(msg.badQuote);

      const pre1 = Array.apply(null, new Array(d + 1)).join(tab);
      const pre2 = pre1 + tab;

      toString.call(this, { d, pre1, pre2, quote, pretty, tab, withNS });
    };

  return descriptor;
};

// ARRAY PROXY DECORATORS //////////////////////////////////////////////////////

const MAX_NODES = 16384;

const arrayProxy = ({ prototype }) => {
  const proxyMethods = [
    'concat', 'entries', 'every', 'filter', 'find', 'findIndex', 'forEach',
    'includes', 'indexOf', 'keys', 'lastIndexOf', 'map', 'reduce',
    'reduceRight', 'reverse', 'slice', 'some', 'values'
  ];

  for (const method of proxyMethods)
    Object.defineProperty(prototype, method, {
      value: function() { return this.children[method](...arguments); }
    });

  // BAM! Is this reasonable? no. IS ANYTHING? I want proxy ;-;

  for (let i = 0; i < MAX_NODES; i++)
    Object.defineProperty(prototype, i, {
      get: function() { return this[CHILDREN][i]; },
      set: function(child) { this.splice(i, 1, child); }
    });
}

// ABSTRACT NODES //////////////////////////////////////////////////////////////

class Node {

  // $KIDS is used to acquire descendents during transformation. It differs
  // from children in that it may include Attribute nodes.
  get [$KIDS]() {
    return this.children;
  }

  // $NAME is used to acquire a name during transformation. It differs from name
  // in that even unnamed nodes will return a value.
  get [$NAME]() {
    return this.name || `$${ camel(this.constructor.name) }`;
  }

  get children() {
    return [];
  }

  get lastChild() {
    return;
  }

  get parent() {
    return this[PARENT];
  }

  get document() {
    let ancestor;

    for (ancestor of this.ancestors()) continue;

    return (ancestor instanceof Document) && ancestor;
  }

  get siblings() {
    return [ ...this.previousSiblings, ...this.nextSiblings ];
  }

  get prevSibling() {
    const parent = this.parent || [];
    const index  = parent.indexOf(this);

    return parent[index - 1];
  }

  get prevSiblings() {
    const parent = this.parent || [];
    const index  = parent.indexOf(this);

    return parent.slice(0, index);
  }

  get nextSibling() {
    const parent = this.parent || [];
    const index  = parent.indexOf(this);

    return parent[index + 1];
  }

  get nextSiblings() {
    const parent = this.parent || [];
    const index  = parent.indexOf(this);

    return parent.slice(index);
  }

  get preservesWS() {
    return !!(this.parent && this.parent.preservesWS);
  }

  get isHTML() {
    return !!(this.parent && this.parent.isHTML);
  }

  get text() {
    return '';
  }
  
  * ancestors() {
    let node = this.parent;

    while (node) {
      yield node;
      node = node.parent;
    }
  }

  * descendents() {
    // Yields all descendent nodes in tiers; in other words, left to right
    // and top to bottom. Can be thought of as returning the most
    // ‘proximate’ nodes first.

    let children = this.children;

    while (children.length) {
      const child = children.shift();

      yield child;

      if (child.children && child.children.length)
        children.push(...child.children);
    }
  }

  * descendentTree() {
    // Yields all descendent nodes by following branches; this is a sax-like
    // walk of the descendent tree.

    for (const child of this.children) {
      yield child;
      yield * child.tree();
    }
  }

  findAncestor(predicate) {
    for (const ancestor of this.ancestors())
      if (predicate(ancestor))
        return ancestor;
  }

  findAncestors(predicate) {
    return [ ...this.ancestors() ].filter(predicate);
  }

  findChild(predicate) {
    if (this[CHILDREN])
      return this.find(predicate);
  }

  findChildren(predicate) {
    if (this[CHILDREN])
      return this.filter(predicate);
  }

  findDescendent(predicate) {
    for (const descendent of this.descendents())
      if (predicate(descendent))
        return descendent;
  }

  findDescendents(predicate) {
    return [ ...this.descendents() ].filter(predicate);
  }

  remove() {
    if (!this.parent) return;

    const index = this.parent.indexOf(this);

    this.parent.splice(index, 1);

    return this;
  }

  clone() {
    return new this.constructor(this);
  }

  toJSON(opts) {
    const obj = this.toObject(opts);

    return JSON.stringify(obj, undefined, opts.tab);
  }

  toObject() {
    return undefined;
  }

  toXML(opts) {
    return this.toString(opts);
  }

  isSelfValid() {
    return true;
  }

  isValid() {
    try {
      this.isSelfValid();
      return true;
    } catch (err) {
      return false;
    }
  }

  [Symbol.toPrimitive]() {
    return this.toString();
  }

  [Symbol.toStringTag]() {
    return `[object ${
      this.constructor.name
    }${
      this.name ? ` "${ this.name }"` : ''
    }]`;
  }
}

@selfContent
class ContentNode extends Node {
  constructor(opts={}) {
    super();

    if (opts::isString())
      this.content = opts;
    else if (opts.content)
      this.content = opts.content;
  }
}

@arrayProxy
class NodeArray extends Node {
  constructor(legalChildren, children) {
    super();

    this[CHILDREN] = [];
    this[LEGAL_CHILDREN] = legalChildren;

    if (children)
      this.push(...children);
  }

  get children() {
    return this[CHILDREN].slice(0, MAX_NODES);
  }

  get lastChild() {
    return this[CHILDREN][this[CHILDREN].length];
  }

  get text() {
    return this.map(child => child.text).filter(text => text).join(' ');
  }

  get length() {
    return this[CHILDREN].length;
  }

  set length(num) {
    this.splice(val);
  }

  [Symbol.iterator]() {
    return this[CHILDREN][Symbol.iterator]();
  }

  [LEGALIZE](children, method, ...args) {
    if ((new Set(children)).size != children.length)
      throw new TypeError(msg.repeatChild);

    const valid = children.every(
      child => child === undefined || this[LEGAL_CHILDREN].some(
        Legal => child instanceof Legal
      )
    );

    if (!valid)
      throw new TypeError(msg.illegalChild(this[LEGAL_CHILDREN]));

    const result = this.children[method](...args);

    this[VALIDATE_CHILDREN](result);

    for (const child of children) {
      child.remove();
      if (child) child[PARENT] = this;
    }
  }

  [POST_MODIFY]() {
    this[CHILDREN] = this[CHILDREN].filter(child => child);
  }

  [VALIDATE_CHILDREN](children) {
    // This private method, which is overridden by individual NodeArrays, is
    // used by LEGALIZE to apply more specific constraints about legal children
    // than type alone. It differs from isSelfValid in that it does not confirm
    // that all requirements are satisfied, only that the children ‘so far’ are
    // well-formed in relation to one another. 
    return true;
  }

  join() {
    return this.children.map(child => child.toString()).join('\n');
  }

  pop() {
    const child = this[CHILDREN].pop();

    child[PARENT] = undefined;

    return child;
  }

  push(...children) {
    this[LEGALIZE](children, 'push', ...children);

    this[CHILDREN].push(...children);

    this[POST_MODIFY]();

    return this.length;
  }

  shift() {
    const child = this[CHILDREN].shift();

    child[PARENT] = undefined;

    return child;
  }

  sort() {
    return this[CHILDREN].sort(...arguments);
  }

  splice(index, count, ...children) {
    this[LEGALIZE](children, 'splice', ...arguments);
    
    const orphans = this[CHILDREN].splice(index, count, ...children);

    for (const orphan of orphans)
      orphan.remove();

    this[POST_MODIFY]();

    return orphans;
  }

  unshift(...children) {
    this[LEGALIZE](children, 'unshift', ...children);

    this[CHILDREN].unshift(...children);

    this[POST_MODIFY]();

    return this.length;
  }

  isValid() {
    return super.isValid() && this.every(child => child.isValid());
  }

  toString(opts) {
    return this.map(child => child.toString(opts)).join('\n');
  }
}

// ROOT NODES //////////////////////////////////////////////////////////////////

export
@selfObject
@accessor.encoding
@accessor.standalone
@accessor.version
class Document extends NodeArray {
  constructor({ version=1, encoding='UTF-8', standalone=false, children }={}) {
    super([ Comment, Doctype, Element, ProcessingInstruction ], children);

    this.version    = version;
    this.encoding   = encoding;
    this.standalone = standalone;
  }

  get document() {
    return this;
  }

  get doctype() {
    return this.findChild(child => child instanceof Doctype);
  }

  get root() {
    return this.findChild(child => child instanceof Element);
  }

  elementDefinition(name) {
    const dtd = this.doctype;
    return dtd && dtd.elementDefinition(name);
  }

  entityDefinition(ref) {
    const dtd = this.doctype;
    return dtd && dtd.entityDefinition(ref);
  }

  notationDefinition(name) {
    const dtd = this.doctype;
    return dtd && dtd.notationDefinition(name);
  }

  elementByID(id) {
    const dtd = this.doctype;

    if (!dtd) return;

    const { idAttributes } = dtd;

    if (!idAttributes.length) return;

    const elems = this.findDescendents(desc => desc instanceof Element);

    for (const [ elemName, attrNames ] of idAttributes) {
      const idElems = elems.find(elem => elem.name == elemName);

      for (const elem of idElems)
        for (const attrName of attrNames)
          if (elem.getAttributeValue(attrName) == id) return elem;
    }
  }

  [VALIDATE_CHILDREN](children) {
    const elms = children.findChildren(child => child instanceof Element);
    const dtds = children.findChildren(child => child instanceof Doctype);

    if (elms.length > 1)
      throw new MalformedError(msg.multipleRoots);

    if (dtds.length > 1)
      throw new MalformedError(msg.multipleDoctypes);

    if (dtds.length && elms.length) {
      const [ dtd ] = dtds;
      const [ elm ] = elms;

      if (dtd.name != elm.name)
        throw new MalformedError(msg.mismatchedDoctype);

      if (this.indexOf(elm) < this.indexOf(dtd))
        throw new MalformedError(msg.doctypeAfterRoot);
    }

    return true;
  }

  isSelfValid() {
    if ((this.standalone !== undefined || this.encoding) && !this.version)
      throw new MalformedError(msg.missingVersion);

    const elms = this.findChildren(child => child instanceof Element);
    const dtds = this.findChildren(child => child instanceof Doctype);

    if (elms.length === 0)
      throw new MalformedError(msg.missingRoot);

    if (elms.length > 1)
      throw new MalformedError(msg.multipleRoots);

    if (dtds.length > 1)
      throw new MalformedError(msg.multipleDoctypes);

    if (dtds.length) {
      const [ dtd ] = dtds;
      const [ elm ] = elms;

      if (dtd.name != elm.name)
        throw new MalformedError(msg.mismatchedDoctype);

      if (this.indexOf(elm) < this.indexOf(dtd))
        throw new MalformedError(msg.doctypeAfterRoot);
    }

    return true;
  }

  toString(opts) {
    this.isSelfValid();

    let xml = '';

    if (this.version) {
      const version = this.version === 1 ? '1.0' : this.version;
      const encoding = this.encoding;
      const standalone =
        this.standalone === true ? 'yes' :
        this.standalone === false ? 'no' :
        null;

      xml = `<?xml version="${ version }"`;

      if (encoding)
        xml += ` encoding="${ encoding }"`;

      if (standalone)
        xml += ` standalone="${ standalone }"`;

      xml += ' ?>\n';
    }

    return xml + super.toString(opts);
  }
}

export class Fragment extends NodeArray {
  constructor({ children }={}) {
    super([ Comment, Element, ProcessingInstruction, Text ], children);
  }
}

// NON-DTD NODES ///////////////////////////////////////////////////////////////

export
@selfValue
@({ prototype }) => {
  const desc = Object.getOwnPropertyDescriptor(prototype, 'name');
  const set = desc.set;

  // Some crazy shit to ensure attributes are always unique: if an attribute’s
  // name is being changed, we need to delete any previously existing attribute
  // with the new name (which we don’t know until setting, due to
  // normalization).

  desc.set = function(name) {
    const elem = this[PARENT];

    if (!elem) return set.call(this, name);

    let err;

    try {
      elem[ATTRIBUTES].delete(this);
      set.call(this, name);

      if (!this.name)
        throw new TypeError(msg.attributeMustBeNamed);

      elem.removeAttribute(this.name);
    } catch ($err) {
      err = $err;
    } finally {
      elem[ATTRIBUTES].add(this);
      if (err) throw err;
    }
  };

  Object.defineProperty(prototype, 'name', desc);
}
@accessor.name()
@accessor.alias('name', 'key')
@accessor.attributeValue
class Attribute extends Node {

  get definition() {
    const elemDef = this.parent && this.parent.definition;

    if (!elemDef) return;

    return elemDef.attr[this.name] || null;
  }

  escape(delim='"') {
    if (delim != '"' && delim != '\'')
      throw new TypeError(msg.badQuote);

    return escapeAttr(this.value || '', delim);
  }

  remove() {
    if (!this.parent) return this;
    return this.parent.removeAttribute(this.name);
  }

  isSelfValid() {
    const def = this.definition;

    if (!def) return true;

    // Though accessors prevent setting an ‘implausible’ value for a particular
    // attribute type, they do not do contextual checks like confirming that an
    // IDREF references a real ID. Further, because declarations are editable,
    // it is possible for originally valid values to enter an invalid state, so
    // these must be reconfirmed. The simplest way -- even if it’s a bit naughty
    // (side-effects) -- to do this is to reassign the value:

    const value = this.value = this.value;

    switch (def.type) {
      case 'cdata':
        return true;

      case 'entity':
      case 'entities':
        const ents = this.document.doctype.filter(
          node => node instanceof EntityDeclaration
        );

        for (const entName of value.split(/[\n\r\t ]+/g)) {
          const ent = ents.find(ent => ent.name == entName);

          if (!ent)
            throw new MalformedError(msg.entityAttrNotEntity);
          else if (ent.type != 'unparsed')
            throw new MalformedError(msg.entityAttrNotNDATA);
        }

        return true;

      case 'enumeration':
        if (!def.enumeration.has(value))
          throw new MalformedError(msg.badEnum(value));

        return true;

      case 'id':
        if (this.document.elementByID(value) != this.parent)
          throw new MalformedError(msg.repeatID);

        return true;

      case 'idref':
      case 'idrefs':
        value = value.split(/[\n\r\t ]+/g);
        if (!value.every(id => this.document.elementByID(value)))
          throw new MalformedError(msg.badIDReference);

        return true;

      case 'nmtoken':
      case 'nmtokens':
        if (!value)
          throw new MalformedError(msg.badNMToken);

        return true;

      case 'notation':
        if (!def.enumeration.has(value))
          throw new MalformedError(msg.badEnum(value));

        if (!this.document.notationDefinition(value))
          throw new MalformedError(msg.notationEnumNotDeclared);

        return true;
    }
  }

  @toStringOpts
  toString({ quote, withNS }) {
    this.isSelfValid();

    const key = withNS ? this.name : this.nom;
    const value = this.escape(quote);

    return `${ key }=${ quote }${ value }${ quote }`;
  }
}

export
@accessor.cdataContent
class CDATASection extends ContentNode {

  get [$NAME]() {
    return '$text';
  }

  get text() {
    return this.content.trim();
  }

  @toStringOpts
  toString({ pre1, pre2, pretty }) {

    const content = pretty ? this.content::prettify(pre2, pre1) : content;

    return `${ pre1 }<![CDATA[${ content }]>`;
  }
}

export
@accessor.commentContent
class Comment extends ContentNode {

  @toStringOpts
  toString({ pre1, pre2, pretty }) {

    const content = pretty ? this.content::prettify(pre2, pre1) : content;

    return `${ pre1 }<!--${ content }-->`;
  }
}

export
@selfObject
@accessor.name()
class Element extends NodeArray {
  constructor({ name, attributes }={}) {
    super([ Comment, Element, ProcessingInstruction, Text ]);

    this[ATTRIBUTES] = new Set();

    if (name) this.name = name;
    if (attributes) this.attributes = attributes;
  }

  get [$KIDS]() {
    return [ ...this.attributes, ...this ];
  }

  get attributes() {
    return [ ...this[ATTRIBUTES] ];
  }

  set attributes(attrs) {
    if (attrs === undefined || attrs === null) {
      this[ATTRIBUTES].clear();
      return;
    }

    const orig = this.attributes;

    try {
      this[ATTRIBUTES].clear();

      if ((attrs instanceof Set) || (attrs instanceof Array))
        for (const attr of attrs)
          this.addAttribute(attr);

      else if (attrs instanceof Map)
        for (const [ name, value ] of attrs)  
          this.setAttributeValue(name, value);

      else if (attrs instanceof Object)
        for (const name in attrs)
          this.setAttributeValue(name, attrs[name]);

      else
        throw new TypeError(msg.badAttrs);

    } catch (err) {
      this[ATTRIBUTES] = orig;
      throw err;
    }
  }

  get definition() {
    const doc = this.document;
    return doc.elementDefinition(this.name);
  }

  get preservesWS() {
    const xs = this.getAttributeValue('xml:space');

    if (xs == 'preserve') return true;

    return super.preservesWS;
  }

  set preservesWS(val) {
    val = val ? 'preserve' : 'default';
    this.setAttributeValue('xml:space', val);
  }

  get [ATTRIBUTES_FULL]() {
    const attrs = this.attributes;
    const def   = this.definition;

    if (def && def.defaults.size)
      for (const [ name, value ] of def.defaults)
        if (!this.getAttribute(name))
          attrs.push(new Attribute({ name, value }));

    return attrs;
  }

  [VALIDATE_CHILDREN](children) {
    const def = this.definition;

    if (!def || def.type == 'any') return true;

    /* TODO: Validate content spec (direct violations) */

    return true;
  }

  getAttribute(name) {
    return this.attributes.find(attr => attr.name == name);
  }

  removeAttribute(name) {
    const attr = this.getAttribute(name);

    if (attr) {
      this[ATTRIBUTES].delete(attr);
      attr[PARENT] = undefined;
      return attr;
    }
  }

  getAttributeValue(name) {
    const attr = this.getAttribute(name);

    if (attr) return attr.value || '';
  }

  setAttributeValue(name, value) {
    if (this.isHTML) name = name.toLowerCase();

    let attr = this.getAttribute(name);
    let edef = this.definition;
    let adef = edef && edef.attr[name];

    if (adef) {
      /* TODO: confirm validity vis a vis attr spec? or delegate... */
    }

    if (attr) {
      attr.value = value;
    } else {
      const Att = this.isHTML ? HTMLAttribute : Attribute;
      attr = new Att({ name, value });
      this[ATTRIBUTES].add(attr);
    }
  }

  isSelfValid() {
    const def = this.definition;

    if (!def) return true;

    if (def.required)
      for (const attr of required)
        if (!this.getAttribute(attr))
          throw new MalformedError(msg.missingRequiredAttr(this.name, attr));

    /* TODO: Validate content spec (complete) */

    return true;
  }

  @toStringOpts
  toString({ d, pre1, pre2, quote, pretty, tab, withNS }) {
    this.isSelfValid();

    const name  = withNS ? this.name : this.nom;
    const empty = !this.length;
    const sc    = empty && !this.neverSelfCloses;

    const attrs =
      this[ATTRIBUTES_FULL].map(attr => ' ' + attr.toString({ withNS, quote }));

    if (pretty) attrs.sort();

    const start = `${ pre1 }<${ name }${ attrs.join('') }${ sc ? '/' : '' }>`;

    if (sc)
      return start;

    const end  = `</${ name }>`;

    if (empty)
      return `${ start }${ end }`;
    else
      return `${ start }\n${
        super.toString({ d: d + 1, quote, pretty, tab, withNS })
      }\n${ pre1 }${ end }`;
  }
}

export
@accessor.target
@accessor.instruction
class ProcessingInstruction extends Node {
  
  isSelfValid() {
    if (!this.target)
      throw new MalformedError(msg.missingTarget);

    return true;
  }

  @toStringOpts
  toString({ pre1, pretty }) {
    this.isSelfValid();

    const instruction = this.instruction ?
      (pretty ? this.instruction.trim() : this.instruction) + ' ' :
      '';

    return `${ pre1 }<?${ this.target } ${ instruction }?>`;
  }
}

@accessor.textContent
class Text extends ContentNode {

  get escaped() {
    return escapeText(this.content);
  }

  get text() {
    return this.content.trim();
  }

  @toStringOpts
  toString({ pre1, pretty }) {
    if (this.preservesWS) return this.escaped;

    return pretty ?
      this.escaped::prettify(pre1) :
      `${ pre1 }${ this.escaped }`;
  }
}

// DOCTYPE & DECLARATION NODES /////////////////////////////////////////////////

export
@accessor.name()
@accessor.systemID
@accessor.publicID
class Doctype extends NodeArray {
  constructor({ name, systemID, publicID, children }={}) {
    super([
      AttlistDeclaration, Comment,
      ElementDeclaration, EntityDeclaration,
      NotationDeclaration, ProcessingInstruction
    ], children);

    if (name) this.name = name;
    if (systemID) this.systemID = systemID;
    if (publicID) this.publicID = publicID;
  }

  get idAttributes() {
    const attlists =
      this.findChildren(child => child instanceof AttlistDeclaration);

    return attlists.map(
      attlist => [ attlist.name, attlist.filter(attDef => attDef.type == 'id') ]
    )
      .filter(([ name, list ]) => list.length)
      .reduce((acc, [ name, list ]) => {
        let entry = acc.find(entry => entry.name == name);

        if (!entry) {
          entry = { element: name, attributes: [] };
          acc.push(entry);
        }

        for (const attDef of list)
          entry.attributes.push(attDef.name);

        return acc;
      }, []);
  }

  elementDefinition(name) {
    const elemDecl = this.findChild(child =>
      (child instanceof ElementDeclaration) && (child.name == name)
    );

    const attLists = this.findChildren(child =>
      (child instanceof AttlistDeclaration) && (child.name == name)
    );

    const attDefs = attLists.reduce((acc, attList) => {
      for (const attDef of attList) {
        if (acc.find(prevDef => prevDef.name == attDef.name)) continue;
        acc.push(attDef);
      }

      return acc;
    }, []);

    if (!elemDecl && !attDefs.length) return;

    const reqDefs = attDefs.filter(attDef => attDef.defaultType == 'required');
    const required = new Set(reqDefs.map(attDef => attDef.name));

    const defDefs = attDefs.filter(attDef => attDef.defaultValue)
    const defaults = new Map(defDefs.map(
      ({ name, defaultValue }) => [ name, defaultValue ]
    ));

    const res = Object.create(elemDecl);

    res.attr     = attDefs;
    res.required = required;
    res.defaults = defaults;

    return res;
  }

  entityDefinition(ref) {
    return this.findChild(child =>
      (child instanceof EntityDeclaration) && (child.symbol == ref)
    );
  }

  notationDefinition(name) {
    return this.findChild(child =>
      (child instanceof NotationDeclaration) && (child.name == name)
    );
  }

  isSelfValid() {
    if (this.publicID && !this.systemID)
      throw new MalformedError(msg.missingDoctypeSystemID);

    const decls = this.filter(child =>
      child instanceof ElementDeclaration ||
      child instanceof EntityDeclaration ||
      child instanceof NotationDeclaration
    ).map(child => `${ child.constructor.name } # ${ child.name }`)

    if (decls.length > new Set(decls).size)
      throw new MalformedError(msg.repeatDeclaration);

    return true;
  }

  @toStringOpts
  toString({ d, pre1, pretty, quote, tab, withNS }) {
    this.isSelfValid();

    const name = withNS ? this.name : this.nom;

    const idType =
      this.publicID ? ' PUBLIC' :
      this.systemID ? ' SYSTEM' : '';

    let publicID = this.publicID ? ' ' + quotePID(this.publicID, quote) : '';
    let systemID = this.systemID ? ' ' + quoteSID(this.systemID, quote) : '';

    const id = `${ idType }${ publicID }${ systemID }`;

    const start = `${ pre1 }<!DOCTYPE ${ name }${ id }`;

    if (!this.length)
      return `${ start }>`;

    return `${ start } [\n${
      this.super.toString({ d, pretty, quote, tab, withNS })
    }\n${ pre1 }]>`
  }
}

export
@accessor.name()
class AttlistDeclaration extends NodeArray {
  constructor({ name, children }={}) {
    super([ AttributeDefinition ], children);

    if (name) this.name = name;
  }

  isSelfValid() {
    if (!this.name)
      throw new MalformedError(msg.missingName(this.constructor.name));
  }

  @toStringOpts
  toString({ d, pre1, quote, pretty, tab, withNS }) {
    this.isSelfValid();

    const name = withNS ? this.name : this.nom;

    const start = `${ pre1 }<!ATTLIST ${ name }`;

    if (!this.length)
      return `${ start }>`;

    if (this.length === 1)
      return `${ start } ${ this[0].toString({ pretty: false }) }>`;

    return `${ start }\n${
      super.toString({ d: d + 1, quote, pretty, tab, withNS })
    }>`;
  }
}

export
@accessor.name()
@accessor.alias('name', 'key')
@accessor.enumeration
@accessor.alias('enumeration', 'enum')
@accessor.attributeType
@accessor.defaultType
@accessor.defaultValue
class AttributeDefinition {
  constructor({ name, enumeration, type, defaultType, defaultValue }={}) {
    super();

    if (name) this.name = name;
    if (type) this.type = type;
    if (enumeration) this.enumeration = enumeration;
    if (defaultType) this.defaultType = defaultType;
    if (defaultValue) this.defaultValue = defaultValue;
  }

  escape(delim='"') {
    if (delim != '"' && delim != '\'')
      throw new TypeError(msg.badQuote);

    return escapeAttr(this.value || '', delim);
  }

  isSelfValid() {
    if (!this.name)
      throw new MalformedError(msg.missingName(this.constructor.name));

    const { type, defaultType, defaultValue, enumeration } = this;

    const ignoreDefault =
      defaultType == 'implicit' || defaultType == 'required';

    const isEnumerated = (type == 'enumeration') || (type == 'notation');

    const isUPEs = (type == 'entity') || (type == 'entities');

    if (!defaultType && !ignoreDefault && (type != 'cdata'))
      throw new MalformedError(msg.defaultEmpty(type, defaultType));

    if (!ignoreDefault && isEnumerated && !enumeration.has(defaultValue))
      throw new MalformedError(msg.badEnum(value));

    if (!ignoreDefault && isUPEs) {
      const doc = this.document;
      const doctype = doc && doc.doctype;

      if (doctype) {
        for (const upe of defaultValue.split(/[\n\r\t ]+/g)) {
          const upedef = doctype.findChild(node =>
            (node instanceof EntityDeclaration) && (node.name == upe)
          );

          if (!upedef)
            throw new MalformedError(msg.entityAttrNotEntity);
          if (upedef.type != 'unparsed')
            throw new MalformedError(msg.entityAttrNotNDATA);
        }
      }
    }

    if (isEnumerated && !enumeration.size)
      throw new MalformedError(msg.emptyEnum);

    if (type == 'notation') {
      const doc = this.document;

      if (doc) {
        for (const not of enumeration)
          if (!doc.notationDefinition(not)) 
            throw new MalformedError(msg.notationEnumNotDeclared);
      }
    }

    return true;
  }

  @toStringOpts
  toString({ pre1, quote, pretty, withNS }) {
    this.isSelfValid();

    const key = withNS ? this.name : this.nom;

    let attType = '';

    if (this.type != 'enumeration')
      attType = this.type.toUpperCase();

    if (this.type == 'notation')
      attType += ' ';

    if (this.type == 'enumeration' || this.type == 'notation')
      attType += `(${ [ ...this.enumeration ].join('|') })`;

    let defaultDecl = '';

    if (this.defaultType != 'implicit')
      defaultType = `#${ this.defaultType.toUpperCase() }`;

    if (this.defaultType == 'fixed')
      defaultType += ' ';

    if (this.defaultType == 'implicit' || this.defaultType == 'fixed')
      defaultType += `${ quote }${ this.escape(quote) }${ quote }`;

    if (pretty) {
      return `${ pre1 }${ attDefColumns(key, attType, defaultDecl) }`;
    } else {
      return `${ pre1 }${ key } ${ attType } ${ defaultDecl }`;
    }
  }
}

export
@accessor.name()
class ElementDeclaration extends Node {
  constructor({ name, spec }={}) {
    super();

    if (name) this.name = name;
    if (spec) this.spec = spec;
  }

  get spec() {
    return this[SPEC] || 'any';
  }

  set spec(spec) {
    const wasObj = !this[SPEC]::isString();

    const validObj =
      spec instanceof ContentSpecChoice ||
      spec instanceof ContentSpecMixed ||
      spec instanceof ContentSpecSequence;

    if (validObj) {
      if (wasObj) this[SPEC][PARENT] = undefined;
      this[SPEC] = spec;
      this[SPEC][PARENT] = this;
      return;
    }

    spec = String(spec).toLowerCase().trim();

    if (spec == 'any' || 'empty') {
      if (wasObj) this[SPEC][PARENT] = undefined;
      this[SPEC] = spec;
      return;
    }

    throw new TypeError(msg.invalidContentSpec);
  }

  isContentValid(elem) {
    this.isSelfValid();

    const spec = this.spec;

    // Top level only:

    if (spec == 'any')
      return true;

    if (spec == 'empty')
      if (elem.length)
        throw new MalformedError(msg.emptyElemHasContent(elem.name));
      else return true;

    if (spec instanceof ContentSpecMixed) {
      const names = new Set(spec.map(member => member.name));

      const children = elem.filter(child => child instanceof Element);

      for (const childName of new Set(children.map(child => child.name)))
        if (!names.has(childName))
          throw new MalformedError(msg.specIllegal(elem.name, childName));

      return true;
    }

    // Delegate to the recursive operation in the shadows:

    const hasText = elem.find(
      child => (child instanceof Text) || (child instanceof CDATASection)
    );

    if (hasText)
      throw new MalformedError(msg.specIllegal(elem.name, 'text'));

    const children = elem.filter(child => child instanceof Element);

    const [ [ badChild ], success ] =
      ElementDeclaration[VALID_CONTENT_RECUR](children, spec);

    if (!success)
      if (badChild)
        throw new MalformedError(msg.specIllegal(elem.name, badChild.name));
      else
        throw new MalformedError(msg.specIncomplete(elem.name));

    return true;
  }

  static [VALID_CONTENT_RECUR](children, spec) {
    let matched, head, tail; 

    const deeeeper = ElementDeclaration[VALID_CONTENT_RECUR];

    if (spec instanceof ContentSpecMember) {

      [ head, ...tail ] = children;

      matched = head.name == spec.name;

    } else if (spec instanceof ContentSpecSequence) {

      for (const member of spec) {

        [ tail, matched ] = deeeeper(children, member);

        if (!matched) break;

      }

    } else if (spec instanceof ContentSpecChoice) {

      for (const member of spec) {

        [ tail, matched ] = deeeeper(children, member);

        if (matched) break;
      }

    }

    switch (spec.quantifier) {
      case '+':
        if (matched) {
          [ tail ] = deeeeper(tail, spec);
          return [ tail, true ];
        } else {
          return [ children, false ];
        }
      case '*':
        if (matched) {
          [ tail ] = deeeeper(tail, spec);
          return [ tail, true ];
        } else {
          return [ children, true ];
        }
      case '?':
        if (matched)
          return [ tail, true ];
        else
          return [ children, true ];
      default:
        if (matched)
          return [ tail, true ];
        else
          return [ children, false ];
    }
  }

  isSelfValid() {
    if (!this.name)
      throw new MalformedError(msg.missingName(this.constructor.name));

    return true;
  }

  @toStringOpts
  toString({ pre1, withNS }) {
    const name = withNS ? this.name : this.nom;
    const spec = this.spec.toString({ withNS });

    return `${ pre1 }<!ELEMENT ${ name } ${ spec }>`;
  }
}

export
@accessor.name(false, false)
@accessor.entityType
@accessor.systemID
@accessor.publicID
@accessor.ndata
class EntityDeclaration extends Node {
  constructor({ name, systemID, publicID, type='general', value, ndata }={}) {
    super();

    if (name) this.name = name;
    if (systemID) this.systemID = systemID;
    if (publicID) this.publicID = publicID;
    if (value) this.value = value;
    if (ndata) this.ndata = ndata;

    // Note that `value` has no accessor. This is because value may contain
    // arbitrary data in the case of unparsed entities.

    this.type = type;
  }

  get symbol() {
    return this.type == 'unparsed' ? this.name :
      `${ this.type == 'parameter' ? '%' : '&' }${ this.name };`;
  }

  escape(delim='"') {
    if (this.type == 'unparsed') return '';

    if (delim != '"' && delim != '\'')
      throw new TypeError(msg.badQuote);

    return escapeEntValue(escapeAttr(extractValid(this.value || ''), delim));
  }

  isSelfValid() {
    if (!this.name)
      throw new MalformedError(msg.missingName(this.constructor.name));

    if (this.publicID && !this.systemID)
      throw new MalformedError(msg.missingEntitySystemID);

    if (this.type == 'unparsed' && !this.ndata)
      throw new MalformedError(msg.unparsedMissingNDATA);

    if (this.type == 'unparsed' && !this.systemID)
      throw new MalformedError(msg.unparsedMissingID);

    if (this.type != 'unparsed' && this.value && !this.value::isString())
      throw new MalformedError(msg.onlyUnparsedMayHaveArbitraryValue);

    if (this.ndata) {
      const doc = this.document;
      const not = doc && doc.notationDefinition(this.ndata);

      if (!not)
        throw new MalformedError(msg.ndataNotDeclared);
    }

    return true;
  }

  @toStringOpts
  toString({ pre1, quote }) {
    this.isSelfValid();

    const symbol = this.type == 'parameter' ? '% ' : '';
    const name   = this.name;

    let end = '';

    if (this.systemID) {
      const idType = this.publicID ? 'PUBLIC' : 'SYSTEM';
      const pid    = this.publicID ? ' ' + quotePID(this.publicID, quote) : '';
      const sid    = this.systemID ? ' ' + quoteSID(this.systemID, quote) : '';
      end = `${ idType }${ pid }${ sid }`;

      if (this.ndata) end += ` NDATA ${ this.ndata }`;
    } else {
      end = this.escape(quote);
    }

    return `${ pre1 }<!ENTITY ${ symbol }${ name } ${ end }>`;
  }
}

export
@accessor.name(false, false)
@accessor.systemID
@accessor.publicID
class NotationDeclaration extends Node {
  constructor({ name, systemID, publicID }) {
    super();

    if (this.name) this.name = name;
    if (this.systemID) this.systemID = systemID;
    if (this.publicID) this.publicID = publicID;
  }

  isValid() {
    return this.name && (this.systemID || this.publicID);
  }

  isSelfValid() {
    if (!this.name)
      throw new MalformedError(msg.missingName(this.constructor.name));

    if (!this.systemID && !this.publicID)
      throw new MalformedError(msg.missingNotationID);

    return true;
  }

  @toStringOpts
  toString({ d, pre1, pre2, quote, pretty, tab, withNS }) {
    this.isSelfValid();

    const idType = this.publicID ? 'PUBLIC' : 'SYSTEM';

    let publicID = this.publicID ? ' ' + quotePID(this.publicID, quote) : '';
    let systemID = this.systemID ? ' ' + quoteSID(this.systemID, quote) : '';

    const id = `${ idType }${ publicID }${ systemID }`;

    return `${ pre1 }<!NOTATION ${ name } ${ id }>`;
  }
}

// CONTENT SPEC ////////////////////////////////////////////////////////////////

export
@accessor.name()
@accessor.quantifier
class ContentSpecMember extends Node {
  constructor({ name, quantifier='' }={}) {
    super();

    this.name = name;
    this.quantifier = quantifier;
  }

  remove() {
    super.remove();
    this[SUPPRESS_QUANTIFIER] = false;
  }

  toString({ withNS=true }={}) {
    const name = withNS ? this.name : this.nom;
    const quant = this[SUPPRESS_QUANTIFIER] ? '' : this.quantifier;

    return `${ name }${ quant }`;
  }
}

export
@accessor.quantifier
class ContentSpecMixed extends NodeArray {
  constructor({ children }={}) {
    super([ ContentSpecMember ], children);
  }

  get quantifier() {
    return this.length ? '*' : '';
  }

  [POST_MODIFY]() {
    super[POST_MODIFY]();

    for (const child of this)
      child[SUPPRESS_QUANTIFIER] = true;
  }

  [VALIDATE_CHILDREN](children) {
    for (child of children)
      if (child != children.find(child2 => child2.name == child.name))
        throw new TypeError(msg.repeatMixedChild);
  }

  remove() {
    if (this[PARENT])
      this[PARENT][SPEC] = 'any';
  }

  toString() {
    const members = [
      '#PCDATA',
      ...this.map(member => member.toString())
    ].join('|');

    return `(${ members })${ this.quantifier }`;
  }
}

class ContentSpecGrouping extends NodeArray {
  constructor({ children, quantifier='' }={}) {
    super([
      ContentSpecChoice, ContentSpecSequence, ContentSpecMember
    ], children);

    this.quantifier = quantifier;
  }

  isSelfValid() {
    if (!this.length)
      throw new MalformedError(msg.emptyContentSpecGroup);
  }

  remove() {
    if (this[PARENT] instanceof ElementDeclaration)
      this[PARENT][SPEC] = 'any';
    else
      super.remove();
  }

  toString() {
    this.isSelfValid();

    const members = this.map(member => member.toString()).join(this[JOINER]);

    return `(${ members })${ this.quantifier }`;
  }
}

export
@accessor.quantifier
class ContentSpecChoice extends ContentSpecGrouping {
  constructor(opts) {
    super(opts);
    this[JOINER] = '|';
  }

  [VALIDATE_CHILDREN](children) {
    for (child of children.filter(child => child instanceof ContentSpecMember))
      if (child != children.find(child2 => child2.name == child.name))
        throw new TypeError(msg.repeatChoiceChild);
  }
}

export
@accessor.quantifier
class ContentSpecSequence extends ContentSpecGrouping {
  constructor(opts) {
    super(opts);
    this[JOINER] = ',';
  }
}

// HTML DATA PREP //////////////////////////////////////////////////////////////

const htmlCS = {};

for (const specName in htmlData.specs) {
  const { type, content } = htmlData.specs[specName];

  if (type == 'pcdata') {
    htmlCS[specName] = new ContentSpecMixed({ children: content });
  } else {
    htmlCS[specName] = new ContentSpecChoice({
      quantifier: '*',
      children: content.map(name => new ContentSpecMember({ name }));
    });
  }
}

// HTML NODES //////////////////////////////////////////////////////////////////

export
@accessor.isHTML
class HTMLDocument extends Document {
  constructor($opts) {
    const { children, ...opts } = $opts;

    super(opts);

    this[LEGAL_CHILDREN] = [
      HTMLDoctype, HTMLElement, Comment, ProcessingInstruction
    ];

    if (children)
      this.push(...children);
  }

  elementByID(id) {
    return this.findDescendent(
      desc => (desc instanceof HTMLElement) && (desc.id == id)
    );
  }

  select(selector) {
    return select(this.root, selector);
  }
}

const HTML_PUB
const HTML_SYS;

export
@accessor.isHTML
class HTMLDoctype extends Node {
  constructor({ systemID, publicID }={}) {
    super();

    if (systemID) this.systemID = systemID;
    if (publicID) this.publicID = publicID;
  }

  get name() { return 'html'; }
  set name(str) {}

  isSelfValid() {}
}

export
@({ prototype }) => {
  for (const attr of htmlData.attributes)
    Object.defineProperty(prototype, attr, {
      get: function() { return this.getAttributeValue(attr); },
      set: function(val) { this.setAttributeValue(attr, val); }
    });
}
@accessor.isHTML
@accessor.name(true)
class HTMLElement extends Element {
  constructor($opts) {
    const { children, ...opts } = $opts;

    super(opts);

    this[LEGAL_CHILDREN] = [
      Comment, HTMLElement, ProcessingInstruction, Text
    ];

    if (children)
      this.push(...children);
  }

  get alwaysSelfCloses() {
    return htmlData.selfCloses.has(this.name);
  }

  get neverSelfCloses() {
    return !this.alwaysSelfCloses;
  }

  get preservesWS() {
    return htmlData.permitsWS.has(this.name) || super.permitsWS;
  }

  get definition() {
    return htmlData.elems[this.name];
  }

  get [CLASS_SET]() {
    return new Set((this.class || '').trim().split(/\s+/gu));
  }

  select(selector) {
    return select(this, selector);
  }

  hasClass(cls) {
    [ cls ] = cls.match(/\S+/);

    return this[CLASS_SET].has(cls);
  }

  addClass(cls) {
    [ cls ] = cls.match(/\S+/);

    this.class = [ ...this[CLASS_SET].add(cls) ].join(' ');
  }

  removeClass(cls) {
    [ cls ] = cls.match(/\S+/);

    this.class = [ ...this[CLASS_SET].delete(cls) ].join(' ');
  }

  toString(opts) {
    if (this.name == 'script') {
      // TODO
    } else if (this.name == 'style') {
      // TODO
    } else {
      return this.super.toString(opts);
    }
  }
}

export
@accessor.isHTML
@accessor.name(true)
class HTMLAttribute extends Attribute {

  get definition() {
    if (this.name == 'class') return { type: 'nmtokens' };
    if (this.name == 'id') return { type: 'id' };
  }

  escape(quote) {
    return escapeHTML(super.escape(quote));
  }

  @toStringOpts
  toString({ quote, withNS }) {
    const key = withNS ? this.name : this.nom;
    const value = this.escape(quote);

    return value ? `${ key }=${ quote }${ value }${ quote }` : key;
  }
}

export
@accessor.isHTML
class HTMLText extends Text {
  get escaped() {
    return escapeHTML(super.escaped);
  }
}
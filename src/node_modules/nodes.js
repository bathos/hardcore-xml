// IMPORTS /////////////////////////////////////////////////////////////////////

import { HardcoreTypeError as HTE } from 'errors';
import { camel } from 'renamers';

import * as isValid from 'string-validation';

import msg from 'msg';

// NOTES ///////////////////////////////////////////////////////////////////////
//
// This file is really long. Oops. I should break it apart ... at some point ...
// later ... yeah, later.
//
////////////////////////////////////////////////////////////////////////////////

// UTIL: COERCION //////////////////////////////////////////////////////////////

const replaceGTEntity = function() {
	return this.replace(/&gt;/g, '>');
};

const replaceLiteralAmp = function() {
	const parts = this.split(/(?=&)/g);

	let res = '';

	for (const part of parts) {
		if (!part.startsWith('&')) {
			res += part;
			continue;
		}

		let [ , name ] = part.match(/^&([\s\S]+);/) || [];

		if (name && (isValid.nameStr(name) || isValid.charRef(name)))
			res += part;
		else
			res += '&amp;' + part.slice(1);
	}

	return res;
};

const replaceLiteralLT = function() {
	return this.replace(/</g, '&lt;');
};

const replaceLiteralThingie = function() {
	return this.replace(/\]\]>/g, ']]&gt;');
};

const replaceLTEntity = function() {
	return this.replace(/&lt;/g, '<')
};

const replaceQuoteEntities = function() {
	return this.replace(/&quot;/g, '"').replace(/&apos;/g, '\'');	
};

const replaceKnownEntities = function() {
	return this::replaceGTEntity()::replaceQuoteEntities()::replaceLTEntity();
}

// UTIL: TRANSFORMATION ////////////////////////////////////////////////////////

const prettyLength = 80;
const prettyColumn = 25;

const escapeQuote = function(quote) {
	const pattern  = new RegExp(quote, 'g');
	const entity   = quote == '"' ? '&quot;' : '&apos;';

	return this.replace(pattern, entity);	
};

const indent = (d, tab) => {
	if (!tab) tab = '';

	if (!isValid.whitespace(tab)) tab = '\t';

	return new Array(d + 1).join(tab || '');
};

const norm = function() {
	return this.trim().replace(/\s+/g, ' ');
};

const safelyQuote = function(quote) {
	if (~this.indexOf(quote))
		quote = quote == '"' ? '\'' : '"';

	return `${ quote }${ this }${ quote }`
};

const toPrettyLines = function(p='') {
	const words = this.trim().split(/\s+/g);

	const lines = words.reduce((lines, word) => {
		let line = lines.pop();

		if (!line) return [ word ];

		let newLine = line + ' ' + word;

		if (newLine.length > prettyLength)
			lines.push(line, word);
		else
			lines.push(newLine);

		return lines;
	}, []);

	return lines.map(line => p + line).join('\n');	
};

const toVersionString = function() {
	return this === 1 ? '1.0' : this.toString();
};

const validQuote = quote => quote == '\'' ? quote : '"';

// INTERNAL PROPERTIES /////////////////////////////////////////////////////////

const $array               = Symbol();
const $attributes          = Symbol();
const $children            = Symbol();
const $childrenConstructor = Symbol();
const $constructors        = Symbol();
const $content             = Symbol();
const $contentSpec         = Symbol();
const $defaultType         = Symbol();
const $defaultValue        = Symbol();
const $encoding            = Symbol();
const $instruction         = Symbol();
const $isParameter         = Symbol();
const $key                 = Symbol();
const $keyword             = Symbol();
const $members             = Symbol();
const $name                = Symbol();
const $namespace           = Symbol();
const $ndata               = Symbol();
const $parent              = Symbol();
const $PARENT              = Symbol();
const $publicID            = Symbol();
const $quantifier          = Symbol();
const $standalone          = Symbol();
const $systemID            = Symbol();
const $target              = Symbol();
const $type                = Symbol();
const $validate            = Symbol();
const $validate2           = Symbol();
const $value               = Symbol();
const $version             = Symbol();

// These are special properties used by `toObject`.

const $$kids    = Symbol();
const $$name    = Symbol();
const $$nmsm    = Symbol();
const $$self    = Symbol();
const $toObject = Symbol();

// UTIL: TO OBJECT /////////////////////////////////////////////////////////////

const coerceString = (node, val) => {
	return typeof val == 'string' ? val :
	node.text || node.cleanContent || '';
};

const coerceNumber = (node, val) => {
	const str = coerceString(node, val);

	if (/infinity/i.test(str))
		return Infinity;
	if (/-\s*infinity/i.test(str))
		return -Infinity;

	return parseFloat(str);
};

const coerceDate = (node, val) => {
	const str = coerceString(node, val);

	return new Date(str);
};

const coerceBoolean = (node, val) => {
	const str = coerceString(node, val);
	
	if (/^(?:t(?:rue)?|y(?:es)?|1)$/i.test(str))
		return true;
	if (/^(?:f(?:alse)?|no?|0)$/i.test(str))
		return false;
};

const coercions = new Map([
	[ Boolean, coerceBoolean ],
	[ Date, coerceDate ],
	[ Number, coerceNumber ],
	[ String, coerceString ]
]);

const normMatch = ($match, $nmsm) => {
	if (typeof $match == 'string' || $match instanceof String)
		return [ node => node[$nmsm] == $match, 'nm' ];
	if ($match instanceof RegExp)
		return [ node => $match.test(node[$nmsm]), 'nm' ];
	if (Node.isPrototypeOf($match))
		return [ node => node instanceof $match, 'nd' ];
	if ($match instanceof Function)
		return [ node => $match(node, node[$nmsm]), 'fn' ];
	if ($match === true)
		return [ () => true, 'wc' ];

	return [ () => false, 'wc' ];
};

const normMatches = ($matches, $nmsm) => {
	const matches = $matches.map($match => normMatch($match, $nmsm));
	const types = {};

	for (const [ fn, type ] of matches) {
		if (type == 'wc') {
			return fn;
		} else {
			types[type] = types[type] || [];
			types[type].push(fn);
		}
	}

	const { nm, nd, fn } = types;
	const groups = [ nm, nd, fn ].filter(group => group);

	return node => groups.every(group => group.some(match => match(node)));
};

const baseRules = () => {
	return [
		{ match: [ Element, Attribute, Text, CDATASection ] },
		{ match: Document, before: node => ({}) },
		{ match: DocumentFragment },
		{ match: true, ignore: true }
	]
};

const normRule = ($rule, $nmsm, $renamer) => {
	// Match

	let match;

	if ($rule.match instanceof Array)
		match = normMatches($rule.match, $nmsm);
	else
		[ match ] = normMatch($rule.match, $nmsm);

	// Rename

	let rename;

	if (typeof $rule.rename == 'string' || $rule.rename instanceof String)
		rename = () => $rule.rename;
	else if ($rule.rename instanceof Function)
		rename = $rule.rename;
	else if ($renamer)
		rename = $renamer;
	else
		rename = name => name;

	// Before / Fold / Ignore

	let before;

	const { collapse } = $rule;

	const fold =
		((typeof collapse == 'string') || (collapse instanceof String)) ?
		collapse : null;

	if ($rule.ignore) {
		before = () => undefined;
	} else {
		const $coerce = coercions.get($rule.coerce);
		const $before = $rule.before;

		if ($coerce && $before)
			before = (node, baseVal) => $before(node, $coerce(node, baseVal));
		else if ($coerce)
			before = $coerce;
		else if ($before)
			before = $before;
		else
			before = (node, baseVal) => baseVal;
	}

	// Collapse, Plural, After, AfterPlural

	const { after=val=>val, afterPlural=val=>val } = $rule;
	const { plural, asArray } = $rule;

	return {
		after,
		afterPlural,
		asArray,
		before,
		collapse,
		fold,
		match,
		plural,
		rename
	};
};

const normRules = ($rules, $nmsm, renamer) => {
	return $rules
		.concat(baseRules())
		.map($rule => normRule($rule, $nmsm, renamer));
};

// COMMON ACCESSORS ////////////////////////////////////////////////////////////

// Not all node properties neatly align with class inheritance. To avoid
// repetition, this decorator works as a kind of accessor mix-in.

const get = $symbol => function() { return this[$symbol]; }

const getFullName = function() {
	return this.namespace ?
		`${ this.namespace }:${ this.name }` :
		this.name; 
};

const setEncoding = function(str) {
	if (str === undefined || str === null) {
		this[$encoding] = undefined;
	} else {
		str = String(str);

		if (isValid.encoding(str))
			this[$encoding] = str;
	}
};

const setName = function(str) {
	str = String(str).trim();

	if (isValid.nameStr(str))
		this[$name] = str;
	else
		throw new HTE(msg.invalidName, str);
};

const setNamespace = function(str) {
	if (str === undefined || str === null) {
		this[$namespace] = null;
	} else {
		str = String(str).trim();

		if (!~str.indexOf(':') && isValid.nameStr(str))
			this[$namespace] = str;
		else
			throw new HTE(msg.invalidName, str);
	}
};

const setPublicID = function(str) {
	if (str === undefined || str === null)
		this[$publicID] = undefined;
	else if (isValid.publicID(str))
		this[$publicID] = str;
	else
		throw new HTE(msg.invalidPID, str);
};

const setSystemID = function(str) {
	if (str === undefined || str === null)
		this[$systemID] = undefined;
	else if (isValid.systemID(str))
		this[$systemID] = str;
	else
		throw new HTE(msg.invalidSID, str);
};

const setValue = $symbol => function(str) {
	if (str === undefined || str === null) {
		this[$symbol] = '';
	} else {
		str = String(str)
			::replaceLiteralAmp()
			::replaceLiteralLT()
			::replaceQuoteEntities();

		// Note " and ' are not escapes to entities until toString, as its
		// nature will depend on which quotation mark delimiter is used.

		if (isValid.charData(str))
			this[$symbol] = str;
		else
			throw new HTE(msg.invalidValue, str);
	}
};

const setVersion = function(val) {
	if (val === undefined || val === null) {
		this[$version] = undefined;
	} else {
		val = parseFloat(val);

		if (val >= 1 && val < 2)
			this[$version] = val;
		else
			throw new HTE(msg.invalidVersion, val);
	}
};

const commonAccessor = (target, name, descriptor) => {
	switch (name) {
		case 'encoding':
			descriptor.get = get($encoding);
			descriptor.set = setEncoding;
			return descriptor;
		case 'defaultValue':
			descriptor.get = get($defaultValue);
			descriptor.set = setValue($defaultValue);
			return descriptor;
		case 'fullName':
			descriptor.get = getFullName;
			return descriptor;
		case 'name':
			descriptor.get = get($name);
			descriptor.set = setName;
			return descriptor;
		case 'namespace':
			descriptor.get = get($namespace);
			descriptor.set = setNamespace;
			return descriptor;
		case 'publicID':
			descriptor.get = get($publicID);
			descriptor.set = setPublicID;
			return descriptor;
		case 'systemID':
			descriptor.get = get($systemID);
			descriptor.set = setSystemID;
			return descriptor;
		case 'value':
			descriptor.get = get($value);
			descriptor.set = setValue($value);
			return descriptor;
		case 'version':
			descriptor.get = get($version);
			descriptor.set = setVersion;
			return descriptor;
	}
}

// NODE ////////////////////////////////////////////////////////////////////////

class Node {
	constructor() {}

	get [$$kids]() { return []; }
	get [$$name]() { return; }
	get [$$nmsm]() { return this[$$name]; }
	get [$$self]() { return {}; }

	get parent() {
		return this[$PARENT];
	}

	get [$parent]() {
		return this[$PARENT];
	}

	set [$parent](parent) {
		this.remove();
		this[$PARENT] = parent;
	}

	get parents() {
		return [ ... this.lineage() ].slice(1);
	}

	get siblings() {
		const generation = this.parent && this.parent.children;
		return (generation && generation.filter(n => n != this)) || [];
	}

	get prev() {
		const generation = (this.parent && this.parent.children) || [];
		const index      = generation.indexOf(this) - 1;
		return generation[index];
	}

	get next() {
		const generation = (this.parent && this.parent.children) || [];
		const index      = generation.indexOf(this) + 1;
		return generation[index];
	}

	clone() {
		return new this.constructor(this);
	}

	findNearestAncestor(predicate) {
		for (const parent of this.parents) {
			if (predicate(descendent))
				return descendent;
		}
	}

	findNearestDescendent(predicate) {
		/* this space intentionally left blank ... oh, wait */
	}

	* lineage() {
		let node = this;

		while (node) {
			yield node;
			node = node.parent;
		}
	}

	* descendents() {
		/* likewise */
	}

	* tree() {
		for (const child of (this.children || [])) {
			yield child;
			yield * child.tree();
		}
	}

	remove() {
		const parent = this[$PARENT];

		if (!parent) return;

		const children =
			(this instanceof Attribute || this instanceof AttributeDefinition) ?
			parent[$attributes] : parent[$children];

		if (!children) return;

		const index = children.indexOf(this);

		if (~index) children.splice(index, 1);

		return this;
	}

	toObject({ withNS=false, renamer=camel, rules=[] }={}) {
		const plurals = new Map();
		const $nmsm   = withNS ? $$nmnm : $$name;

		let $renamer;

		if (renamer instanceof Function)
			$renamer = renamer;
		else if (renamer instanceof Map)
			$renamer = name => renamer.get(name);
		else if (renamer instanceof Object)
			$renamer = name => renamer[name];
		else
			$renamer = name => name;

		rules = normRules(rules, $nmsm, $renamer);

		return this[$toObject]({}, rules, plurals, $nmsm, $renamer);
	}

	[$toObject](target, rules, plurals, $nmsm, renamer) {
		const rule = rules.find(rule => rule.match(this));
		const name = rule.rename(this[$nmsm]) || this[$nmsm];

		const { asArray, fold, collapse } = rule;

		let self = rule.before(this, this[$$self]);

		if (asArray && !(self instanceof Array))
			self = [];

		if (fold && !(self instanceof Object))
			self = {};

		const isOb = self instanceof Object;
		const kids = (isOb || collapse) ? this[$$kids] : [];

		if (asArray) {
			for (const kid of kids) {
				const member = {};
	
				kid[$toObject](member, rules, plurals, $nmsm, renamer);

				self.push(member);
			}
		} else {
			for (const kid of kids) {
				const $target = (isOb && (!collapse || fold)) ? self : target;
				kid[$toObject]($target, rules, plurals, $nmsm, renamer);
			}
		}

		const implicitIgnore =
			self instanceof Object && !(self instanceof Date) &&
			!Object.keys(self).length;

		if ((self === undefined) || implicitIgnore)
			return target;

		if (isOb) {
			for (const key in self) {
				const val = self[key];
				const afterPlural = plurals.get(val);

				if (afterPlural)
					self[key] = afterPlural(val);
			}
		}

		if (fold) {
			if (fold in self)
				self = self[fold];
			else
				return target;
		}

		let res = rule.after(self, this, name);

		if (res instanceof Object && !(res instanceof Date)) {
			const keys = Object.keys(res);
			const likelyTextKey = renamer('$text') || '$text';

			if ((keys.length === 1) && (keys[0] == likelyTextKey))
				res = this.text;
		}

		const prev = target[name];

		// We do not test for arrayness because it is plausible that a custom
		// transform returned an array *as* a value, that is, not as "the"
		// value but as "a" value, which may be the member of another array.
		// Instead we maintain a WeakSet to confirm whether it’s an array we’ve
		// created ourselves.

		if (plurals.has(prev)) {
			prev.push(res);
		} else if ((name in target) && (rule.plural !== false)) {
			target[name] = [ prev, res ];
			plurals.set(target[name], rule.afterPlural);
		} else if (rule.plural) {
			target[name] = [ res ];
			plurals.set(target[name], rule.afterPlural);
		} else {
			target[name] = res;
		}

		return self;
	}

	toJSON(opts) {
		const obj = this.toObject(opts);

		return JSON.stringify(obj, undefined, opts.tab);
	}

	toXML(opts) {
		return this.toString(opts);
	}

	isValid() {
		// Some nodes (usually DTD nodes) have complex validation based on
		// multiple attributes that will overwrite this. But for most nodes,
		// this will be true by definition because the setters prevent them from
		// ever becoming invalid to begin with. 
		return true;
	}
}

// CHILDREN ////////////////////////////////////////////////////////////////////

// A variety of nodes can have a series of valid children. Initially I
// approached this by subclassing Array, which largely works now, but I was
// troubled by the fact that there was no way to elegantly deal with direct
// assignment to index, since we don’t yet have Proxy. Instead we need to
// create a sort of Proxy manually that simply doesn’t acknowledge indexes. It’s
// a bit tedious by comparison, but it’s necessary if we want to allow the
// ‘parent’ property to work correctly.
//
// The $validate private method confirms that would-be members pass muster. Some
// subclasses augment $validate with additional, more complex content rules.
//
// The ElementChildren class gets exported as DocumentFragment, since it closely
// resembles that ‘node type’ (it isn’t one really) as implemented in various
// other XML/HTML libraries.

class Children extends Node /* extends Array sort of */ {
	constructor() {
		super();

		this[$array] = [];
	}

	get [$$kids]() { return this; }
	get [$$name]() { return; }
	get [$$self]() { return {}; }

	get first() {
		return this[$array][0];
	}

	get last() {
		return this[$array][this[$array].length -1];
	}

	get [$parent]() {
		return this[$PARENT];
	}

	set [$parent](parent) {
		this.remove();
		this[$PARENT] = parent;
		this[$array].forEach(m => m[$PARENT] = parent); // already removed
	}

	[$validate](...members) {
		const constructors = this[$constructors];

		for (const member of members) {
			if (!constructors.some(Constr => member instanceof Constr))
				throw new HTE(msg.illegalChild, member);
		}
	}

	clone() {
		const clone = new this.constructor();

		const clonelings = this[$array].map(m => m.clone());

		clone.push(...clonelings);

		return clone;
	}

	toObject(opts) {
		if (this.parent) {
			return this.parent.toObject(opts);
		} else {
			const base = new NodeWithChildren(Children);

			base.children = this;

			const result = base.toObject(opts);

			this.remove();

			return result;
		}
	}

	// Different behavior

	join(sep='\n') {
		return this[$array].join(sep);
	}

	toLocaleString() {
		return this.toString();
	}

	toString({ d, pretty, quote, tab, withNS }={}) {
		return this[$array].map(
			child => child.toString({ d, pretty, quote, tab, withNS })
		).join(!tab ? '' : '\n');
	}

	// Simple proxy

	get length()        { return this[$array].length; }
	set length(val)     { this.splice(val); }

	entries()           { return this[$array].entries(); }
	every()             { return this[$array].every(...arguments); }
	filter()            { return this[$array].filter(...arguments); }
	find()              { return this[$array].find(...arguments); }
	findIndex()         { return this[$array].findIndex(...arguments); }
	forEach()           { return this[$array].forEach(...arguments); }
	includes()          { return this[$array].includes(...arguments); }
	indexOf()           { return this[$array].indexOf(...arguments); }
	keys()              { return this[$array].keys(); }
	lastIndexOf()       { return this[$array].lastIndexOf(...arguments); }
	map()               { return this[$array].map(...arguments); }
	reduce()            { return this[$array].reduce(...arguments); }
	reduceRight()       { return this[$array].reduceRight(...arguments); }
	reverse()           { return this[$array].reverse(); }
	some()              { return this[$array].some(...arguments); }
	sort()              { return this[$array].sort(...arguments); }
	values()            { return this[$array].values(...arguments); }

	[Symbol.iterator]() { return this[$array][Symbol.iterator](); }

	// Requiring parent change

	pop() {
		const member = this[$array].pop();

		member[$parent] = undefined;

		return member;
	}

	shift() {
		const member = this[$array].shift();

		member[$parent] = undefined;

		return member;
	}

	slice() {
		const members = this[$array].slice(...arguments);

		members.forEach(m => m[$parent] = undefined);

		return new this.constructor(...members);
	}

	// Requiring validation
	// copyWithin & fill are not proxied

	concat() {
		this[$validate](...arguments);

		const members = this[$array].concat(...arguments);
		const res     = new this.constructor(...members);

		if (res[$validate2]) res[$validate2]();

		return res;
	}

	push(...newMembers) {
		this[$validate](...newMembers);

		const orig = this[$array].slice();
		const res  = this[$array].push(...newMembers);

		if (this[$validate2])
			this[$validate2](orig);

		newMembers.forEach(m => m[$parent] = this[$parent]);

		return res;
	}

	splice(start, count, ...newMembers) {
		if (newMembers.length)
			this[$validate](newMembers);

		const orig = this[$array].slice();
		const res  = this[$array].splice(...arguments);

		if (this[$validate2])
			this[$validate2](orig);

		res.forEach(m => m[$parent] = undefined);
		newMembers.forEach(m => m[$parent] = this[$parent]);

		return res;
	}

	unshift(...newMembers) {
		this[$validate](...newMembers);

		const orig = this[$array].slice();
		const res  = this[$array].unshift(...newMembers);

		if (this[$validate2])
			this[$validate2](orig);

		newMembers.forEach(m => m[$parent] = this[$parent]);

		return res;
	}
}

class DocumentChildren extends Children {
	constructor() {
		super();

		this[$constructors] = [
			Comment,
			Doctype,
			Element,
			ProcessingInstruction
		];
	}

	[$validate2](orig) {
		const arr = this[$array];

		try {
			let doctypeAllowed = true;
			let elementAllowed = true;

			for (const m of arr) {

				if (m instanceof Element) {

					if (elementAllowed) {
						doctypeAllowed = false;
						elementAllowed = false;
					} else {
						throw new HTE(msg.illegalRoot, m);
					}

				} else if (m instanceof Doctype) {
					if (doctypeAllowed)
						doctypeAllowed = false;
					else
						throw new HTE(msg.illegalDoctype, m);
				}
			}
		} catch (err) {
			this[$array] = orig;
			throw err;
		}
	}
}

class DoctypeChildren extends Children {
	constructor() {
		super();

		this[$constructors] = [
			Comment,
			Declaration,
			EntityDeclaration,
			ParameterReference,
			ProcessingInstruction
		];
	}
}

class DoctypeExternalChildren extends Children {
	constructor() {
		super();

		this[$constructors] = [
			Comment,
			ConditionalSection,
			Declaration,
			EntityDeclaration,
			ParameterReference,
			ProcessingInstruction
		];
	}	
}

export class ChildElementGroup extends Children {
	constructor({ type='CHOICE', quantifier='' }={}) {
		super();

		this[$constructors] = [ ChildElementName, ChildElementGroup ];

		this[$type] = type;

		this[$quantifier] = quantifier;
	}

	[$validate](...members) {
		const type = this[$type];

		if (members.some(m => m instanceof RootChildElementGroup))
			throw new HTE(msg.illegalRCEG);

		if (type == 'ANY' || type == 'EMPTY')
			throw new HTE(msg.mismatchedCEGType);

		if (type == 'MIXED' &&
			members.some(m => m instanceof ChildElementGroup))
			
			throw new HTE(msg.mixedDepth);
	}

	clone() {
		clone              = super.clone();
		clone[$type]       = this[$type];
		clone[$quantifier] = this[$quantifier];

		return clone;
	}

	get quantifier() {
		return this[$quantifier];
	}

	set quantifier(str) {
		if (str === undefined || str === null)
			str = '';

		str = String(str).trim();

		if (!isValid.quantifier(str))
			throw new HTE(msg.invalidQuantifier, str);

		if (this[$type] == 'MIXED' && str && str != '*')
			throw new HTE(msg.mixedQuantifier, str);

		if (this[$type] == 'ANY' || this[$type] == 'EMPTY')
			throw new HTE(msg.anyEmptyQuantifier, str);

		this[$quantifier] = str;
	}

	get type() {
		return this[$type];
	}

	set type(str) {
		if (str === undefined || str === null)
			str = 'CHOICE';

		str = String(str).trim().toUpperCase();

		if (str == 'SEQUENCE' || str == 'CHOICE')
			this[$type] = str;
		else
			throw new HTE(msg.invalidCEGType, str);
	}

	toString({ withNS=true }) {
		if (this.type == 'ANY' || this.type == 'EMPTY')
			return this.type;

		const joiner     = this.type == 'SEQUENCE' ? ', ' : '|';
		const quantifier = this.quantifier;
		const children   = this.map(m => m.toString({ withNS }));

		if (this.type == 'MIXED')
			if (children.length)
				return `(#PCDATA | ${ children.join(joiner) })${ quantifier }`;
			else
				return '(#PCDATA)';
		else if (children.length)
			return `(${ children.join(joiner) })${ quantifier }`;
		else
			throw new HTE(msg.invalidContentSpec);
	}
}

class RootChildElementGroup extends ChildElementGroup {
	constructor() {
		super();
	}

	get type() {
		return this[$type];
	}

	set type(str) {
		if (str === undefined || str === null)
			str = 'CHOICE';

		str = String(str).trim().toUpperCase();

		if (str == 'SEQUENCE' || str == 'CHOICE') {
			this[$type] = str;

		} else if (str == 'MIXED') {

			this[$type] = str;
			this[$array] = this.filter(m => m instanceof ChildElementName);

			if (this.quantifier && this.quantifier != '*')
				this.quantifier = '';

		} else if (str == 'ANY' || str == 'EMPTY') {
			this[$type] = str;
			this[$array].length = 0;
			this.quantifier = '';

		} else {
			throw new HTE(msg.invalidCEGType, str);
		}
	}
}

class AttributeDefinitions extends Children {
	constructor() {
		super();

		this[$constructors] = [ AttributeDefinition ];
	}

	toString({ d=0, pretty=true, quote='"', tab='\t', withNS=true }={}) {
		if (!this.length) return '';

		return this
			.map(m => m.toString({ d, pretty, quote, tab, withNS }))
			.join(tab ? '\n' : ' ');
	}
}

class ElementAttributes extends Children {
	constructor() {
		super();

		this[$constructors] = [ Attribute ];
	}

	[$validate2](orig) {
		const arr = this[$array];

		try {
			const keys = arr.map(attr => attr.key);

			for (const key of keys)
				if (~keys.indexOf(key, keys.indexOf(key) + 1))
					throw new HTE(msg.duplicateAttrKey, key);

		} catch (err) {
			this[$array] = orig;
			throw err;
		}
	}

	getAttribute({ namespace, key }) {
		return this.find(
			attr => (attr.namespace == namespace) && (attr.key === key)
		);
	}

	setAttribute({ namespace, key, value }) {
		const existingMember = this.getAttribute({ namespace, key });

		if (existingMember)
			existingMember.value = value;
		else
			this.push(new Attribute({ namespace, key, value }));
	}

	removeAttribute({ namespace, key }) {
		const index = this[$array].findIndex(
			attr => attr.namespace == namespace && attr.key === key
		);

		if (~index)
			return this[$array].splice(index, 1);
	}

	toString({ pretty=true, quote='"', withNS=true }={}) {
		return this[$array].map(
			attr => attr.toString({ pretty, quote, withNS })
		).join(' ');
	}
}

class ElementChildren extends Children {
	constructor() {
		super();

		this[$constructors] = [
			CDATASection,
			Comment,
			Element,
			ProcessingInstruction,
			Text
		];
	}
}

// ABSTRACT NODES //////////////////////////////////////////////////////////////

class NodeWithChildren extends Node {
	constructor(ChildrenConstructor) {
		super();

		this[$childrenConstructor] = ChildrenConstructor;
		this.children = new ChildrenConstructor();
	}

	get [$$kids]() { return this.children; }

	get children() {
		return this[$children];
	}

	set children(val) {
		if (val instanceof this[$childrenConstructor]) {
			this[$children] = val;
			val[$parent] = this;
		} else {
			throw new HTE(msg.illegalChildren, val);
		}
	}

	clone() {	
		const clone = new this.constructor(this);

		clone.children = this.children.clone();

		return clone;
	}

	* descendents() {
		// Note that we yield descendents in ‘tiers,’ rather than immediately
		// recursing on each child’s tree. The result does not include nodes
		// like ‘Attribute’ and ‘ChildElementName’.

		let children = [ ...this.children ];

		while (children.length) {

			const child = children.shift();

			yield child;

			if (child.children && child.children.length)
				children.push(...child.children);
		}
	}

	findNearestDescendent(predicate) {
		for (const descendent of this.descendents()) {
			if (predicate(descendent))	
				return descendent;
		}
	}

	add(node) {
		this.children.push(node);
	}
}

// ROOT NODES //////////////////////////////////////////////////////////////////

// When parsing, the goal is either a valid Document or a valid DoctypeExternal.
// The correct goal is ambiguous until reaching specific nodes that can only
// occur in one or the other.
//
// - It’s a document:
//   - Doctype
//   - An XML declaration which includes ‘standalone’
//   - Element
// - It’s an external DTD:
//   - ConditionalSection
//   - Declaration (<!ENTITY etc)
//   - ParameterReference
//
// Document places some restrictions on its children. A Doctype must occur
// before the root Element, or not at all, and there can only be a single root
// element.
//
// The external DTD is like the ‘children’ part of Doctype, but it may also
// begin with an xml declaration (called a text declaration in this context...)
// like Document.

export class Document extends NodeWithChildren {
	constructor({ version, encoding, standalone, children=[] }={}) {
		super(DocumentChildren);

		this.version    = version;
		this.encoding   = encoding;
		this.standalone = standalone;

		for (const child of children)
			this.children.push(child);

		// Cannot confirm validity here.
	}

	clone() {
		const clone = new Document({
			version: this.version,
			encoding: this.encoding,
			standalone: this.standalone
		});

		clone.children = this.children.clone();

		return clone;
	}

	get [$$self]() {
		const self = {};

		if (this.version) self.$version = this.version;
		if (this.encoding) self.$encoding = this.encoding;
		if (this.standalone) self.$standalone = this.standalone;

		return self;
	}

	@commonAccessor
	get version() {}
	set version(x) {}

	@commonAccessor
	get encoding() {}
	set encoding(x) {}

	get standalone() {
		return this[$standalone];
	}

	set standalone(val) {
		if (typeof val == 'boolean') {
			this[$standalone] = val;
		} else if (val instanceof Boolean) {
			this[$standalone] = !!val;
		} else if (val === undefined || val === null) {
			this[$standalone] = undefined;
		} else {
			val = String(val).trim();

			if (/^(yes|true)$/i.test(val))
				this[$standalone] = true;
			else if (/^(no|false)$/i.test(val))
				this[$standalone] = false;
			else
				throw new HTE(msg.invalidSDD, val);
		}
	}

	get doctype() {
		return this.children.find(m => m instanceof Doctype);
	}

	set doctype(dt) {
		if (!(dt instanceof Doctype))
			throw new HTE(msg.wrongNodeType, dt);

		const index = this.children.findIndex(m => m instanceof Doctype);

		if (~index)
			this.children.splice(index, 1, dt);
		else
			this.children.unshift(dt);
	}

	get root() {
		return this.children.find(m => m instanceof Element);
	}

	set root(el) {
		if (!(el instanceof Element))
			throw new HTE(msg.wrongNodeType, el);

		const index = this.children.findIndex(m => m instanceof Element);

		if (index)
			this.children.splice(index, 1, el);
		else
			this.children.push(el);
	}

	isValid() {
		return this.children.some(child => child instanceof Element);
	}

	toString({ d=0, pretty=true, quote='"', tab='\t', withNS=true }={}) {
		if (!this.isValid())
			throw new HTE(msg.malformedDocument);

		quote = validQuote(quote);

		const p       = indent(d, tab);
		const docArr  = [];
		const version = this.version;

		if (version) {

			const verStr =
				`version=${ quote }${ version::toVersionString() }${ quote } `;

			const encStr = this.encoding ?
				`encoding=${ quote }${ this.encoding }${ quote } ` : '';

			const sddStr = this.standalone !== undefined ?
				`standalone=${ quote }${
					this.standalone ? 'yes' : 'no'
				}${ quote } ` : '';

			docArr.push(`${ p }<?xml ${ verStr }${ encStr }${ sddStr }?>`);
		}

		docArr.push(this.children.toString({ d, pretty, quote, tab, withNS }));

		return docArr.join(tab ? '\n' : '');
	}
}

export class DoctypeExternal extends NodeWithChildren {
	constructor({ version, encoding, children=[] }={}) {
		super(DoctypeExternalChildren);

		this.version  = version;
		this.encoding = encoding;

		for (const child of children)
			this.children.push(child);
	}

	get [$$self]() {
		const self = {};
		if (this.version) self.$version = this.version;
		if (this.encoding) self.$encoding = this.encoding;

		return self;
	}

	@commonAccessor
	get version() {}
	set version(x) {}

	@commonAccessor
	get encoding() {}
	set encoding(x) {}

	toString({ d=0, pretty=true, quote='"', tab='\t', withNS=true }={}) {
		quote = validQuote(quote);
		
		const p        = indent(d, tab);
		const dtdArr   = [];
		const version  = this.version;
		const encoding = this.encoding;

		if (version || encoding) {

			const verStr = version ?
				`version=${ quote }${
					version::toVersionString()
				}${ quote } ` : '';

			const encStr = encoding ?
				`encoding=${ quote }${
					encoding
				}${ quote } ` : '';

			dtdArr.push(`${ p }<?xml ${ verStr }${ encStr }?>`);
		}

		if (this.children.length)
			dtdArr.push(
				this.children.toString({ d, pretty, quote, tab, withNS })
			);

		return dtdArr.join(tab ? '\n' : '');
	}
}

// DOCTYPE /////////////////////////////////////////////////////////////////////

// A doctype declaration specifies the location of an external definition and/or
// inline definitions. The terminology here is a little wobbly to me, but the
// contents of the DTD ‘itself’, whether internal or external, are individual
// declarations (English: definitions) for different nodes/elements/whatever
// to be used with the document in question, provided the DTD name matches the
// root node (I think...).

export class Doctype extends NodeWithChildren {
	constructor({ name, systemID, publicID }) {
		super(DoctypeChildren);

		this.name     = name;
		this.systemID = systemID;
		this.publicID = publicID;

		if (!this.isValid())
			throw new HTE(msg.malformedDTD);
	}

	get [$$name]() { return '$doctype'; }
	get [$$self]() {
		const self = {};

		if (this.name) self.$name = this.name;
		if (this.publicID) self.$publicID = this.publicID;
		if (this.systemID) self.$systemID = this.systemID;

		return self;
	}

	@commonAccessor
	get name() {}
	set name(x) {}

	@commonAccessor
	get systemID() {}
	set systemID(x) {}

	@commonAccessor
	get publicID() {}
	set publicID(x) {}

	isValid() {
		return (
			(this.name) &&
			(
				(this.systemID) ||
				(!this.systemID && !this.publicID)
			)
		);
	}

	toString({ d=0, pretty=true, quote='"', tab='\t', withNS=true }={}) {
		quote = validQuote(quote);

		const dbl = quote == '"';
		const p   = indent(d, tab);
		const nl  = tab ? '\n' : '';

		let sid        = this.systemID;
		let pid        = this.publicID;
		let externalID = '';
		let dtd        = '';

		if (sid) {

			sid = sid::safelyQuote(quote);

			if (pid) {
				pid::safelyQuote(quote);

				externalID = `PUBLIC ${ pid } ${ sid } `;
			} else {
				externalID = `SYSTEM ${ sid } `;
			}
		}

		if (this.children.length)
			dtd = ` [${ nl }${
				this.children.toString({ d: d + 1, pretty, quote, tab, withNS })
			}${ nl }${ p }]`;

		return `${ p }<!DOCTYPE ${ this.name }${ externalID }${ dtd }>`;
	}
}

// ELEMENT /////////////////////////////////////////////////////////////////////

// Elements are the bits people actually care about -- ‘tags’. In XML, unlike
// HTML, a self-closing tag must contain the closing slash (wtf were the HTML
// folks thinking to make that optional??).

export class Element extends NodeWithChildren {
	constructor({ namespace, name, text, attributes }) {
		super(ElementChildren);

		const attr =
			attributes instanceof ElementAttributes ? attributes :
			new ElementAttributes();

		this[$attributes] = attr;
		this.namespace    = namespace;
		this.name         = name;

		if (text) this.addText(text);

		if (attributes && !(attributes instanceof ElementAttributes)) {
			for (const key in attributes)
				this.setAttribute({ key, value: attributes[key] });
		}
	}

	clone() {
		clone = super.clone();

		clone.attributes = this.attributes.clone();

		return clone;
	}

	get [$$kids]() {
		return [ ...this.children, ...this.attributes ];
	}
	get [$$name]() { return this.name; }
	get [$$nmsm]() { return this.fullName; }

	get attributes() {
		return this[$attributes];
	}

	set attributes(val) {
		if (val instanceof ElementAttributes) {
			this[$attributes] = val;
			val[$parent] = this;
		} else {
			throw new HTE(msg.wrongNodeType, val);
		}
	}

	get text() {
		return this[$children].reduce((acc, m) => {

			if (m instanceof Text)
				acc.push(m[$content]::replaceKnownEntities());
			else if (m instanceof CDATASection)
				acc.push(m[$content]);
			else if (m instanceof Element)
				acc.push(m.text);

			return acc;

		}, []).join(' ').replace(/\s{2,}/g, ' ').trim();
	}

	@commonAccessor
	get name() {}
	set name(x) {}

	@commonAccessor
	get namespace() {}
	set namespace(x) {}

	@commonAccessor
	get fullName() {}

	addText(str) {
		const text = new Text(str);
		this.children.push(text);
	}

	getAttribute() {
		return this.attributes.getAttribute(...arguments);
	}

	setAttribute() {
		return this.attributes.setAttribute(...arguments);
	}

	removeAttribute() {
		return this.attributes.removeAttribute(...arguments);
	}

	toString({ d=0, pretty=true, quote='"', tab='\t', withNS=true }={}) {
		const html = this instanceof HTMLElement;
		const asc  = this instanceof HTMLElementASC;
		const pre  = [ ...this.lineage() ].some(
			e => e instanceof HTMLElementPre
		);
		
		const p  = indent(d, tab);
		const nl = (tab && !pre) ? '\n' : '';

		const attributes =
			this.attributes.toString({ pretty, quote, withNS });

		const openTag =
			(withNS ? this.fullName : this.name) +
			(attributes ? ` ${ attributes }` : '');

		if (!this.children.length) {
			if (html && !asc)
				return `${ p }<${ openTag }></${ this.name }>`;
			else
				return `${ p }<${ openTag }/>`;
		} else {
			const children = this.children.toString(
				{ d: d + 1, pretty, quote, tab, withNS }
			);

			const initPre = (pre && !children.startsWith('\n')) ? '\n' : '';
			const endPre = pre ? '' : `\n${ p }`;

			return `${ p }<${ openTag }>${ nl }${ initPre }${
				children
			}${ endPre }</${ this.name }>`;
		}
	}
}

export class DocumentFragment extends NodeWithChildren {
	constructor() {
		super(ElementChildren);
	}

	toString({ d=0, pretty=true, quote="", tab='\t', withNS=true }={}) {
		return this.children.toString({ d, pretty, quote, tab, withNS });
	}
}

// ATTRIBUTE ///////////////////////////////////////////////////////////////////

// Attributes in XML, unlike HTML, must have values (even if they’re just empty
// strings) and those values must be quoted. Entities are processed inside the
// values, and ampersand and less-than must be represented as entities.
// Depending on the quote used as the delimiter, instances of that will also
// require entity-escaping.

export class Attribute extends Node {
	constructor({ namespace, key, value }) {
		super();

		this.namespace = namespace;
		this.key       = key;
		this.value     = value;
	}

	get [$$name]() { return this.key; }
	get [$$nmsm]() { return this.fullName; }
	get [$$self]() { return this.value; }

	get key() {
		return this[$key];
	}

	set key(str) {
		str = String(str).trim();

		if (isValid.nameStr(str))
			this[$key] = str;
		else
			throw new HTE(msg.invalidName, str);
	}

	@commonAccessor
	get namespace() {}
	set namespace(x) {}

	@commonAccessor
	get value() {}
	set value(x) {}

	get fullName() {
		return this.namespace ? `${ this.namespace }:${ this.key }` : this.key; 
	}

	toString({ pretty=true, quote='"', withNS=true }) {
		quote = validQuote(quote);

		let value = this.value::escapeQuote(quote);

		if (pretty) value = value::norm();

		const key = withNS ? this.fullName : this.key;

		return `${ key }=${ quote }${ value }${ quote }`;
	}
}

// COMMENT /////////////////////////////////////////////////////////////////////

// Comments can occur nearly anywhere, and their content’s only restriction is
// to disallow the sequence ‘--’ (even if not followed by >). The way the
// valid pattern works, the closing sequence may not be ‘--->’, though we will
// automatically correct both of these things in the setter. However the open
// sequence can be ‘<!---’. 

export class Comment extends Node {
	constructor(content) {
		super();

		if (content instanceof Object && content.content)
			content = content.content;

		this.content = content;
	}

	get [$$name]() { return '$comment'; }
	get [$$self]() { return this.content.replace(/\s+/g, ' ').trim(); }

	get content() {
		return this[$content];
	}

	set content(str) {
		if (str === undefined || str === null) {
			this[$content] = '';
		} else {
			str = String(str).replace(/-(?=-|$)/g, '- ');

			if (!isValid.commentContent(str))
				throw new HTE(msg.invalidComment, str);

			this[$content] = str;
		}
	}

	toString({ d=0, pretty=true, tab='\t' }={}) {
		const p = indent(d, tab);

		if (!pretty)
			return `${ p }<!--${ this.content }-->`;
		else if (this.content.length <= prettyLength)
			return `${ p }<!-- ${ this.content::norm() } -->`;
		
		return (
			`${ p }<!--\n${ this.content::toPrettyLines(p + tab) }\n${ p }-->`
		);
	}
}

// TEXT ////////////////////////////////////////////////////////////////////////

// Text nodes can occur inside Elements. They must escape ampersands, less-than
// signs, and greater-than signs when they occur in the sequence ']]>'. In fact
// whitespace text nodes (of a sort?) may occur outside Elements as well, and
// are considered part of the document structure even though their only purpose
// then would be to create an unnavigable barf party -- which is why this, and
// many other parsers I think, ignore that part of the XML spec.

export class Text extends Node {
	constructor(content) {
		super();

		if (content instanceof Object && content.content)
			content = content.content;

		this.content = content;
	}

	get [$$name]() { return '$text'; }
	get [$$self]() { return this.cleanContent; }

	get content() {
		return this[$content];
	}

	set content(str) {
		if (str === undefined || str === null) {
			this[$content] = '';
		} else {
			str = String(str)
				::replaceQuoteEntities()
				::replaceGTEntity() // all &gt; to >
				::replaceLiteralThingie() // > to &gt; but only when needed
				::replaceLiteralAmp()
				::replaceLiteralLT();

			if (isValid.charData(str))
				this[$content] = str;
			else
				throw new HTE(msg.invalidText, str);
		}
	}

	get cleanContent() {
		return this[$content]::replaceKnownEntities();
	}

	toString({ d=0, pretty=true, tab='\t' }={}) {
		const p    = indent(d, tab);
		const text = this.content;

		if (this.parents.some(e => e instanceof HTMLElementPre))
			return text;

		if (pretty)
			return text::toPrettyLines(p);
		else
			return p + text;
	}
}

// PROCESSING INSTRUCTIONS /////////////////////////////////////////////////////

// A processing instruction is a directive targetting some interpretting agent.
// They can appear in most places, and their only required attribute is `target`
// which identifies the agent in question (it may not be 'xml'). The instruction
// is any string not including the termination sequence '?>'.

export class ProcessingInstruction extends Node {
	constructor({ target, instruction }) {
		super();

		this.target      = target;
		this.instruction = instruction;
	}

	get [$$name]() { return '$processingInstruction'; }
	get [$$self]() {
		const self = {};

		if (this.target) self.$target = this.target;
		if (this.instruction) self.$instruction = this.instruction;

		return self;
	}

	get target() {
		return this[$target];
	}

	set target(str) {
		str = String(str).trim();

		if (isValid.piTarget(str))
			this[$target] = str;
		else
			throw new HTE(msg.invalidTarget, str);
	}

	get instruction() {
		return this[$instruction];
	}

	set instruction(str) {
		if (str === undefined || str === null)
			this[$instruction] = '';
		else if (isValid.piInstruction(str))
			this[$instruction] = str;
		else
			throw new HTE(msg.invalidInstruction, str);
	}

	toString({ d=0, pretty=true, tab='\t' }={}) {
		const p = indent(d, tab);

		if (!pretty)
			return `${ p }<?${ this.target } ${ this.instruction }?>`;

		const instruction = this.instruction::norm();

		if (instruction.length <= prettyLength)
			return `${ p }<?${ this.target } ${ instruction } ?>`;
		
		return (
			`${ p }<?${ this.target }\n${
				instruction::toPrettyLines(p + tab)
			}\n${ p }?>`
		);
	}
}

// MARKED SECTIONS /////////////////////////////////////////////////////////////

// A marked section is one taking the pattern <![NAME[CONTENT]]>. There are
// only three types, technically: CDATA, IGNORE, and INCLUDE, and of these only
// the first is common.
//
// CDATA allows the inclusion of literal character data
// without entity escaping; it ‘resolves’ to its text content, and therefore may
// only appear in positions that text nodes may appear in. It may not contain
// the sequence ‘]]>’ internally.
//
// IGNORE and INCLUDE are called ‘conditional sections’ and they’re a bit
// arcane. Both may only appear in an ‘external subset,’ which is like a DTD’s
// internal subset except it appears in a standalone file. Why they cannot
// appear in an internal subset I’m not sure.
//
// Both may contain anything a DTD can contain; the contents are just being
// ‘sectioned off’. They’re not particularly useful on their own because an
// INCLUDE section means the same as not having wrapped it at all, and an IGNORE
// section is simply ignored. However, while marked sections only have three
// keywords, it is possible to use parameter references that resolve to these
// words, which is what introduces their conditional nature: by changing the
// entity reference definition, you can toggle various DTD sections that depend
// on it.
//
// Technically, an IGNORE section’s content isn’t even parsed as DTD content, so
// it’s just a bunch of ignored text. Unlike CDATA, it may include ‘]]>’ so long
// as it was preceded by a matching ‘<![’. But realistically, it is understood
// that IGNORE contents are in fact DTD content. We do parse them as such
// because our goal is to produce an editable / transformable tree, not to
// render content.

class MarkedSection extends Node {
	constructor(keyword, content) {
		super();

		this[$keyword] = keyword;
		this.content   = content;
	}

	toString({ d=0, pretty=true, quote='"', tab='\t', withNS=true }={}) {
		const p      = indent(d, tab);
		const nl     = tab ? '\n' : '';
		const prefix = `${ p }<![${ this[$keyword] }[`;

		const children = this.children && this.children.length &&
			this.children.toString({ d: d + 1, pretty, quote, tab, withNS });

		let content = this.content;

		if (!content && !children)
			return prefix + ']]>';

		if (children)
			return `${ prefix }${ nl }${ children }${ nl }${ p }]]>`;

		if (pretty) {
			const pp = p + tab;

			if (content.length <= prettyLength) {
				return `${ prefix } ${ content } ]]>`;
			} else {
				content = content
					.split('\n')
					.map(line => pp + line.trim())
					.join('\n');

				return `${ prefix }\n${ content }\n${ p }]]>`;
			}
		} else {
			return prefix + content + ']]>';
		}
	}
}

export class CDATASection extends MarkedSection {
	constructor(content) {
		if (content instanceof Object && content.content)
			content = content.content;

		super('CDATA', content);
	}

	get [$$name]() { return '$text'; }
	get [$$self]() { return this.content; }

	get content() {
		return this[$content];
	}

	set content(val) {
		if (val == undefined || val == null)
			val = '';

		if (isValid.cdataContent(val))
			this[$content] = val;
		else
			throw new HTE(msg.invalidCDATA, val);
	}
}

export class ConditionalSection extends MarkedSection {
	constructor(keyword) {
		super();

		if (keyword instanceof Object && keyword.keyword)
			keyword = keyword.keyword;

		this.keyword    = keyword;
		this[$children] = new DoctypeExternalChildren();
	}

	clone() {
		const clone = super.clone();

		clone.children = this.children.clone();

		return clone;
	}

	get [$$kids]() { return this.children; }
	get [$$name]() { return '$conditionalSection'; }
	get [$$self]() {
		return {
			$keyword: this.keyword
		};
	}

	get content() { return undefined; }
	set content(val) { }

	get children() {
		return this[$children];
	}

	set children(val) {
		if (val instanceof DoctypeExternalChildren) {
			this[$children] = val;
			val[$parent] = this;
		} else {
			throw new HTE(msg.illegalChild, val);
		}
	}

	get keyword() {
		return this[$keyword];
	}

	set keyword(str) {
		str = String(str);

		if (str == 'IGNORE' || str == 'INCLUDE') {
			this[$keyword] = str;
			return;
		}

		if (str.startsWith('%') && str.endsWith(';'))
			str = str.slice(1, -1);

		if (isValid.nameStr(str))
			this[$keyword] = `%${ str };`;
		else
			throw new HTE(msg.invalidConditionalKeyword, str);
	}
}

// DTD CONTENTS ////////////////////////////////////////////////////////////////

// Though parameter references (%abc;) may, like entity references (&abc;)
// appear in contexts where they aren’t considered nodes in themselves to us,
// in the context of a DTD they may occur as children in isolation.

export class ParameterReference extends Node {
	constructor(name) {
		super();

		if (name instanceof Object && name.name)
			name = name.name;

		this.name = name;
	}

	get [$$name]() { return '$parameterReference'; }
	get [$$self]() { return this.name; }

	get name() {
		return this[$name];
	}

	set name(str) {
		str = String(str);

		if (str.startsWith('%') && str.endsWith(';'))
			str = str.slice(1, -1);

		if (isValid.nameStr(str))
			this[$name] = `%${ str };`;
		else
			throw new HTE(msg.invalidPR, str);
	}

	toString({ d=0, tab='\t' }={}) {
		return indent(d, tab) + this.name;
	}
}

// The generic Declaration class provides the common name accessors. Note that
// EntityDeclaration is not a subclass of this because it doesn’t have the same
// type of name as the others.

class Declaration extends Node {
	constructor(namespace, name) {
		super();

		this.name      = name;
		this.namespace = namespace;

		// Cannot validate here
	}

	@commonAccessor
	get name() {}
	set name(x) {}

	@commonAccessor
	get namespace() {}
	set namespace(x) {}

	@commonAccessor
	get fullName() {}

	isValid() {
		return !!this.name;
	}
}

// An element declaration has one of several types of ‘legal children’ lists or
// statements, and the lists can be nested, making this somewhat tough to model.

export class ElementDeclaration extends Declaration {
	constructor({ namespace, name, quantifier='', type='CHOICE' }) {
		super(namespace, name);

		this[$contentSpec] = new RootChildElementGroup();
		this[$contentSpec][$PARENT] = this;

		this.type       = type;
		this.quantifier = quantifier;

		// Validity cannot be checked here.
	}

	clone() {
		const clone = super.clone();

		clone[$contentSpec] = this.contentSpec.clone();
		clone[$contentSpec][$parent] = clone;

		return clone;
	}

	get [$$name]() { return `$element_${ this.name }`; }
	get [$$nmsm]() { return `$element_${ this.fullName }`; }
	get [$$self]() {
		return {
			$contentSpec: this.contentSpec.toString() // eh who cares
		};
	}

	get contentSpec() {
		return this[$contentSpec];
	}

	get quantifier() {
		return this[$contentSpec][$quantifier];
	}

	set quantifier(val) {
		this[$contentSpec].quantifier = val;
	}

	get type() {
		return this[$contentSpec][$type];
	}

	set type(val) {
		this[$contentSpec].type = val;
	}

	isValid() {
		return !(
			(!this.name) ||
			(!this.type && !this.contentSpec.length) ||
			(
				(this.type == 'ANY' || this.type == 'EMPTY') &&
				(this.contentSpec.length || this.quantifier)
			)
		);
	}

	toString({ d=0, pretty=true, tab='\t', withNS=true }={}) {
		if (!this.isValid())
			throw new HTE(msg.elementDeclMalformed);

		const name = withNS ? this.fullName : this.name;
		const spec = this.contentSpec.toString({ withNS });
		const p    = indent(d, tab);

		return `${ p }<!ELEMENT ${ name } ${ spec }>`;
	}
}

// The ChildElementName class represents references to elements by their names
// for use in the ‘permitted children’ part of an ElementDeclaration. While
// ChildElementGroups can be nested, at the ‘leaf’ parts of the resulting tree,
// the ultimate children must always be ChildElementNames.

export class ChildElementName extends Declaration {
	constructor({ namespace, name, quantifier }) {
		super(namespace, name);

		this.quantifier = quantifier;
	}

	get quantifier() {
		return this[$quantifier];
	}

	set quantifier(str) {
		if (this.parent && this.parent.type == 'MIXED')
			throw new HTE(msg.mixedQuantifier, str);

		if (str === undefined || str === null)
			str = '';

		str = String(str).trim();

		if (!isValid.quantifier(str))
			throw new HTE(msg.invalidQuantifier, str);

		this[$quantifier] = str;
	}

	toString({ withNS=true }) {
		return `${ withNS ? this.fullName : this.name }${ this.quantifier }`;
	}
}

// The AttListDeclaration defines attributes for an element specified by name.
// I’m not sure why they’re not just part of ElementDeclaration since they are
// element-specific.

export class AttListDeclaration extends Declaration {
	constructor({ namespace, name }) {
		super(namespace, name);

		this[$attributes] = new AttributeDefinitions();
	}

	clone() {
		const clone = super.clone();

		clone.defs = this.defs.clone();

		return clone;
	}

	get [$$kids]() { return this.defs; }
	get [$$name]() { return `$attList_${ this.name }`; }
	get [$$nmsm]() { return `$attList_${ this.fullName }`; }

	get defs() {
		return this[$attributes];
	}

	set defs(val) {
		if (val instanceof AttributeDefinitions) {
			this[$attributes] = val;
			val[$parent] = this;
		} else {
			throw new HTE(msg.wrongNodeType, val);
		}
	}

	toString({ d=0, pretty=true, quote='"', tab='\t', withNS=true }={}) {
		const p = indent(d, tab);

		const defs =
			this.defs.toString({ d: d + 1, pretty, quote, tab, withNS });

		if (!defs || !tab)
			return `${ p }<!ATTLIST ${ this.name }${
				defs ? ` ${ defs } ` : ''
			}>`;

		return `${ p }<!ATTLIST ${ this.name }\n${ defs }>`
	}
}

// A single AttributeDefinition has a type, a defaultType, and possibly members
// and a defaultValue, depending on the type and defaultType. There may be
// better terminology for these things but I couldn’t find it. In the docs it’ll
// be explained by example.

export class AttributeDefinition extends Declaration {
	constructor({ defaultType, defaultValue, members, name, namespace, type }) {
		super(namespace, name);

		this.type         = type;
		this.defaultType  = defaultType || 'IMPLIED';
		this.defaultValue = defaultValue;
		this.members      = members;

		if (!this.isValid())
			throw new HTE(msg.malformedAttrDef);
	}

	get [$$name]() { return this.name; }
	get [$$nmsm]() { return this.fullName; }
	get [$$self]() {
		const self = {};

		if (this.type) self.$type = this.type;
		if (this.members) self.$members = this.members;
		if (this.defaultType) self.$defaultType = this.defaultType;
		if (this.defaultValue) self.$defaultValue = this.defaultValue;

		return self;
	}

	get type() {
		return this[$type];
	}

	set type(val) {
		if (val === undefined || val === null || val === '') {

			this[$type] = '';

			const members = this[$members] || [];

			this.members = members.filter(m => isValid.nmToken(m));

		} else {

			val = String(val).trim().toUpperCase();

			if (isValid.stringOrTokenizedType(val)) {

				this[$type] = val;

				if (val == 'NOTATION') {

					const members = this[$members] || [];

					this.members = members.filter(m => isValid(name));

				} else {
					this.members = [];
				}

			} else {
				throw new HTE(msg.invalidAttDefType, val);
			}
		}
	}

	get defaultType() {
		return this[$defaultType];
	}

	set defaultType(str) {
		if (str === undefined || str === null || str === '') {
			this[$defaultType] = '';
		} else {
			str = String(str).trim().toUpperCase();

			if (!str.startsWith('#')) str = '#' + str;

			if (isValid.defaultType(str))
				this[$defaultType] = str;
			else
				throw new HTE(msg.invalidDefaultType, str);
		}
	}

	@commonAccessor
	get defaultValue() {}
	set defaultValue(x) {}

	get members() {
		return this[$members] && this[$members].slice();
	}

	set members(val) {
		if (val === undefined || val === null ||
			(val instanceof Array && !val.length)) {

			this[$members] = undefined;
		} else {

			if (!(val instanceof Array))
				throw new HTE(msg.attDefMembersArr, val);

			val = val.map(m => String(m));

			if (!this.type || this.type == 'NOTATION') {

				const thing = this.type ? 'name' : 'nmToken';

				if (val.every(m => isValid[thing](m)))
					this[$members] = val;
				else
					throw new HTE(msg.attDefMembersString, val);
			} else {
				throw new HTE(msg.attDefMembersConflict, val);
			}
		}
	}

	isValid() {
		return (
			(this.name) &&
			(
				(this.members && this.members.length) ||
				(this.type && this.type != 'NOTATION')
			) &&
			(
				this.defaultValue ||
				(this.defaultType && this.defaultType != 'FIXED')
			)
		);
	}

	toString({ d=0, pretty=true, quote='"', tab='\t', withNS=true }={}) {
		if (!this.isValid())
			throw new HTE(msg.malformedAttrDef);

		quote = validQuote(quote);

		const p = indent(d, tab);
		const name = withNS ? this.fullName : this.name;

		const nc = !pretty || (name.length >= prettyColumn) ? ' ' :
			new Array(prettyColumn - name.length + 1).join(' ');

		const type = `${
			this.type ? this.type + ' ' : ''
		}${
			this.members && this.members.length ?
			`(${ this.members.join('|')})` : ''
		}`;

		const tc = !pretty || (type.length >= prettyColumn) ||
			(name.length >= prettyColumn) ? ' ' :
			new Array(prettyColumn - type.length + 1).join(' ');

		let defaultStr = '';

		if (this.defaultType && this.defaultType != '#FIXED') {
			defaultStr = this.defaultType;
		} else {
			if (this.defaultType == '#FIXED') defaultStr = '#FIXED ';
			defaultStr += this.defaultValue::safelyQuote(quote);
		}

		return `${ p }${ name }${ nc }${ type }${ tc }${ defaultStr }`;
	}
}

// An entity declaration can define the value of an entity reference (e.g. &lt;)
// or of a ... a percent-sign one. Which ... I think is a ‘parameter entity’.
// Honestly the spec seems pretty opaque on what a lot of stuff actually means.

export class EntityDeclaration extends Node {
	constructor({ isParameter, name, ndata, publicID, systemID, value }) {
		super();

		this.isParameter = isParameter;
		this.name        = name;
		this.ndata       = ndata;
		this.publicID    = publicID;
		this.systemID    = systemID;
		this.value       = value;

		if (!this.isValid())
			throw new HTE(msg.malformedEntityDecl);
	}

	get [$$name]() {
		return `$entity_${ this.isParameter ? '%' : '' }${ this.name }`;
	}

	get [$$self]() {
		const self = {};

		if (this.ndata) self.$ndata = this.ndata;
		if (this.publicID) self.$publicID = this.publicID;
		if (this.systemID) self.$systemID = this.systemID;
		if (this.value) self.$value = this.value;

		return self;
	}

	get isParameter() {
		return this[$isParameter];
	}

	set isParameter(val) {
		this[$isParameter] == !!val;
		this[$ndata] = undefined;
	}

	get name() {
		return this[$name];
	}

	set name(str) {
		str = String(str).trim();

		if (isValid.nameStr(str))
			this[$name] = str;
		else
			throw new HTE(msg.invalidName, str);
	}

	get ndata() {
		return this[$ndata];
	}

	set ndata(str) {
		if (str === undefined || str === null) {
			this[$ndata] = undefined;
		} else {
			str = String(str).trim();

			if (isValid.nameStr(str))
				this[$name] = str;
			else
				throw new HTE(msg.invalidNDATAStr, str);
		}
	}

	@commonAccessor
	get publicID() {}
	set publicID(x) {}

	@commonAccessor
	get systemID() {}
	set systemID(x) {}

	get value() {
		return this[$val]
	}

	set value(str) {
		if (str === undefined || str === null) {
			this[$symbol] = undefined;
		} else {
			str = String(str)
				::replaceLiteralAmp()
				::replaceQuoteEntities();

			if (isValid.entityValue(str))
				this[$symbol] = str;
			else
				throw new HTE(msg.invalidValue, str);
		}	
	}

	isValid() {
		return !(
			(!this.name) ||
			(this.value && (this.systemID || this.publicID)) ||
			(!this.value && !this.systemID) ||
			((this.value || this.isParameter) && this.ndata)
		);
	}

	toString({ d=0, pretty=true, quote='"', tab='\t' }={}) {
		if (!this.isValid())
			throw new HTE(msg.malformedEntityDecl);

		quote = validQuote(quote);

		const p = indent(d, tab);

		const prefix = this.isParameter ? '% ' : '';

		const val   = this.value && this.value::safelyQuote(quote);
		const sid   = this.systemID && this.systemID::safelyQuote(quote);
		const pid   = this.publicID && this.publicID::safelyQuote(quote);
		const ndata = this.ndata && ` NDATA ${ this.ndata }`;

		let definition = '';

		if (val) {
			definition = val;
		} else if (pid) {
			definition = `PUBLIC ${ pid } ${ sid }${ ndata }`;
		} else if (sid) {
			definition = `SYSTEM ${ sid }${ ndata }`
		}

		return `${ p }<!ENTITY ${ prefix }${ this.name } ${ definition }>`;
	}
}

// A NotationDeclaration does -- presumably -- something.

export class NotationDeclaration extends Declaration {
	constructor({ name, namespace, publicID, systemID }) {
		super(namespace, name);

		this.publicID = publicID;
		this.systemID = systemID;

		if (!this.isValid())
			throw new HTE(msg.malformedNotationDecl);
	}

	get [$$name]() { return `$notation_${ this.name }`; }
	get [$$nmsm]() { return `$notation_${ this.fullName }`; }
	get [$$self]() {
		return {
			$publicID: this.publicID,
			$systemID: this.systemID
		};
	}

	@commonAccessor
	get systemID() {}
	set systemID(x) {}

	@commonAccessor
	get publicID() {}
	set publicID(x) {}

	isValid() {
		return !!(this.name && (this.systemID || this.publicID));
	}

	toString({ d=0, quote='"', tab='\t' }={}) {
		if (!this.isValid()) throw new HTE(msg.malformedNotationDecl);

		quote = validQuote(quote);

		const sid = this.systemID && this.systemID::safelyQuote(quote);
		const pid = this.publicID && this.publicID::safelyQuote(quote);

		let id = '';

		if (pid && !sid)
			id = `PUBLIC ${ pid }`;
		else if (pid && sid)
			id = `PUBLIC ${ pid } ${ sid }`;
		else if (sid)
			id = `SYSTEM ${ sid }`;

		return `${ indent(d, tab) }<!NOTATION ${ this.name }${ id }>`;
	}
}

// HTML ELEMENTS ///////////////////////////////////////////////////////////////

const knownAttribute = (target, name, descriptor) => {
	
	descriptor.get = function() {
		const attr = this.getAttribute({ key: name });
		return attr && attr.value;
	}

	descriptor.set = function(value) {
		return this.setAttribute({ key: name, value });
	}

	return descriptor;
};

const lowercase = (target, name, descriptor) => {
	const { set } = descriptor;

	descriptor.set = function(val) {
		if (val === undefined || null)
			return this::set(val);
		else
			return this::set(String(val).toLowerCase());
	};

	return descriptor;
};

export class HTMLAttribute extends Attribute {
	constructor() {
		super();
	}

	get key() {
		return this[$key];
	}

	set key(str) {
		str = String(str).trim().toLowerCase();

		if (isValid.nameStr(str))
			this[$key] = str;
		else
			throw new HTE(msg.invalidName, str);
	}

	@commonAccessor
	@lowercase
	get namespace() {}
	set namespace(x) {}
}

class HTMLElementAttributes extends ElementAttributes {
	constructor() {
		super();

		this[$constructors] = [ HTMLAttribute ];
	}

	getAttribute({ namespace, key }) {
		namespace = namespace.toLowerCase();
		key       = key.toLowerCase();

		return super.getAttribute({ namespace, key });
	}

	setAttribute({ namespace, key, value }) {
		namespace = namespace.toLowerCase();
		key       = key.toLowerCase();

		return super.setAttribute({ namespace, key, value });
	}

	removeAttribute({ namespace, key }) {
		namespace = namespace.toLowerCase();
		key       = key.toLowerCase();

		return super.removeAttribute({ namespace, key });
	}
}

export class HTMLElement extends Element {
	constructor({ namespace, name, text, attributes }) {
		name = name.toLowerCase();

		super(...arguments);

		if (!namespace) {
			if (!(this instanceof HTMLElementASC) && HTMLElementASC.nodes[name])
				return new HTMLElementASC({ name, text, attributes });
			if (!(this instanceof HTMLElementPre) && HTMLElementPre.nodes[name])
				return new HTMLElementPre({ name, text, attributes });
		}
	}

	addClass(name) {
		const classStr = this.class || '';
		const classes  = classStr.split(/\s+/g).filter(c => c);
		const classSet = new Set(classes);

		classSet.add(name);

		this.class = [ ...classSet ].join(' ');
	}

	hasClass(name) {
		if (!this.class)
			return false;

		const classes = this.class.split(/\s+/g);

		return !!~classes.indexOf(name);
	}

	removeClass(name) {
		const classStr = this.class || '';
		const classes  = classStr.split(/\s+/g).filter(c => c);
		const classSet = new Set(classes);

		classSet.delete(name);

		this.class = [ ...classSet ].join(' ');
	}

	get attributes() {
		return this[$attributes];
	}

	set attributes(val) {
		if (val instanceof ElementAttributes) {
			const attrs = new HTMLElementAttributes();

			for (const attr of val)
				attrs.setAttribute(attr);

			attrs[$parent] = this;
			this[$attributes] = attrs;
		} else if (val instanceof HTMLElementAttributes) {
			val[$parent] = this;
			this[$attributes] = val;
		} else {
			throw new HTE(msg.wrongNodeType, val);
		}
	}

	@commonAccessor
	@lowercase
	get name() {}
	set name(x) {}

	@commonAccessor
	@lowercase
	get namespace() {}
	set namespace(x) {}

	@knownAttribute
	get alt() {}
	set alt(x) {}

	@knownAttribute
	get 'class'() {}
	set 'class'(x) {}

	@knownAttribute
	get dir() {}
	set dir(x) {}

	@knownAttribute
	get height() {}
	set height(x) {}

	@knownAttribute
	get href() {}
	set href(x) {}

	@knownAttribute
	get id() {}
	set id(x) {}

	@knownAttribute
	get lang() {}
	set lang(x) {}

	@knownAttribute
	get placeholder() {}
	set placeholder(x) {}

	@knownAttribute
	get src() {}
	set src(x) {}

	@knownAttribute
	get style() {}
	set style(x) {}

	@knownAttribute
	get title() {}
	set title(x) {}

	@knownAttribute
	get translate() {}
	set translate(x) {}

	@knownAttribute
	get type() {}
	set type(x) {}

	@knownAttribute
	get value() {}
	set value(x) {}

	@knownAttribute
	get width() {}
	set width(x) {}
}

export class HTMLElementASC extends HTMLElement {
	constructor() {
		super(...arguments);
	}
}

HTMLElementASC.nodes = {
	area: true,
	base: true,
	br: true,
	col: true,
	command: true,
	embed: true,
	hr: true,
	img: true,
	input: true,
	keygen: true,
	link: true,
	meta: true,
	param: true,
	source: true,
	track: true,
	wbr: true	
};

export class HTMLElementPre extends HTMLElement {
	constructor() {
		super(...arguments);
	}
}

HTMLElementPre.nodes = {
	pre: true,
	script: true,
	style: true
};

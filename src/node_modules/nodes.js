// IMPORTS /////////////////////////////////////////////////////////////////////

import {
	DuplicateKeyError,
	IllegalChildError,
	IncompatibleContentSpecError,
	IncompatibleQuantifierError,
	InvalidContentSpecError,
	InvalidDocumentError,
	InvalidStringError,
	InvalidVersionError
} from 'errors';

import * as isValid from 'string-validation';

// NOTES ///////////////////////////////////////////////////////////////////////

// All nodes and ‘children’ properties have ‘toString’, ‘toObject’ and ‘toJSON’
// methods. The results can be configured with an options argument, and the
// particular options vary by method, though some are shared.
//
// All three take the following option:
//
// - withNS (true) // Include or omit namespace prefixes
//
// The first yields XML. 
//
// - d (0)           // Indentation depth (mainly intended for internal use)
// - tab ('\t')      // The string to use to represent a single indent. If the
//                      value is `null` there will be no indentation or
//                      linebreaks added to the output.
// - pretty (true)   // Perform additional whitespace normalization
// - quote ('"')     // Preferred quote string (may be " or ')

// UTIL: COERCION //////////////////////////////////////////////////////////////

const replaceGTEntity = function() {
	return this.replace(/&gt;/g, '>');
};

const replaceLiteralAmp = function() {
	const parts = this.split(/(?=&)/g);

	let res = '';

	for (const part of parts) {
		if (!part.startsWith('&')) {
			res += part;
			continue;
		}

		let [ , name ] = part.match(/^&([\s\S]+);/) || [];

		if (name && (isValid.name(name) || isValid.charRef(name)))
			res += part;
		else
			res += '&amp;' + part.slice(1);
	}

	return res;
};

const replaceLiteralLT = function() {
	return this.replace(/</g, '&lt;');
};

const replaceLiteralThingie = function() {
	return this.replace(/\]\]>/g, ']]&gt;');
};

const replaceQuoteEntities = function() {
	return this.replace(/&quot;/g, '"').replace(/&apos;/g, '\'');	
};

// UTIL: TRANSFORMATION ////////////////////////////////////////////////////////

const prettyLength = 80;
const prettyColumn = 30;

const escapeQuote = function(quote) {
	const pattern  = new RegExp(quote, 'g');
	const entity   = quote == '"' ? '&quot;' : '&apos;';

	return this.replace(pattern, entity);	
};

const indent = (d, tab) => new Array(d + 1).join(tab || '');

const norm = function() {
	return this.trim().replace(/\s+/g, ' ');
};

const safelyQuote = function(quote) {
	if (~this.indexOf(quote))
		quote = quote == '"' ? '\'' : '"';

	return `${ quote }${ this }${ quote }`
};

const toPrettyLines = function(p='') {
	const words = this.trim().split(/\s+/g);

	const lines = words.reduce((lines, word) => {
		let line = lines.pop();

		if (!line) return [ word ];

		let newLine = line + ' ' + word;

		if (newLine.length > prettyLength)
			lines.push(line, word);
		else
			lines.push(newLine);

		return lines;
	}, []);

	return lines.map(line => p + line).join('\n');	
};

const toVersionString = function() {
	return this === 1 ? '1.0' : this.toString();
};

const validQuote = quote => quote == '\'' ? quote : '"';

// INTERNAL PROPERTIES /////////////////////////////////////////////////////////

const $array               = Symbol();
const $attributes          = Symbol();
const $children            = Symbol();
const $childrenConstructor = Symbol();
const $constructors        = Symbol();
const $content             = Symbol();
const $contentSpec         = Symbol();
const $encoding            = Symbol();
const $instruction         = Symbol();
const $key                 = Symbol();
const $keyword             = Symbol();
const $name                = Symbol();
const $namespace           = Symbol();
const $parent              = Symbol();
const $PARENT              = Symbol();
const $publicID            = Symbol();
const $quantifier          = Symbol();
const $standalone          = Symbol();
const $systemID            = Symbol();
const $target              = Symbol();
const $type                = Symbol();
const $validate            = Symbol();
const $validate2           = Symbol();
const $value               = Symbol();
const $version             = Symbol();

// COMMON ACCESSORS ////////////////////////////////////////////////////////////

// Not all node properties neatly align with class inheritance. To avoid
// repetition, this decorator works as a kind of accessor mix-in.

const get = $symbol => function() { return this[$symbol]; }

const getFullName = function() {
	return this.namespace ?
		`${ this.namespace }:${ this.name }` :
		this.name; 
};

const setEncoding = function(str) {
	if (val === undefined || val === null) {
		this[$encoding] = undefined;
	} else {
		val = String(val);

		if (encNamePattern.test(val))
			this[$encoding] = val;
	}
};

const setName = function(str) {
	str = String(str).trim();

	if (isValid.name(str))
		this[$name] = str;
	else
		throw new InvalidStringError();
};

const setNamespace = function(str) {
	if (str === undefined || str === null) {
		this[$namespace] = null;
	} else {
		str = String(str).trim();

		if (!~str.indexOf(':') && isValid.name(str))
			this[$namespace] = str;
		else
			throw new InvalidStringError();
	}
};

const setPublicID = function(str) {
	if (str === undefined || str === null)
		this[$publicID] = undefined;
	else if (isValid.publicID(str))
		this[$publicID] = str;
	else
		throw new InvalidStringError();
};

const setSystemID = function(str) {
	if (str === undefined || str === null)
		this[$systemID] = undefined;
	else if (isValid.systemID(str))
		this[$systemID] = str;
	else
		throw new InvalidStringError();
};

const setVersion = function(val) {
	if (val === undefined || val === null) {
		this[$version] = undefined;
	} else {
		val = parseFloat(val);

		if (val >= 1 && val < 2)
			this[$version] = val;
		else
			throw new InvalidVersionError();
	}
};

const commonAccessor = (target, name, descriptor) {
	switch (name) {
		case 'encoding':
			descriptor.get = get($encoding);
			descriptor.set = setEncoding;
			return descriptor;
		case 'fullName':
			descriptor.get = getFullName;
			return descriptor;
		case 'name':
			descriptor.get = get($name);
			descriptor.set = setName;
			return descriptor;
		case 'namespace':
			descriptor.get = get($namespace);
			descriptor.set = setNamespace;
			return descriptor;
		case 'publicID':
			descriptor.get = get($publicID);
			descriptor.set = setPublicID;
			return descriptor;
		case 'systemID':
			descriptor.get = get($systemID);
			descriptor.set = setSystemID;
			return descriptor;
		case 'version':
			descriptor.get = get($version);
			descriptor.set = setVersion;
			return descriptor;
	}
}

// NODE ////////////////////////////////////////////////////////////////////////

class Node {
	constructor() {}

	get parent() {
		return this[$PARENT];
	}

	get [$parent]() {
		return this[$PARENT];
	}

	set [$parent](parent) {
		this.remove();
		this[$PARENT] = parent;
	}

	remove() {
		if (!this[$PARENT]) return;

		const index = this[$PARENT].children.indexOf(this);

		this[$PARENT][$children].splice(index, 1);

		return this;
	}
}

// CHILDREN ////////////////////////////////////////////////////////////////////

// A variety of nodes can have a series of valid children. Initially I
// approached this by subclassing Array, which largely works now, but I was
// troubled by the fact that there was no way to elegantly deal with direct
// assignment to index, since we don’t yet have Proxy. Instead we need to
// create a sort of Proxy manually that simply doesn’t acknowledge indexes. It’s
// a bit tedious by comparison, but it’s necessary if we want to allow the
// ‘parent’ property to work correctly.
//
// The $validate private method confirms that would-be members pass muster. Some
// subclasses augment $validate with additional, more complex content rules.
//
// The ElementChildren class gets exported as DocumentFragment, since it closely
// resembles that ‘node type’ (it isn’t one really) as implemented in various
// other XML/HTML libraries.

class Children extends Node /* extends Array sort of */ {
	constructor() {
		super();

		this[$array] = [];
	}

	get [$parent]() {
		return this[$PARENT];
	}

	set [$parent](parent) {
		this.remove();
		this[$PARENT] = parent;
		this[$array].forEach(m => m[$PARENT] = parent); // already removed
	}

	[$validate](...members) {
		const constructors = this[$constructors];

		for (const member of members) {
			if (!constructors.some(Constr => member instanceof Constr))
				throw new IllegalChildError(member);
		}
	}

	// Different behavior

	join(sep='\n') {
		return this[$array].join(sep);
	}

	toLocaleString() {
		return this.toString();
	}

	toString({ d, pretty, quote, tab, withNS }) {
		return this[$array].map(
			child => child.toString({ d, pretty, quote, tab, withNS })
		).join(opts.tab === null ? '' : '\n');
	}

	// Simple proxy

	get length()        { return this[$array].length; }
	set length(val)     { this[$array].length = val; }

	entries()           { return this[$array].entries(); }
	every()             { return this[$array].every(...arguments); }
	filter()            { return this[$array].filter(...arguments); }
	find()              { return this[$array].find(...arguments); }
	findIndex()         { return this[$array].findIndex(...arguments); }
	forEach()           { return this[$array].forEach(...arguments); }
	includes()          { return this[$array].includes(...arguments); }
	indexOf()           { return this[$array].indexOf(...arguments); }
	keys()              { return this[$array].keys(); }
	lastIndexOf()       { return this[$array].lastIndexOf(...arguments); }
	map()               { return this[$array].map(...arguments); }
	reduce()            { return this[$array].reduce(...arguments); }
	reduceRight()       { return this[$array].reduceRight(...arguments); }
	reverse()           { return this[$array].reverse(); }
	some()              { return this[$array].some(...arguments); }
	sort()              { return this[$array].sort(...arguments); }
	values()            { return this[$array].values(...arguments); }

	[Symbol.iterator]() { return this[$array][Symbol.iterator](); }

	// Requiring parent change

	pop() {
		const member = this[$array].pop();

		member[$parent] = undefined;

		return member;
	}

	shift() {
		const member = this[$array].shift();

		member[$parent] = undefined;

		return member;
	}

	slice() {
		const members = this[$array].slice(...arguments);

		members.forEach(m => m[$parent] = undefined);

		return new this.constructor(...members);
	}

	// Requiring validation
	// copyWithin & fill are not proxied

	concat() {
		this[$validate](...arguments);

		const members = this[$array].concat(...arguments);
		const res     = new this.constructor(...members);

		if (res[$validate2]) res[$validate2]();

		return res;
	}

	push(...newMembers) {
		this[$validate](...newMembers);

		const orig = this[$array].slice();
		const res  = this[$array].push(...newMembers);

		if (this[$validate2])
			this[$validate2](orig);

		newMembers.forEach(m => m[$parent] = this[$parent]);

		return res;
	}

	splice(start, count, ...newMembers) {
		if (newMembers.length)
			this[$validate](newMembers);

		const orig = this[$array].slice();
		const res  = this[$array].splice(...arguments);

		if (this[$validate2])
			this[$validate2](orig);

		res.forEach(m => m[$parent] = undefined);
		newMembers.forEach(m => m[$parent] = this[$parent]);

		return res;
	}

	unshift(...newMembers) {
		this[$validate](...newMembers);

		const orig = this[$array].slice();
		const res  = this[$array].unshift(...newMembers);

		if (this[$validate2])
			this[$validate2](orig);

		newMembers.forEach(m => m.parent = this[$parent]);

		return res;
	}
}

class DocumentChildren extends Children {
	constructor() {
		super();

		this[$constructors] = [
			Comment,
			Doctype,
			Element,
			ProcessingInstruction
		];
	}

	[$validate2](orig) {
		const arr = this[$array];

		try {
			let doctypeAllowed = true;
			let elementAllowed = true;

			for (const m of arr) {

				if (m instanceof Element) {

					if (elementAllowed) {
						doctypeAllowed = false;
						elementAllowed = false;
					} else {
						throw new IllegalChildError();
					}

				} else if (m instanceof Doctype) {
					if (doctypeAllowed)
						doctypeAllowed = false;
					else
						throw new IllegalChildError();
				}
			}
		} catch (err) {
			this[$array] = orig;
			throw err;
		}
	}
}

class DoctypeChildren extends Children {
	constructor() {
		super();

		this[$constructors] = [
			Comment,
			Declaration,
			ParameterReference,
			ProcessingInstruction
		];
	}
}

class DoctypeExternalChildren extends Children {
	constructor() {
		super();

		this[$constructors] = [
			Comment,
			ConditionalSection,
			Declaration,
			ParameterReference,
			ProcessingInstruction
		];
	}	
}

export class ChildElementGroup extends Children {
	constructor() {
		super();

		this[$constructors] = [ ElementName, ElementGroup ];

		this[$quantifier] = '';

		this[$type] = 'CHOICE';
	}

	[$validate](...members) {
		const type = this[$type];

		if (members.some(m => m instanceof RootChildElementGroup))
			throw new IllegalChildError();

		if (type == 'ANY' || type == 'EMPTY')
			throw new IllegalChildError();

		if (type == 'MIXED' && members.some(m => m instanceof ElementGroup))
			throw new IllegalChildError();
	}

	get quantifier() {
		return this[$quantifier];
	}

	set quantifier(str) {
		if (str === undefined || str === null)
			str = '';

		str = String(str).trim();

		if (!isValid.quantifier(str))
			throw new InvalidStringError();

		if (this[$type] == 'MIXED' && str && str != '*')
			throw new IncompatibleQuantifierError();

		if (this[$type] == 'ANY' || this[$type] == 'EMPTY')
			throw new IncompatibleQuantifierError();

		this[$quantifier] = str;
	}

	get type() {
		return this[$type];
	}

	set type() {
		if (str === undefined || str === null)
			str = 'CHOICE';

		str = String(str).trim().toUpperCase();

		if (str == 'SEQUENCE' || str == 'CHOICE')
			this[$type] = str;
		else
			throw new InvalidStringError();
	}

	toString({ withNS=true }) {
		if (this.type == 'ANY' || this.type == 'EMPTY')
			return this.type;

		const joiner     = this.type == 'SEQUENCE' ? ', ' : ' | ';
		const quantifier = this.quantifier;
		const children   = this.map(m => m.toString({ withNS }));

		if (this.type == 'MIXED')
			if (children.length)
				return `(#PCDATA | ${ children.join(joiner) })${ quantifier }`;
			else
				return '(#PCDATA)';
		else if (children.length)
			return `(${ children.join(joiner) })${ quantifier }`;
		else
			throw new InvalidContentSpecError();
	}
}

class RootChildElementGroup extends ChildElementGroup {
	constructor() {
		super();
	}

	get type() {
		return this[$type];
	}

	set type() {
		if (str === undefined || str === null)
			str = 'CHOICE';

		str = String(str).trim().toUpperCase();

		if (str == 'SEQUENCE' || str == 'CHOICE') {
			this[$type] = str;

		} else if (str == 'MIXED') {

			this[$type] = str;
			this[$array] = this.filter(m => m instanceof ChildElementName);

			if (this.quantifier && this.quantifier != '*')
				this.quantifier = '';

		} else if (str == 'ANY' || str == 'EMPTY') {
			this[$type] = str;
			this[$array].length = 0;
			this.quantifier = '';

		} else {
			throw new InvalidStringError();
		}
	}
}

class AttributeDefinitions extends Children {
	constructor() {
		super();

		this[$constructors] = [ AttributeDefinition ];
	}

	toString({ d=0, pretty=true, quote='"', tab='\t', withNS=true }={}) {
		if (!this.length) return '';

		return this
			.map(m => m.toString({ d, pretty, quote, tab, withNS }))
			.join(tab ? '\n' : ' ');
	}
}

class ElementAttributes extends Children {
	constructor() {
		super();

		this[$constructors] = [ Attribute ];
	}

	[$validate2](orig) {
		const arr = this[$array];

		try {
			const keys = arr.map(attr => attr.key);

			for (const key of keys)
				if (~keys.indexOf(key, keys.indexOf(key) + 1))
					throw new DuplicateKeyError();

		} catch (err) {
			this[$array] = orig;
			throw err;
		}
	}

	setAttribute(namespace=null, key, value) {
		if (arguments.length == 2 && namespace) {
			value     = key;
			key       = namespace;
			namespace = null;
		}

		const existingMember = this[$array].find(
			attr => attr.namespace === namespace && attr.key === key
		);

		if (existingMember)
			existingMember.value = value;
		else
			this.push(new Attribute(namespace, key, value));
	}

	removeAttribute(namespace, key) {
		if (namespace && !key) {
			key       = namespace;
			namespace = null;
		}

		const index = this[$array].findIndex(
			attr => attr.namespace === namespace && attr.key === key
		);

		if (~index)
			return this[$array].splice(index, 1);
	}

	toString({ pretty=true, quote='"', withNS=true }={}) {
		return this[$array].map(
			attr => attr.toString({ pretty, quote, withNS })
		).join(' ');
	}
}

class ElementChildren extends Children {
	constructor() {
		super();

		this[$constructors] = [
			CDATASection,
			Comment,
			Element,
			ProcessingInstruction,
			Text
		];
	}
}

export const DocumentFragment = ElementChildren;

// ABSTRACT NODES //////////////////////////////////////////////////////////////

class NodeWithChildren extends Node {
	constructor(ChildrenConstructor) {
		super();

		this[$childrenConstructor] = ChildrenConstructor;
		this.children = new ChildrenConstructor();
	}

	get children() {
		return this[$children];
	}

	set children(val) {
		if (val instanceof this[$childrenConstructor]) {
			this[$children] = val;
			val[$parent] = this;
		} else {
			throw new IllegalChildError();
		}
	}
}

// ROOT NODES //////////////////////////////////////////////////////////////////

// When parsing, the goal is either a valid Document or a valid DoctypeExternal.
// The correct goal is ambiguous until reaching specific nodes that can only
// occur in one or the other.
//
// - It’s a document:
//   - Doctype
//   - An XML declaration which includes ‘standalone’
//   - Element
// - It’s an external DTD:
//   - ConditionalSection
//   - Declaration (<!ENTITY etc)
//   - ParameterReference
//
// Document places some restrictions on its children. A Doctype must occur
// before the root Element, or not at all, and there can only be a single root
// element.
//
// The external DTD is like the ‘children’ part of Doctype, but it may also
// begin with an xml declaration (called a text declaration in this context...)
// like Document.

export class Document extends NodeWithChildren {
	constructor(version, encoding, standalone) {
		super(DocumentChildren);

		this.version    = version;
		this.encoding   = encoding;
		this.standalone = standalone;
	}

	@commonAccessor
	get version() {}
	set version(x) {}

	@commonAccessor
	get encoding() {}
	set encoding(x) {}

	get standalone() {
		return this[$standalone];
	}

	set standalone(val) {
		if (typeof val == 'boolean') {
			this[$standalone] = val;
		} else if (val instanceof Boolean) {
			this[$standalone] = !!val;
		} else if (val === undefined || val === null) {
			this[$standalone] = undefined;
		} else {
			val = String(val).trim();

			if (/^(yes|true)$/i.test(val))
				this[$standalone] = true;
			else if (/^(no|false)$/i.test(val))
				this[$standalone] = false;
			else
				throw new TypeError();
		}
	}

	get doctype() {
		return this.children.find(m => m instanceof Doctype);
	}

	set doctype(dt) {
		if (!(dt instanceof doctype))
			throw new IllegalChildError();

		const index = this.children.findIndex(m => m instanceof Doctype);

		if (index)
			this.children[$array][index] = dt;
		else
			this.children[$array].unshift(dt);
	}

	isValid() {
		return this.children.some(child => child instanceof Element);
	}

	toString({ d=0, pretty=true, quote='"', tab='\t', withNS=true }={}) {
		if (!this.isValid())
			throw new InvalidDocumentError();

		quote = validQuote(quote);

		const p       = indent(d, tab);
		const docArr  = [];
		const version = this.version;

		if (version) {

			const verStr =
				`version=${ quote }${ version::toVersionString() }${ quote } `;

			const encStr = this.encoding ?
				`encoding=${ quote }${ this.encoding }${ quote } ` : '';

			const sddStr = this.standalone !== undefined ?
				`standalone=${ quote }${
					this.standalone ? 'yes' : 'no'
				}${ quote } ` : '';

			docArr.push(`${ p }<?xml ${ verStr }${ encStr }${ sddStr }?>`);
		}

		doc.push(this.children.toString({ d, pretty, quote, tab, withNS }));

		return docArr.join(tab ? '\n' : '');
	}
}

export class DoctypeExternal extends NodeWithChildren {
	constructor(version, encoding) {
		super(DoctypeExternalChildren);

		this.version  = version;
		this.encoding = encoding;
	}

	@commonAccessor
	get version() {}
	set version(x) {}

	@commonAccessor
	get encoding() {}
	set encoding(x) {}

	toString({ d=0, pretty=true, quote='"', tab='\t', withNS=true }={}) {
		quote = validQuote(quote);
		
		const p        = indent(d, tab);
		const dtdArr   = [];
		const version  = this.version;
		const encoding = this.encoding;

		if (version || encoding) {

			const verStr = version ?
				`version=${ quote }${
					version::toVersionString()
				}${ quote } ` : '';

			const encStr = encoding ?
				`encoding=${ quote }${
					encoding
				}${ quote } ` : '';

			dtdArr.push(`${ p }<?xml ${ verStr }${ encStr }?>`);
		}

		if (this.children.length)
			dtdArr.push(
				this.children.toString({ d, pretty, quote, tab, withNS })
			);

		return dtdArr.join(tab ? '\n' : '');
	}
}

// DOCTYPE /////////////////////////////////////////////////////////////////////

// A doctype declaration specifies the location of an external definition and/or
// inline definitions. The terminology here is a little wobbly to me, but the
// contents of the DTD ‘itself’, whether internal or external, are individual
// declarations (English: definitions) for different nodes/elements/whatever
// to be used with the document in question, provided the DTD name matches the
// root node (I think...).

export class Doctype extends NodeWithChildren {
	constructor(name, systemID, publicID) {
		super(DoctypeChildren);

		this.name     = name;
		this.systemID = systemID;
		this.publicID = publicID;
	}

	@commonAccessor
	get name() {}
	set name(x) {}

	@commonAccessor
	get systemID() {}
	set systemID(x) {}

	@commonAccessor
	get publicID() {}
	set publicID(x) {}

	toString({ d=0, pretty=true, quote='"', tab='\t', withNS=true }={}) {
		quote = validQuote(quote);

		const dbl = quote == '"';
		const p   = indent(d, tab);
		const nl  = tab ? '\n' : '';

		let sid        = this.systemID;
		let pid        = this.publicID;
		let externalID = '';
		let dtd        = '';

		if (sid) {

			sid = sid::safelyQuote(quote);

			if (pid) {
				pid::safelyQuote(quote);

				externalID = `PUBLIC ${ pid } ${ sid } `;
			} else {
				externalID = `SYSTEM ${ sid } `;
			}
		}

		if (this.children.length)
			dtd = `[${ nl }${
				this.children.toString({ d: d + 1, pretty, quote, tab, withNS })
			}${ nl }${ p }${}]`;

		return `${ p }<!DOCTYPE ${ this.name }${ externalID }${ dtd }>`;
	}
}

// ELEMENT /////////////////////////////////////////////////////////////////////

// Elements are the bits people actually care about -- ‘tags’. In XML, unlike
// HTML, a self-closing tag must contain the closing slash (wtf were the HTML
// folks thinking to make that optional??).

export class Element extends NodeWithChildren {
	constructor(namespace, name) {
		super(ElementChildren);

		if (namespace && !name) {
			name      = namespace;
			namespace = null;
		}

		this[$attributes] = new ElementAttributes();
		this.namespace    = namespace;
		this.name         = name;
	}

	get attributes() {
		return this[$attributes];
	}

	set attributes(val) {
		if (val instanceof ElementAttributes) {
			this[$attributes] = val;
			val[$parent] = this;
		} else {
			throw new IllegalChildError();
		}
	}

	@commonAccessor
	get name() {}
	set name(x) {}

	@commonAccessor
	get namespace() {}
	set namespace(x) {}

	@commonAccessor
	get fullName() {}

	setAttribute() {
		this.attributes.setAttribute(...arguments);
	}

	removeAttribute() {
		this.attributes.removeAttribute(...arguments);
	}

	toString({ d=0, pretty=true, quote='"', tab='\t', withNS=true }={}) {
		const p  = indent(d, tab);
		const nl = tab ? '\n' : '';

		const attributes =
			this.attributes.toString({ pretty, quote, withNS });

		const openTag =
			(withNS ? this.fullName : this.name) +
			(attributes ? ` ${ attributes }${ pretty ? ' ' : '' }` : '');

		if (!this.children.length)
			return `${ p }<${ openTag }/>`;
		else
			return `${ p }<${ openTag }>${ nl }${
				this.children.toString({ d: d + 1, pretty, quote, tab, withNS })
			}${ nl }${ p }</${ this.name }>`;
	}
}

// ATTRIBUTE ///////////////////////////////////////////////////////////////////

// Attributes in XML, unlike HTML, must have values (even if they’re just empty
// strings) and those values must be quoted. Entities are processed inside the
// values, and ampersand and less-than must be represented as entities.
// Depending on the quote used as the delimiter, instances of that will also
// require entity-escaping.

export class Attribute extends Node {
	constructor(namespace, key, value) {
		super();

		if (arguments.length === 2) {
			value     = key;
			key       = namespace;
			namespace = null;
		}

		this.namespace = namespace;
		this.key       = key;
		this.value     = value;
	}

	get key() {
		return this[$key];
	}

	set key(str) {
		str = String(str).trim();

		if (isValid.name(str))
			this[$key] = str;
		else
			throw new InvalidStringError();
	}

	@commonAccessor
	get namespace() {}
	set namespace(x) {}

	get value() {
		return this[$value];
	}

	set value(str) {
		if (str === undefined || str === null) {
			this[$value] = '';
		} else {
			str = String(str)
				::replaceLiteralAmp()
				::replaceLiteralLT()
				::replaceQuoteEntities();

			// Note " and ' are not escapes to entities until toString, as its
			// nature will depend on which quotation mark delimiter is used.

			if (isValid.charData(str))
				this[$value] = str;
			else
				throw new InvalidStringError();
		}
	}

	get fullName() {
		return this.namespace ? `${ this.namespace }:${ this.key }` : this.key; 
	}

	toString({ pretty=true, quote='"', withNS=true }) {
		quote = validQuote(quote);

		let value = this.value::escapeQuote(quote);

		if (pretty) value = value::norm();

		const key = withNS ? this.fullName : this.key;

		return `${ key }=${ quote }${ value }${ quote }`;
	}
}

// COMMENT /////////////////////////////////////////////////////////////////////

// Comments can occur nearly anywhere, and their content’s only restriction is
// to disallow the sequence ‘--’ (even if not followed by >). The way the
// valid pattern works, the closing sequence may not be ‘--->’, though we will
// automatically correct both of these things in the setter. However the open
// sequence can be ‘<!---’. 

export class Comment extends Node {
	constructor(content) {
		super();

		this.content = content;
	}

	get content() {
		return this[$content];
	}

	set content(str) {
		if (str === undefined || str === null) {
			this[$content] = '';
		} else {
			str = String(str).replace(/-(?=-|$)/g, '- ');

			if (!isValid.commentContent(str))
				throw new InvalidStringError();

			this[$content] = str;
		}
	}

	toString({ d=0, pretty=true, tab='\t' }={}) {
		const p = indent(d, tab);

		if (!pretty)
			return `${ p }<!--${ this.content }-->`;
		else if (this.content.length <= prettyLength)
			return `${ p }<!-- ${ this.content::norm() } -->`;
		
		return (
			`${ p }<!--\n${ this.content::toPrettyLines(p + tab) }\n${ p }-->`
		);
	}
}

// TEXT ////////////////////////////////////////////////////////////////////////

// Text nodes can occur inside Elements. They must escape ampersands, less-than
// signs, and greater-than signs when they occur in the sequence ']]>'. In fact
// whitespace text nodes (of a sort?) may occur outside Elements as well, and
// are considered part of the document structure even though their only purpose
// then would be to create an unnavigable barf party -- which is why this, and
// many other parsers I think, ignore that part of the XML spec.

export class Text extends Node {
	constructor(content) {
		super();

		this.content = content;
	}

	get content() {
		return this[$content];
	}

	set content(str) {
		if (str === undefined || str === null) {
			this[$content] = '';
		} else {
			str = String(str)
				::replaceQuoteEntities()
				::replaceGTEntity() // all &gt; to >
				::replaceLiteralThingie() // > to &gt; but only when needed
				::replaceLiteralAmp()
				::replaceLiteralLT();

			if (isValid.charData(str))
				this[$content] = str;
			else
				throw new InvalidStringError();
		}
	}

	toString({ d=0, pretty=true, tab='\t' }={}) {
		const p    = indent(d, tab);
		const text = this.content;

		if (pretty)
			return text::toPrettyLines(p);
		else
			return p + text;
	}
}

// PROCESSING INSTRUCTIONS /////////////////////////////////////////////////////

// A processing instruction is a directive targetting some interpretting agent.
// They can appear in most places, and their only required attribute is `target`
// which identifies the agent in question (it may not be 'xml'). The instruction
// is any string not including the termination sequence '?>'.

export class ProcessingInstruction extends Node {
	constructor(target, instruction) {
		super();

		this.target      = target;
		this.instruction = instruction;
	}

	get target() {
		return this[$target];
	}

	set target(str) {
		str = String(str).trim();

		if (isValid.piTarget(str))
			this[$target] = str;
		else
			throw new InvalidStringError();
	}

	get instruction() {
		return this[$instruction];
	}

	set instruction(str) {
		if (str === undefined || str === null)
			this[$instruction] = '';
		else if (isValid.piInstruction(str))
			this[$instruction] = str;
		else
			throw new InvalidStringError();
	}

	toString({ d=0, pretty=true, tab='\t' }={}) {
		const p = indent(d, tab);

		if (!pretty)
			return `${ p }<?${ this.target } ${ this.instruction }?>`;

		const instruction = this.instruction::norm();

		if (instruction.length <= prettyLength)
			return `${ p }<?${ this.target } ${ instruction } ?>`;
		
		return (
			`${ p }<?${ this.target }\n${
				instruction::toPrettyLines(p + tab)
			}\n${ p }?>`
		);

	}
}

// MARKED SECTIONS /////////////////////////////////////////////////////////////

// A marked section is one taking the pattern <![NAME[CONTENT]]>. There are
// only three types, technically: CDATA, IGNORE, and INCLUDE, and of these only
// the first is common.
//
// CDATA allows the inclusion of literal character data
// without entity escaping; it ‘resolves’ to its text content, and therefore may
// only appear in positions that text nodes may appear in. It may not contain
// the sequence ‘]]>’ internally.
//
// IGNORE and INCLUDE are called ‘conditional sections’ and they’re a bit
// arcane. Both may only appear in an ‘external subset,’ which is like a DTD’s
// internal subset except it appears in a standalone file. Why they cannot
// appear in an internal subset I’m not sure.
//
// Both may contain anything a DTD can contain; the contents are just being
// ‘sectioned off’. They’re not particularly useful on their own because an
// INCLUDE section means the same as not having wrapped it at all, and an IGNORE
// section is simply ignored. However, while marked sections only have three
// keywords, it is possible to use parameter references that resolve to these
// words, which is what introduces their conditional nature: by changing the
// entity reference definition, you can toggle various DTD sections that depend
// on it.
//
// Technically, an IGNORE section’s content isn’t even parsed as DTD content, so
// it’s just a bunch of ignored text. Unlike CDATA, it may include ‘]]>’ so long
// as it was preceded by a matching ‘<![’. But realistically, it is understood
// that IGNORE contents are in fact DTD content. We do parse them as such
// because our goal is to produce an editable / transformable tree, not to
// render content.

class MarkedSection extends Node {
	constructor(keyword, content) {
		super();

		this[$keyword] = keyword;
		this.content   = content;
	}

	toString({ d=0, pretty=true, quote='"', tab='\t', withNS=true }={}) {
		const p      = indent(d, tab);
		const nl     = tab ? '\n' : '';
		const prefix = `${ p }<![${ this[$keyword] }[`;

		const children = this.children && this.children.length &&
			this.children.toString({ d: d + 1, pretty, quote, tab, withNS });

		let content = this.content;

		if (!content && !children)
			return prefix + ']]>';

		if (children)
			return `${ prefix }${ nl }${ children }${ nl }${ p }]]>`;

		if (pretty) {
			const pp = p + tab;

			content = content
				.split('\n')
				.map(line => pp + line.trim())
				.join('\n');

			return `${ prefix }\n${ content }\n${ p }]]>`;

		} else {
			return prefix + content + ']]>';
		}
	}
}

export class CDATASection extends MarkedSection {
	constructor(content) {
		super('CDATA', content);
	}

	get content() {
		return this[$content];
	}

	set content(val) {
		if (isValid.cdataContent(val))
			this[$content] = val;
		else
			throw new InvalidStringError(val);
	}
}

export class ConditionalSection extends MarkedSection {
	constructor(keyword, content) {
		super();

		this.keyword    = keyword;
		this[$children] = new DoctypeExternalChildren();
	}

	get content() { return undefined; }
	set content(val) { }

	get children() {
		return this[$children];
	}

	set children(val) {
		if (val instanceof DoctypeExternalChildren)
			this[$children] = val;
		else
			throw new IllegalChildError();
	}

	get keyword() {
		return this[$keyword];
	}

	set keyword(str) {
		str = String(str);

		if (str == 'IGNORE' || str == 'INCLUDE') {
			this[$keyword] = str;
			return;
		}

		if (str.startsWith('%') && str.endsWith(';'))
			str = str.slice(1, -1);

		if (isValid.name(str))
			this[$keyword] = `%${ str };`;
		else
			throw new InvalidStringError();
	}
}

// DTD CONTENTS ////////////////////////////////////////////////////////////////

// Though parameter references (%abc;) may, like entity references (&abc;)
// appear in contexts where they aren’t considered nodes in themselves to us,
// in the context of a DTD they may occur as children in isolation.

export class ParameterReference extends Node {
	constructor(name) {
		super();

		this.name = name;
	}

	get name() {
		return this[$name];
	}

	set name(str) {
		str = String(str);

		if (str.startsWith('%') && str.endsWith(';'))
			str = str.slice(1, -1);

		if (isValid.name(str))
			this[$name] = `%${ str };`;
		else
			throw new InvalidStringError();
	}

	toString({ d=0, tab='\t' }={}) {
		return indent(d, tab) + this.name;
	}
}

// The generic Declaration class provides the common name accessors

class Declaration extends Node {
	constructor(namespace, name) {
		super();

		if (namespace && !name) {
			name = namespace;
			namespace = null;
		}

		this.name      = name;
		this.namespace = namespace;
	}

	@commonAccessor
	get name() {}
	set name(x) {}

	@commonAccessor
	get namespace() {}
	set namespace(x) {}

	@commonAccessor
	get fullName() {}
}

// An element declaration has one of several types of ‘legal children’ lists or
// statements, and the lists can be nested, making this somewhat tough to model.

export class ElementDeclaration extends Declaration {
	constructor() {
		super(...arguments);

		this[$contentSpec] = new RootChildElementGroup();
		this[$contentSpec][$PARENT] = this;
	}

	get contentSpec() {
		return this[$contentSpec];
	}

	get quantifier() {
		return this[$contentSpec][$quantifier];
	}

	set quantifier(val) {
		this[$contentSpec].quantifier = val;
	}

	get type() {
		return this[$contentSpec][$type];
	}

	set type(val) {
		this[$contentSpec].type = val;
	}

	toString({ d=0, pretty=true, tab='\t', withNS=true }={}) {
		const name = withNS ? this.fullName : this.name;
		const spec = this.contentSpec.toString({ withNS });
		const p    = indent(d, tab);

		return `${ p }<!ELEMENT ${ name } ${ spec }${ pretty ? ' ' : '' }>`;
	}
}

export class ChildElementName extends Declaration {
	constructor() {
		super(...arguments);
	}

	get quantifier() {
		return this[$quantifier];
	}

	set quantifier(str) {
		if (this.parent && this.parent.type == 'MIXED')
			throw new IncompatibleQuantifierError();

		if (str === undefined || str === null)
			str = '';

		str = String(str).trim();

		if (!isValid.quantifier(str))
			throw new InvalidStringError();

		this[$quantifier] = str;
	}

	toString({ withNS=true }) {
		return withNS ? this.fullName : this.name;
	}
}

export class AttListDeclaration extends Declaration {
	constructor() {
		super(...arguments);

		this[$attributes] = new AttributeDefinitions();
	}

	get defs() {
		return this[$attributes];
	}

	set defs(val) {
		if (val instanceof AttributeDefinitions) {
			this[$attributes] = val;
			val[$parent] = this;
		} else {
			throw new IllegalChildError();
		}
	}

	toString({ d=0, pretty=true, quote='"', tab='\t', withNS=true }={}) {
		const p = indent(d, tab);

		const defs =
			this.defs.toString({ d: d + 1, pretty, quote, tab, withNS });

		if (!defs || !tab)
			return `${ p }<!ATTLIST ${ this.name }${
				defs ? ` ${ defs } ` : ''
			}>`;

		return `${ p }<!ATTLIST ${ this.name }\n${ defs }>`
	}
}

export class AttributeDefinition extends Declaration {
	constructor() {
		super(...arguments);
	}

	get type() {
		return this[$type];
	}

	set type(val) {
		if (val instanceof Array) {
			val = val.map(m => String(m));

			if (!val.every(m => isValid.nmToken(m)))
				throw new InvalidStringError();

			this[$type] = val;
			this[$type].toString = function() {
				return `(${ this.join('|') })`;
			};
		} else {
			val = String(val).trim().toUpperCase();

			if (isValid.stringOrTokenizedType(val))
				this[$type] = val;
			else
				throw new InvalidStringError();
		}
	}

	toString({ d=0, pretty=true, quote='"', tab='\t', withNS=true }={}) {
		const p = indent(d, tab);
		const name = withNS ? this.fullName : this.name;

		const nc = !pretty || (name.length >= prettyColumn) ? ' ' :
			new Array(prettyColumn - name.length + 1).join(' ');

		const type = this.type.toString();

		const tc = !pretty || (type.length >= prettyColumn) ||
			(name.length >= prettyColumn) ? ' ' :
			new Array(prettyColumn - type.length + 1).join(' ');

		const defaults = this.defaults.toString();

		return `${ p }${ name }${ nc }${ type }${ tc }${ defaults }`;
	}
}

export class EntityDeclaration extends Declaration {
	constructor() {
		super(...arguments);
	}

	@commonAccessor
	get systemID() {}
	set systemID(x) {}

	@commonAccessor
	get publicID() {}
	set publicID(x) {}
}

export class NotationDeclaration extends Declaration {
	constructor(namespace, name) {
		super(...arguments);
	}

	@commonAccessor
	get systemID() {}
	set systemID(x) {}

	@commonAccessor
	get publicID() {}
	set publicID(x) {}

	toString({ d=0, quote='"' tab='\t' }={}) {
		quote = validQuote(quote);

		const sid = this.systemID && this.systemID::safelyQuote(quote);
		const pid = this.publicID && this.publicID::safelyQuote(quote);

		let id = '';

		if (pid && !sid)
			id = `PUBLIC ${ pid }`;
		else if (pid && sid)
			id = `PUBLIC ${ pid } ${ sid }`;
		else if (sid)
			id = `SYSTEM ${ sid }`;

		return `${ indent(d, tab) }<!NOTATION ${ this.name }${ id }>`;
	}
}

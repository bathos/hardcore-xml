 
import * as nodes from 'node-classes';

import { EventEmitter } from 'events';
import { Domain }       from 'domain';

// Assemblers listen to events emitted by the internal parse streams. Because
// these are only emitting events in accord with the grammar, the assembler’s
// job is pretty simple; it does not need to do anything to ensure, for example,
// that an 'xml declaration' event has occurred in the correct position.
//
// There are some exceptions: in validating mode, we perform a check on nodes
// when they are completed; and certain other concerns that depend on the actual
// content rather than grammar must occur here (for example, element tag
// matching and attribute uniqueness).
//
// Content spec productions of the forms ‘series’ or ‘choice’ require special
// handling (as usual...) that looks very different from everything else. This
// is because they uniquely maintain ambiguity even while yielding an arbitrary
// number of child productions.
//
// Text and xml declarations may have a side effect: they may call the provided
// setEncoding method which will tell the decoder stream how to interpret the
// chunks it is receiving. Node only supports a handful of encodings; we expand
// this pool a bit with iconv. (Note, a sniffing algorithm takes place before
// this, so that we can at least get as far as reading that limited production).

export default class Assembler extends EventEmitter {
  constructor(mode, target, decoder) {
    super();

    this.html   = mode == 'html';
    this.sloppy = mode == 'sloppy' || mode == 'html';
    this.strict = mode == 'strict' || mode == 'validating';
    this.vldtng = mode == 'validating';

    this.Attribute = this.html ? nodes.HTMLAttribute : nodes.Attribute;
    this.Doctype   = this.html ? nodes.HTMLDoctype   : nodes.Doctype;
    this.Document  = this.html ? nodes.HTMLDocument  : nodes.Document;
    this.Element   = this.html ? nodes.HTMLElement   : nodes.Element;
    this.Fragment  = this.html ? nodes.HTMLFragment  : nodes.Fragment;
    this.Text      = this.html ? nodes.HTMLText      : nodes.Text;

    this.node =
      target == 'document'     ? new this.Document() :
      target == 'fragment'     ? new this.Fragment() :
      target == 'external dtd' ? new nodes.Doctype() :
      null;

    this.spec      = null;
    this.specStack = null;
    this.target    = target;
    this.value     = null;
    this.warnings  = [];
  }

    // Domain-based event handler error handling
    /*
    const domain = new Domain();

    domain.on('error', err => {
      if (strict)
        return this.emit('error', err);

      warnings.push(err.message);

      if (!err.nodeRecoverable) {
        const parent = node.parent;
        node.remove();
        node = parent;
      }
    });

    domain.add(grammar);
    domcin.add(decoder);

    domain.run(() => {
      */

  // End target production event

  ['end of file']() {
    if (this.vldtng && this.target == 'document')
      try {
        this.node.isSelfValid();
      } catch (err) {
        err.nodeRecoverable = true;
        throw err;
      }

    const result =
      (this.target == 'external dtd') ? this.node.children :
      (this.target == 'external entity') ? this.value :
      this.node;

    this.emit('result', { result, warnings: this.warnings });
  }

  // Document / Doctype events

  ['xml declaration']({ version, encoding, standalone }) {
    this.node.version    = version;
    this.node.encoding   = encoding;
    this.node.standalone = standalone;
  }

  ['doctype'](opts) {
    const doctype = new this.Doctype(opts);
    this.node.push(doctype);
    this.node = doctype;
  }

  ['doctype end']() {
    if (this.vldtng)
      this.node.isSelfValid();

    this.node = node.parent;
  }

  // Interstitial node events

  ['comment'](opts) {
    this.node.push(new nodes.Comment(opts));
  }

  ['processing instruction'](opts) {
    this.node.push(new nodes.ProcessingInstruction(opts));
  }

  // Element events

  ['element begin'](opts) {
    const elem = new this.Element(opts);
    this.node.push(elem);
    this.node = elem;
  };

  ['attribute']({ name, value='' }) {
    if (this.html)
      name = name.toLowerCase();

    if (this.node.hasAttribute(name)) {
      throw new RecoverableTODO;
    }

    this.node.setAttribute(name, value);

    if (vldtng)
      this.node.getAttribute(name).isSelfValid();
  }

  ['element end']({ name=node.name }) {
    if (this.html)
      name = name.toLowerCase();

    if (this.node.name !== name)
      throw TODO; // check html5 spec; use its recovery logic in sloppy mode

    if (vldtng)
      this.node.isSelfValid();

    this.node = this.node.parent;
  }

  // CDATA events

  ['cdata section'](opts) {
    this.node.push(new nodes.CDATASection(opts));
  }

  ['text']({ content }) {
    if (this.node.lastChild instanceof this.Text)
      this.node.lastChild.content += content;
    else
      this.node.push(new this.Text({ content }));
  }

  // Attlist declaration events

  ['attlist declaration begin'](opts) {
    const attlist = new nodes.AttlistDeclaration(opts);
    this.node.push(attlist);
    this.node = attlist;
  }

  ['attribute definition'](opts) {
    opts.defaultValue = opts.value;

    const attdef = new nodes.AttributeDefinition(opts);

    this.node.push(attdef);

    if (vldtng)
      attdef.isSelfValid();
  }

  ['attlist declaration end']() {
    if (vldtng)
      this.node.isSelfValid();

    this.node = this.node.parent;
  }

  // Element declaration events

  ['element declaration begin'](opts) {
    const eld = new nodes.ElementDeclaration(opts);
    this.node.push(eld);
    this.node = eld;
  }

  ['content spec']({ mixedElems=[], spec }) {
    if (this.spec) {
      this.node.spec = spec;
    } else {
      const children =
        mixedElems.map(name => new nodes.ContentSpecMember({ name }));

      this.node.spec = new nodes.ContentSpecMixed({ children });
    }
  }

  ['content spec group begin']() {
    const newSpec = [];

    if (this.spec) {
      this.specStack.push(newSpec);
      this.spec.push(newSpec);
    } else {
      this.specStack = [ newSpec ];
    }

    this.spec = newSpec;
  }

  ['content spec group disjunction']() {
    this.spec.isDisjunct = true;
  }

  ['content spec member'](opts) {
    this.spec.push(new nodes.ContentSpecMember(opts));
  }

  ['content spec group end']({ quantifier='' }) {
    const opts = { children: this.spec, quantifier };

    const realSpec =
      this.spec.isDisjunct ? new nodes.ContentSpecChoice(opts) :
      new nodes.ContentSpecSequence(opts);

    this.spec = this.specStack.pop(), this.specStack.pop();

    this.spec.push(realSpec);

    this.specStack.push(this.spec);
  }

  ['element declaration end']() {
    if (this.spec) {
      this.node.spec = this.spec;
      this.spec = null;
    }

    if (vldtng)
      this.node.isSelfValid();

    this.node = this.node.parent;
  }

  // Entity and notation declaration events

  ['entity declaration'](opts) {
    opts.type =
      opts.isParameter ? 'parameter' :
      opts.ndata ? 'unparsed' :
      'general';

    const ent = new nodes.EntityDeclaration(opts);

    this.node.push(ent);

    if (vldtng)
      ent.isSelfValid();
  }

  ['notation declaration']({ name, publicID, systemID }) {
    const not = new nodes.NotationDeclaration(opts);

    this.node.push(not);

    if (vldtng)
      not.isSelfValid();
  }

  // Special production events

  ['external entity value'](opts) {
    this.value = opts.value || '';
  }

  ['text declaration']({ version, encoding }) {
    if (encoding && this.decoder.ambiguous)
      this.decoder.setEncodingz(encoding, true);

    if (this.decoder.morePlease) {
      this.decoder.morePlease();
      this.decoder.morePlease = null;
    }
  }
}

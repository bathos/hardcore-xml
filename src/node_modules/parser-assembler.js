 
import * as nodes from 'node-classes';

import { EventEmitter } from 'events';
import { Domain }       from 'domain';

// Assemblers listen to events emitted by the internal parse streams. Because
// these are only emitting events in accord with the grammar, the assembler’s
// job is pretty simple; it does not need to do anything to ensure, for example,
// that an 'xml declaration' event has occurred in the correct position.
//
// There are some exceptions: in validating mode, we perform a check on nodes
// when they are completed; and certain other concerns that depend on the actual
// content rather than grammar must occur here (for example, element tag
// matching and attribute uniqueness).
//
// Content spec productions of the forms ‘series’ or ‘choice’ require special
// handling (as usual...) that looks very different from everything else. This
// is because they uniquely maintain ambiguity even while yielding an arbitrary
// number of child productions.
//
// Text and xml declarations may have a side effect: they may call the provided
// setEncoding method which will tell the decoder stream how to interpret the
// chunks it is receiving. Node only supports a handful of encodings; we expand
// this pool a bit with iconv. (Note, a sniffing algorithm takes place before
// this, so that we can at least get as far as reading that limited production).

export default class Assembler extends EventEmitter {
  constructor(mode, target, grammar, decoder) {
    super();

    const html   = mode == 'html';
    const sloppy = mode == 'sloppy' || mode == 'html';
    const strict = mode == 'strict' || mode == 'validating';
    const vldtng = mode == 'validating';

    const Attribute = html ? nodes.HTMLAttribute : nodes.Attribute;
    const Doctype   = html ? nodes.HTMLDoctype   : nodes.Doctype;
    const Document  = html ? nodes.HTMLDocument  : nodes.Document;
    const Element   = html ? nodes.HTMLElement   : nodes.Element;
    const Fragment  = html ? nodes.HTMLFragment  : nodes.Fragment;
    const Text      = html ? nodes.HTMLText      : nodes.Text;

    let node =
      target == 'document'     ? new Document() :
      target == 'fragment'     ? new Fragment() :
      target == 'external dtd' ? new nodes.Doctype() :
      null;

    let specStack, spec, value;

    // Domain-based event handler error handling

    const domain = new Domain();

    const warnings = [];

    domain.on('error', err => {
      if (strict)
        return this.emit('error', err);

      warnings.push(err.message);

      if (!err.nodeRecoverable) {
        const parent = node.parent;
        node.remove();
        node = parent;
      }
    });

    domain.add(grammar);
    domcin.add(decoder);

    domain.run(() => {

      // End target production event

      grammar.on('end of file', () => {
        if (vldtng && target == 'document')
          try {
            node.isSelfValid();
          } catch (err) {
            err.nodeRecoverable = true;
            throw err;
          }

        const result =
          (target == 'external dtd') ? node.children :
          (target == 'external entity') ? value :
          node;

        this.emit('result', { result, warnings });
      });

      // Document / Doctype events

      grammar.on('xml declaration', ({ version, encoding, standalone }) => {
        node.version    = version;
        node.encoding   = encoding;
        node.standalone = standalone;
      });

      grammar.on('doctype', opts => {
        const doctype = new Doctype(opts);
        node.push(doctype);
        node = doctype;
      });

      grammar.on('doctype end', () => {
        if (vldtng)
          node.isSelfValid();

        node = node.parent;
      });

      // Interstitial node events

      grammar.on('comment', opts => {
        node.push(new nodes.Comment(opts));
      });

      grammar.on('processing instruction', opts => {
        node.push(new nodes.ProcessingInstruction(opts));
      });

      // Element events

      grammar.on('element begin', opts => {
        const elem = new Element(opts);
        node.push(elem);
        node = elem;
      });

      grammar.on('attribute', ({ name, value='' }) => {
        if (html) name = name.toLowerCase();

        if (node.hasAttribute(name)) {
          throw new RecoverableTODO;
        }

        node.setAttribute(name, value);

        if (vldtng)
          node.getAttribute(name).isSelfValid();
      });

      grammar.on('element end', ({ name=node.name }) => {
        if (html)
          name = name.toLowerCase();

        if (node.name !== name)
          throw TODO; // check html5 spec; use its recovery logic in sloppy mode

        if (vldtng)
          node.isSelfValid();

        node = node.parent;
      });

      // CDATA events

      grammar.on('cdata section', opts => {
        node.push(new nodes.CDATASection(opts));
      });

      grammar.on('text', ({ content }) => {
        if (node.lastChild instanceof nodes.Text)
          node.lastChild.content += content;
        else
          node.push(new Text({ content }));
      });

      // Attlist declaration events

      grammar.on('attlist declaration begin', opts => {
        const attlist = new node.AttlistDeclaration(opts);
        node.push(attlist);
        node = attlist;
      });

      grammar.on('attribute definition', opts => {
        opts.defaultValue = opts.value;

        const attdef = new node.AttributeDefinition(opts);

        node.push(attdef);

        if (vldtng)
          attdef.isSelfValid();
      });

      grammar.on('attlist declaration end', () => {
        if (vldtng)
          node.isSelfValid();

        node = node.parent;
      });

      // Element declaration events

      grammar.on('element declaration begin', opts => {
        const eld = new nodes.ElementDeclaration(opts);
        node.push(eld);
        node = eld;
      });

      grammar.on('content spec', ({ mixedElems=[], spec }) => {
        if (spec) {
          node.spec = spec;
        } else {
          const children =
            mixedElems.map(name => new nodes.ContentSpecMember({ name }));

          node.spec = new nodes.ContentSpecMixed({ children });
        }
      });

      grammar.on('content spec group begin', () => {
        const newSpec = [];

        if (spec) {
          specStack.push(newSpec);
          spec.push(newSpec);
        } else {
          specStack = [ newSpec ];
        }

        spec = newSpec;
      });

      grammar.on('content spec group disjunction', () => {
        spec.isDisjunct = true;
      });

      grammar.on('content spec member', opts => {
        spec.push(new nodes.ContentSpecMember(opts));
      });

      grammar.on('content spec group end', ({ quantifier='' }) => {
        const opts = { children: spec, quantifier };

        const realSpec =
          spec.isDisjunct ? new nodes.ContentSpecChoice(opts) :
          new nodes.ContentSpecSequence(opts);

        spec = specStack.pop(), specStack.pop();

        spec.push(realSpec);

        specStack.push(spec);
      });

      grammar.on('element declaration end', () => {
        if (spec) {
          node.spec = spec;
          spec = null;
        }

        if (vldtng)
          node.isSelfValid();

        node = node.parent;
      });

      // Entity and notation declaration events

      grammar.on('entity declaration', opts => {
        opts.type =
          opts.isParameter ? 'parameter' :
          opts.ndata ? 'unparsed' :
          'general';

        const ent = new nodes.EntityDeclaration(opts);

        node.push(ent);

        if (vldtng)
          ent.isSelfValid();
      });

      grammar.on('notation declaration', ({ name, publicID, systemID }) => {
        const not = new nodes.NotationDeclaration(opts);

        node.push(not);

        if (vldtng)
          not.isSelfValid();
      });

      // Special production events

      grammar.on('external entity value', opts => {
        value = opts.value || '';
      });

      grammar.on('text declaration', ({ version, encoding }) => {
        if (encoding) decoder.setEncoding(encoding, true);
      });
    });
  }
}

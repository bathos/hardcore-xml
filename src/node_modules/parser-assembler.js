 
import * as nodes from 'node-classes';
import EventEmitter from 'events';

// Assemblers listen to events emitted by the internal parser. Because the
// parser is only emitting events in accord with the grammar, the assembler’s
// job is pretty simple; it does not need to do anything to ensure, for example,
// that an 'xml declaration' event has occurred in the correct position.
//
// There are some exceptions: in validating mode, we perform a check on nodes
// when they are completed; and certain other concerns that depend on the actual
// content rather than grammar must occur here (for example, element tag
// matching and attribute uniqueness).
//
// Content spec productions of the forms ‘series’ or ‘choice’ require special
// handling (as usual...) that looks very different from everything else. This
// is because they uniquely maintain ambiguity even while yielding an arbitrary
// number of child productions.
//
// Text and xml declarations may have a side effect: they may call the provided
// setEncoding method which will tell the low-level parser how to interpret the
// chunks it is receiving. Node only supports a handful of encodings; we expand
// this pool a bit with iconv. (Note, a sniffing algorithm takes place before
// this, so that we can at least get as far as reading that limited production).

export default class Assembler extends EventEmitter {
  constructor(mode, target, emitter, setEncoding) {
    super();

    const html   = mode == 'html';
    const sloppy = mode == 'sloppy' || mode == 'html';
    const strict = mode == 'strict' || mode == 'validating';
    const vldtng = mode == 'validating';

    const Attribute = html ? nodes.HTMLAttribute : nodes.Attribute;
    const Doctype   = html ? nodes.HTMLDoctype   : nodes.Doctype;
    const Document  = html ? nodes.HTMLDocument  : nodes.Document;
    const Element   = html ? nodes.HTMLElement   : nodes.Element;
    const Fragment  = html ? nodes.HTMLFragment  : nodes.Fragment;
    const Text      = html ? nodes.HTMLText      : nodes.Text;

    let node =
      target == 'document'     ? new Document() :
      target == 'fragment'     ? new Fragment() :
      target == 'external dtd' ? new nodes.Doctype() :
      null;

    let specStack, spec, value;

    // End target production event

    emitter.on('end of file', () => {
      if (vldtng && target == 'document')
        node.isSelfValid();

      const result =
        (target == 'external dtd') ? node.children :
        (target == 'external entity') ? value :
        node;

      this.emit('result', result);
    });

    // Document / Doctype events

    emitter.on('xml declaration', ({ version, encoding, standalone }) => {
      node.version    = version;
      node.encoding   = encoding;
      node.standalone = standalone;
    });

    emitter.on('doctype', opts => {
      const doctype = new Doctype(opts);
      node.push(doctype);
      node = doctype;
    });

    emitter.on('doctype end', () => {
      if (vldtng)
        node.isSelfValid();

      node = node.parent;
    });

    // Interstitial node events

    emitter.on('comment', opts => {
      node.push(new nodes.Comment(opts));
    });

    emitter.on('processing instruction', opts => {
      node.push(new nodes.ProcessingInstruction(opts));
    });

    // Element events

    emitter.on('element begin', opts => {
      const elem = new Element(opts);
      node.push(elem);
      node = elem;
    });

    emitter.on('attribute', ({ name, value='' }) => {
      if (html) name = name.toLowerCase();

      if (node.hasAttribute(name)) {
        // todo
      }

      node.setAttribute(name, value);
    });

    emitter.on('element end', ({ name=node.name }) => {
      if (html)
        name = name.toLowerCase();

      if (node.name !== name)
        throw todo;

      if (vldtng)
        node.isSelfValid();

      node = node.parent;
    });

    // CDATA events

    emitter.on('cdata section', opts => {
      node.push(new nodes.CDATASection(opts));
    });

    emitter.on('text', ({ content }) => {
      if (node.lastChild instanceof nodes.Text)
        node.lastChild.content += content;
      else
        node.push(new Text({ content }));
    });

    // Attlist declaration events

    emitter.on('attlist declaration begin', opts => {
      const attlist = new node.AttlistDeclaration(opts);
      node.push(attlist);
      node = attlist;
    });

    emitter.on('attribute definition', opts => {
      opts.defaultValue = opts.value;

      const attdef = new node.AttributeDefinition(opts);

      node.push(attdef);

      if (vldtng)
        attdef.isSelfValid();
    });

    emitter.on('attlist declaration end', () => {
      if (vldtng)
        node.isSelfValid();

      node = node.parent;
    });

    // Element declaration events

    emitter.on('element declaration begin', opts => {
      const eld = new nodes.ElementDeclaration(opts);
      node.push(eld);
      node = eld;
    });

    emitter.on('content spec', ({ mixedElems=[], spec }) => {
      if (spec) {
        node.spec = spec;
      } else {
        const children =
          mixedElems.map(name => new nodes.ContentSpecMember({ name }));

        node.spec = new nodes.ContentSpecMixed({ children });
      }
    });

    emitter.on('content spec group begin', () => {
      const newSpec = [];

      if (spec) {
        specStack.push(newSpec);
        spec.push(newSpec);
      } else {
        specStack = [ newSpec ];
      }

      spec = newSpec;
    });

    emitter.on('content spec group disjunction', () => {
      spec.isDisjunct = true;
    });

    emitter.on('content spec member', opts => {
      spec.push(new nodes.ContentSpecMember(opts));
    });

    emitter.on('content spec group end', ({ quantifier='' }) => {
      const opts = { children: spec, quantifier };

      const realSpec =
        spec.isDisjunct ? new nodes.ContentSpecChoice(opts) :
        new nodes.ContentSpecSequence(opts);

      spec = specStack.pop(), specStack.pop();

      spec.push(realSpec);

      specStack.push(spec);
    });

    emitter.on('element declaration end', () => {
      if (spec) {
        node.spec = spec;
        spec = null;
      }

      if (vldtng)
        node.isSelfValid();

      node = node.parent;
    });

    // Entity and notation declaration events

    emitter.on('entity declaration', opts => {
      opts.type =
        opts.isParameter ? 'parameter' :
        opts.ndata ? 'unparsed' :
        'general';

      const ent = new nodes.EntityDeclaration(opts);

      node.push(ent);

      if (vldtng)
        ent.isSelfValid();
    });

    emitter.on('notation declaration', ({ name, publicID, systemID }) => {
      const not = new nodes.NotationDeclaration(opts);

      node.push(not);

      if (vldtng)
        not.isSelfValid();
    });

    // Special production events

    emitter.on('external entity value', opts => {
      value = opts.value || '';
    });

    emitter.on('text declaration', ({ version, encoding }) => {
      if (encoding) setEncoding(encoding);
    });
  }
}

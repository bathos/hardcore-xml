
import { EncodingError } from 'error-classes';
import { Transform } from 'stream';

import iconv from 'iconv-lite';

// ICONV TOOLS /////////////////////////////////////////////////////////////////

// This is how iconv normalizes encoding names. It doesn’t expose the resolved
// name so we need to do this in order to compare the initial encoding to a
// later encoding.

const ignored = /[^0-9a-z]|:\d{4}$/g;
const normalizeEnc = enc => String(enc).toLowerCase().replace(ignored, '');

// SNIFFING DATA ///////////////////////////////////////////////////////////////

const firstBytes = [
  // Unambiguous (BOM matches) -- unsupported (utf32)
  { bytes: [ 0x00, 0x00, 0xFE, 0xFF ], enc: 'utf32be',    supported: false },
  { bytes: [ 0xFF, 0xFE, 0x00, 0x00 ], enc: 'utf32le',    supported: false },
  { bytes: [ 0x00, 0x00, 0xFF, 0xFE ], enc: 'utf32-badc', supported: false },
  { bytes: [ 0xFE, 0xFF, 0x00, 0x00 ], enc: 'utf32-cdab', supported: false },

  // Unambiguous (BOM matches) -- supported
  { bytes: [ 0xFE, 0xFF ],             enc: 'utf16be',    ambiguous: false },
  { bytes: [ 0xFF, 0xFE ],             enc: 'utf16le',    ambiguous: false },
  { bytes: [ 0xEF, 0xBB, 0xBF ],       enc: 'utf8',       ambiguous: false },

  // No BOM, sniffing first char of xml decl -- unsupported (utf32, ebcdic)
  { bytes: [ 0x00, 0x00, 0x00, 0x3C ], enc: 'utf32be',    supported: false },
  { bytes: [ 0x3C, 0x00, 0x00, 0x00 ], enc: 'utf32le',    supported: false },
  { bytes: [ 0x00, 0x00, 0x3C, 0x00 ], enc: 'utf32-badc', supported: false },
  { bytes: [ 0x00, 0x3C, 0x00, 0x00 ], enc: 'utf32-cdab', supported: false },
  { bytes: [ 0x4C, 0x6F, 0xA7, 0x94 ], enc: 'ebcdic',     supported: false },

  // No BOM, sniffing first chars of xml decl -- ambiguous but readable until
  // encoding declaration because will begin with same first 128 chars
  { bytes: [ 0x00, 0x3C, 0x00, 0x3F ], enc: 'utf16be',    ambiguous: true },
  { bytes: [ 0x3C, 0x00, 0x3F, 0x00 ], enc: 'utf16le',    ambiguous: true },
  { bytes: [ 0x3C, 0x3F, 0x78, 0x6D ], enc: 'utf8',       ambiguous: true },
  { bytes: [],                         enc: 'utf8',       ambiguous: true }

  // In the ambiguous cases, the encoding indicated is a stand-in value which
  // will be safe for decoding further up until at least the actual encoding
  // declaration, at which point we may need to switch to something more
  // specific. In the final case, we’re dealing with either a utf8 doc with no
  // xml declaration (or a malformed one, e.g. with whitespace preceding) or
  // some encoding we aren’t aware of (which will probably fail).
];

const findEnc = buffer =>
  firstBytes.find(
    ({ bytes }) => bytes.every((byte, i) => byte === buffer[i])
  );

// DECODER /////////////////////////////////////////////////////////////////////

// To some extent, this replicates the stream interfaces provided by iconv-lite
// itself, but we had to stuff some more things in here and inheritance didn’t
// make much sense in this case.

export default class Decoder extends Transform {
  constructor(enc) {
    super();

    this.initial = true;
    this.initialReserve = new Buffer();

    if (enc) this.setEncodingz(enc, false);

    // The above may throw; this is intentional. Instantiation of a Decoder is
    // performed during instantiation of a Parser; this is a synchronous op.
  }

  _transform(chunk, enc, cb) {
    if (this.initial) {

      if (chunk.length < 4) {
        this.initialReserve = Buffer.concat(this.initialReserve, chunk);

        if (this.initialReserve.length >= 4)
          chunk = this.initialReserve;
        else
          return cb();
      }

      this.initial = false;
      this.initialReserve = null;

      const { enc, ambiguous, supported=true } = findEnc(chunk);

      if (!supported)
        return cb(new EncodingError(enc));

      try {
        this.setEncodingz(enc, ambiguous);
      } catch (err) {
        return cb(err);
      }
    }

    if (this.ambiguous)
      return this._transformSync(chunk).then(cb, cb);

    const str = this.decoder.write(chunk);

    if (str) this.push(str, 'utf8');

    cb();
  }

  async _transformSync(chunk) {

    // While encoding remains ambiguous, we feed data byte-by-byte to
    // prevent decoding anything past the xml encoding declaration (or the
    // definite absence of one). This is our way of dealing with the fact
    // that even though streams are naturally async, we need to be sync with
    // the tokenizer/grammar-walker/assembler briefly during this phase.

    let str, byte;

    do {

      byte  = chunk.slice(0, 1);
      chunk = chunk.slice(1);

      str = this.decoder.write(byte);

      if (str) this.push(str);

      await new Promise(resolve => this.morePlease = resolve);

    } while (this.ambiguous && chunk.length)

    if (chunk.length) {
      const str = this.decoder.write(chunk);

      if (str) this.push(str, 'utf8');
    }
  }

  _flush(cb) {
    if (this.initial)
      this.push(this.decoder.write(this.initialReserve));

    this.push(this.decoder.end() + '\u0003');

    cb();
  }

  // “setEncoding” was taken
  setEncodingz(enc, ambiguous=false) {
    if (!iconv.encodingExists(enc))
      throw new EncodingError(enc);

    enc = normalizeEnc(enc);

    if (enc == this.enc) {
      if (!ambiguous) this.ambiguous = false;
      return;
    };

    if (!this.ambiguous)
      throw new EncodingError(enc, this.enc);

    this.decoder   = iconv.getDecoder(enc);
    this.ambiguous = ambiguous;
    this.enc       = enc;
  }
}

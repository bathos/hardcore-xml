
import parseProduction from 'parser-production-parse';

import * as productions from 'parser-productions';
import * as tokens from 'parser-tokens';

import { iterateProperties } from 'brodash-thunderscore';

// PREP PRODUCTIONS ////////////////////////////////////////////////////////////

// Expand production references, transform literals, etc. While the initial tree
// includes three leaf nodes, the result only includes one ('token'), along with
// the two branch nodes ('disjunction', 'series').

const illuminate = (pattern, index, array) => {
  switch (pattern.type) {
    case 'disjunction':
    case 'series':
      pattern.items.forEach(illuminate);
      break;

    case 'literal':
      const regex = new RegExp(`^${ RegExp.escape(pattern.value) }`);
      pattern.human = pattern.value;
      pattern.type  = 'token';
      pattern.value = [ regex, new RegExp(regex.source, 'i') ];
      break;

    case 'production':
      const production = productions[pattern.value];

      if (array && !pattern.quant) {
        array[index] = production;
      } else {
        pattern.type  = 'series';
        pattern.value = null;
        pattern.items = [ production ];
      }
      break;

    case 'token':
      pattern.name  = pattern.value;
      pattern.value = tokens[pattern.value.slice(1)];

      if (pattern.value.length == 1)
        pattern.value[1] = pattern.value[0];

      break;
  }
};

// Parse pattern language, converting string patterns to trees, and merging base
// production definitions and their roots.

for (const [ key, def ] of productions::iterateProperties()) {
  const parsed = parseProduction(def.pattern);
  def.name  = key;
  def.type  = parsed.type;
  def.quant = parsed.quant;
  def.items = parsed.items;
  def.value = parsed.value;
}

for (const [ key, def ] of productions::iterateProperties())
  illuminate(def);

// At this point, our tree is walkable as a sort of decision tree for use by the
// lexer / parser. The nodes look like this:

// TOKEN
//  - value: [ strictRegexPattern, sloppyRegexPattern ]
//  - quant: '*', '+', '?', or ''
//  - name: nameOfToken or undefined

// SEQUENCE / DISJUNCTION
//  - items: [ sequence/disjunction/token... ]
//  - quant: '*', '+', '?', or ''
//  - name: nameOfProduction or undefined
//  - employs: { argName: nameOfTokenOrProduction, ... } or undefined
//  - deploys: (parser, employedArgs) => { ... } or undefined

// GRAMMAR WALKER //////////////////////////////////////////////////////////////

export default class Grammar extends Writable {
  constructor(mode, target, tokenizer) {}


}
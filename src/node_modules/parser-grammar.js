
import parseProduction from 'parser-production-parse';

import * as prods from 'parser-productions';
import * as tokens from 'parser-tokens';

import { iterateProperties, milliseconds } from 'brodash-thunderscore';

// PREP PRODUCTIONS ////////////////////////////////////////////////////////////

// Expand production references, transform literals, etc. While the initial tree
// includes three leaf nodes, the result only includes one ('token'), along with
// the two branch nodes ('disjunction', 'series').

const illuminate = (pattern, index, array) => {
  switch (pattern.type) {
    case 'disjunction':
    case 'series':
      pattern.items.forEach(illuminate);
      pattern.items.forEach(item => item.parent = pattern);
      break;

    case 'literal':
      const regex = new RegExp(`^${ RegExp.escape(pattern.value) }`);
      pattern.type    = 'token';
      pattern.human   = pattern.value;
      pattern.minimum = pattern.value.length;
      pattern.value   = [ regex, new RegExp(regex.source, 'i') ];
      break;

    case 'production':
      const production = prods[pattern.value];

      if (array && !pattern.quant) {
        array[index] = production;
      } else {
        pattern.type  = 'series';
        pattern.value = null;
        pattern.items = [ production ];
        production.parent = pattern;
      }
      break;

    case 'token':
      pattern.name    = pattern.value;
      pattern.minimum = 1;
      pattern.value   = tokens[pattern.value.slice(1)];

      if (pattern.value.length == 1)
        pattern.value[1] = pattern.value[0];

      break;
  }

  if (def.expands)
    illuminate(def.expands);
};

// Parse pattern language, converting string patterns to trees, and merging base
// production definitions and their roots.

for (const [ key, def ] of prods::iterateProperties()) {
  const parsed = parseProduction(def.pattern);

  def.name  = key;
  def.type  = parsed.type;
  def.quant = parsed.quant;
  def.items = parsed.items;
  def.value = parsed.value;

  if (def.expands)
    def.expands = parseProduction(def.expands);
}

for (const [ key, def ] of prods::iterateProperties())
  illuminate(def);

// At this point, our tree is walkable as a sort of decision tree for use by the
// lexer / parser.

const getTarget = (target, mode) => {
  switch (target) {
    case 'document':
      return mode == 'html' ? prods.$documentHTML : prods.$document;
    case 'fragment':
      return mode == 'html' ? prods.$fragmentHTML : prods.$fragment;
    case 'externaldtd':
      return prods.$externalDTD;
    case 'externalentity':
      return prods.$externalEntity;
  }
};

// GRAMMAR WALKER //////////////////////////////////////////////////////////////

export default class Grammar {
  constructor(mode, target, source, dest) {
    const production = getTarget(target, mode);

    this.source = source;
    this.dest   = dest;

    this.source.on('end', () => this.complete = true)

    this.parse(production);
  }

  async read() {
    while (!this.complete) {
      const str = this.source.read();

      if (str !== null)
        return str;

      await milliseconds(5);
    }
  }

  async parse(production, str='', expanding=false) {
    const { items, expands, minimum, name, quant, type, value } = production;
    const isEOF = name == '@EOF';

    let pattern, matched, more, afterExp, expansionRoot, wasExpanding;
    let used = '';

    // Expansion init

    if (expands) {
      [ used, str, matched ] = this.parse(expands, str, expanding);

      if (matched) {
        afterExp      = str;
        str           = this.getExpansion(used);
        wasExpanding  = expanding;
        expanding     = true;
        expansionRoot = true;
        matched       = false;
      }
    }

    if (type == 'token') {

      // Token

      pattern = value[this.modeIndex];

      DISAMBIGUATE_MATCH:
      do {

        ACCRETE_MATERIAL:
        while (str.length < minimum) {
          if (expanding)
            break DISAMBIGUATE_MATCH;

          const more = await this.read();

          if (more)
            str += more;
          else
            break ACCRETE_MATERIAL;
        }

        matched = str.match(pattern);

        if (matched) {
          [ used ] = matched;

          str = str.slice(used.length);

          // If we have consumed the entire string under review on one token, it
          // may be considered an ambiguous match. We must ignore what we have
          // taken and repeat the procedure with more data -- until we hit a
          // case where some unmatched remainder exists (unless, of course, itâ€™s
          // EOF).

          if (!expanding && !str && !isEOF)
            str += await this.read();
        }

      } while (!expanding && !str && !isEOF)

    } else {

      // Disjunction & Series

      for (const item of items) {
        [ more, str, matched ] = await this.parse(item, str, expanding);

        if (more)
          used += more;

        const resolved =
          type == 'series' && !matched ||
          type == 'disjunction' && matched;

        if (resolved) break;

        if (expansionRoot && !str) {
          expanding     = wasExpanding;
          expansionRoot = false;
          str           = afterExp;
        }
      }

      if (!matched) {
        str  = used + str;
        used = '';
      }
    }

    // Quantifier application

    if (quant == '*' || quant == '?')
      matched = true;

    if (matched && (quant == '*' || quant == '+')) {
      [ more, str ] = await this.parse(production, str, expanding);

      if (more)
        used += more;
    }

    if (expansionRoot && str) {
      // TODO
      return [ '', afterExp, false ];
    }

    if (matched) {
      const { becomes, collects, emits, takes } = production;

      if (becomes) {
        this.store[becomes] = used;
      } else if (collects) {
        this.store[collects] = this.store[collects] || [];
        this.store[collects].push(used);
      }

      if (emits) {
        const opts = {};

        for (const opt of takes) {
          opts[opt] = this.store[opt];
          this.store[opt] = undefined;
        }

        this.dest[emits](opts);
      }
    }

    return [ used, str, matched ];
  }

  getExpansion(str) {

  }
}

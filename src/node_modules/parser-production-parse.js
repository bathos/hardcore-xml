
// PATTERNS ////////////////////////////////////////////////////////////////////

const START = /^\(\s*/;
const END   = /^\s*\)/;
const PIPE  = /^\|/;
const QUANT = /^[\*\+\?]/;
const WHITE = /^\s+/;

const patterns = [ START, END, PIPE, QUANT, WHITE ];

// PARSE PRODUCTION STRING /////////////////////////////////////////////////////

// Consume an antlr-like ebnfish string to generate a tree of series and
// disjunction branches with ‘matching’ leaves. The result needs further
// processing to replace ‘production’ leaves with their actual values, which
// cannot be done at this stage since there may be circular references.

export default (str) => {
  str = str.trim();

  if (!str.startsWith('(')) str = `(${ str })`;
  
  let active = { items: [] };

  const stack = [ ];
  
  stringLoop:
  while (str.length) {
    
    patternLoop:
    for (const pattern of patterns) {
      
      const [ match ] = str.match(pattern) || [];
      
      if (!match) continue patternLoop;
      
      str = str.slice(match.length);

      if (active.implicitSeries && (pattern == END || pattern == PIPE)) {
        active.items = active.items.filter(item => item);
        active = stack.pop();
      }
      
      switch (pattern) {
        case START:
          const parent = active;
          active = { type: 'series', quant: '', items: [] };
          parent.items.push(active);
          stack.push(parent);
          continue stringLoop;
        case END:
          if (active.items.length === 1 && !active.quantifier) {
            const parent = stack.pop();
            parent.items.pop();
            parent.items.push(active.items[0]);
            stack.push(parent);
          } else if (!active.items.length) {
            const parent = stack.pop();
            parent.items.pop();
            stack.push(parent);
          }
          active.items = active.items.filter(item => item);
          active = stack.pop();
          continue stringLoop;
        case PIPE:
          active.type = 'disjunction';
          active.items.push(null);
          continue stringLoop;
        case QUANT:
          const item = active.items.pop();
          if (!item || (item.type == 'literal')) {
            active.items.push(item);
            break patternLoop;
          }
          item.quant = match;
          active.items.push(item, null);
          continue stringLoop;
        case WHITE:
          if (active.type == 'disjunction') {
            const item = {
              type: 'series',
              quant: '',
              items: [ active.items.pop() ],
              implicitSeries: true
            };

            active.items.push(item);
            stack.push(active);
            active = item;
          }
          active.items.push(null);
          continue stringLoop;
      }
    }
    
    const [ char ] = str;

    str = str.slice(1);
    
    const item = active.items.pop() || {
      value: '',
      type:
        char == '@' ? 'production' :
        char == '$' ? 'token' :
        'literal'
    };
    
    item.value += char;
    
    active.items.push(item);
  }
  
  if (stack.length)
    throw new Error('nope');
  
  return active.items[0];
}

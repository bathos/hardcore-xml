
// PRODUCTIONS /////////////////////////////////////////////////////////////////
//
// Production patterns use an EBNF-like syntax to describe grammar at the parser
// level similarly to antlr. The values in a pattern are a whitespace delimited
// list (parens and pipes also act as delimiters). An item beginning with a
// dollar sign is a reference to a production. An item beginning with an at sign
// is a reference to a token. Aside from the syntactic characters -- ?+*)(| plus
// space -- and these references, other characters form ‘anonymous’ or ‘literal’
// tokens.
//
// The *, + and ? characters are quantifiers which may appear after any
// reference or parenthesized group. Whitespace between references or literals
// means they form a *series*. A pipe means they form a disjunction. Parens form
// explicit groups, which may themselves have quantifiers. The disjunction
// operator has a higher precedence than space. Thus "a b | c" means
// "((a b) | c)"; in other words, a disjunction whose first choice is a series.
//
// Whitespace, contextually the ‘series operator’, can be made of one or more \s
// chars, so newlines are okay.
//
// Non-deterministic patterns are permissable but not advised, since they are
// less efficient.
//
// There is no escape character. If parens, spaces, or pipes are needed in a
// pattern, they must be referenced via tokens that include them. Quantifiers
// however may appear in literal tokens so long as they don’t follow a
// parenthesized group.
//
// A production may indicate an event that will be emitted on successful
// completion. The "emits" property indicates the event name. It must be paired
// with the "takes" property, which is a list of zero or more arguments that
// will be consumed by the event and provisioned to listeners.
//
// The 'becomes' property says that the entire text value corresponding to the
// successful production will become an argument that can thereafter be
// consumed by an event. Since tokens cannot have these properties, in cases
// where a single token corresponds to an argument, a production must be
// defined with the single token as its pattern.
//
// The 'collects' property is like 'becomes' but accumulates matching values
// into an array.
//
// Unlike tokens, there is no means to create seperate patterns for strict and
// sloppy mode -- all such concerns fall on tokens and the parser. In the case
// of html, which has unique grammatical differences from xml, there is a
// seperate document entry point which leads to paths with different
// productions and events, though there are plenty of shared productions, too.
//
// The implicit exception to this is that literal patterns are created with the
// 'i' flag for sloppy mode.
//
// Some productions possess the 'expands' property, a secondary production which
// can be matched at any point (and takes precedence) but, rather than becoming
// part of the text value of the matched production, is used to return another
// chunk of data for parsing in its place.
//
// Many productions have somewhat arbitrary limits. For example, $prolog could
// instead be inlined in $document. In these cases the divisions are mainly to
// keep things clean, readable, and reusable. But other concerns exist. In the
// case of 'becomes', naturally there is a 'correct' answer -- it must match
// exactly the text which is to become value x. In the case of 'emits' there is
// more leeway, but nonetheless there will usually be a practical point informed
// by the needs of listening agents. In the case of 'expands', the production
// is imbued with additional meaning: any expansion must ‘land’ inside the
// production that spawned it. In other words, in this special case the
// production is considered as a state member of a hierarchy or stack. An
// expansion may add to the stack, so long as it rolls things back before
// concluding, and so long as it does not lead to matches ‘outside’ the spawning
// production.
//
// A one-off property, 'childrenExpand', causes any descendent nodes to inherit
// a parent’s ability to expand references. This is done to prevent duplication
// of every dtd declaration production (internal vs external expansion rules).
//
// Altogether there are five key entry points: $document, $htmlDocument,
// $externalDTD, $externalEntity, and $fragment.

export const $attdef = {
  pattern: '@S $name @S $attType @S $defaultDecl',
  emits: 'attribute definition',
  takes: [ 'name', 'type', 'enumeration', 'defaultType', 'value' ]
};

export const $attlistDecl = {
  pattern: '$attlistDeclStart $attDef* @S? >',
  emits: 'attlist declaration end',
  takes: []
};

export const $attlistDeclStart = {
  pattern: '<!ATTLIST @S $name',
  emits: 'attlist declaration begin',
  takes: [ 'name' ]
}

export const $attribute = {
  pattern: '$name @EQ $attValue',
  emits: 'attribute',
  takes: [ 'name', 'value' ]
};

export const $attType = {
  pattern: '$attTypeKeyword | $attTypeNotation | $attTypeEnumeration'
};

export const $attTypeEnum = {
  pattern: '@NMTOKEN',
  collects: 'enumeration',
};

export const $attTypeEnumeration = {
  pattern: '@LP $attTypeEnum ( @P $attTypeEnum )* @RP'
};

export const $attTypeKeyword = {
  pattern:
    'CDATA | ID | IDREF | IDREFS | ENTITY | ENTITIES | NMTOKEN | NMTOKENS',
  becomes: 'type'
};

export const $attTypeKeywordNotation = {
  pattern: 'NOTATION',
  becomes: 'type'
};

export const $attTypeNotation = {
  pattern:
    `$attTypeKeywordNotation @S @LP $attTypeNotationName (
      @P $attTypeNotationName
    )* @RP`
};

export const $attTypeNotationName = {
  pattern: '@NAME',
  collects: 'enumeration'
};

export const $attValue = {
  pattern: `" $attValueDQ " | ' $attValueSQ '`
};

export const $attValueDQ = {
  pattern: '@ATTVALDQ*',
  expands: '@GEREF',
  becomes: 'value'
};

export const $attValueSQ = {
  pattern: '@ATTVALSQ*',
  expands: '@GEREF',
  becomes: 'value'
};

export const $cdSect = {
  pattern: '<![CDATA[ $cdSectContent? ]]>',
  emits: 'cdata section',
  takes: [ 'content' ]
};

export const $cdSectContent = {
  pattern: '@CDSTEXT',
  becomes: 'content'
};

export const $comment = {
  pattern: '<!-- $commentContent? -->',
  emits: 'comment',
  takes: [ 'content' ]
};

export const $commentContent = {
  pattern: '@COMTEXT',
  becomes: 'content'
};

export const $conditionalSect = {
  pattern: `<![ @S? (INCLUDE @S? [ $extSubset | IGNORE @S? [ $ignored* ) ]]>`,
  expands: '@PEREF'
};

export const $contentSpec = {
  pattern: '$csKeyword | $csMixed | $csGroup'
};

export const $csElem = {
  pattern: '$name $quant?',
  emits: 'content spec member',
  takes: [ 'name', 'quantifier' ]
};

export const $csGroup = {
  pattern:
    `$csGroupBegin $csMember (
      ( $csPipe $csMember )+ |
      ( @COMMA $csMember )+
    )? $csGroupEnd`
};

export const $csGroupBegin = {
  pattern: '@LP',
  emits: 'content spec group begin',
  takes: []
};

export const $csGroupEnd = {
  pattern: '@RP $quant?',
  emits: 'content spec group end',
  takes: [ 'quantifier' ]
};

export const $csMember = {
  pattern: '$csElem | $csGroup'
};

export const $csPipe = {
  pattern: '@P',
  emits: 'content spec group disjunction',
  takes: []
};

export const $csKeyword = {
  pattern: 'EMPTY | ANY',
  becomes: 'spec',
  emits: 'content spec',
  takes: [ 'spec' ]
};

export const $csMixed = {
  pattern: '@LP #PCDATA (@RP | (@P $csMixedName )* @RP * )',
  emits: 'content spec',
  takes: [ 'mixedElems' ]
};

export const $csMixedName = {
  pattern: '@NAME',
  collects: 'mixedElems'
};

export const $defaultDecl = {
  pattern: '$defaultDeclKeyword | ($defaultDeclKeywordFixed @S)? $attValue'
};

export const $defaultDeclKeyword = {
  pattern: '#REQUIRED | #IMPLIED',
  becomes: 'defaultType'
};

export const $defaultDeclKeywordFixed = {
  pattern: '#FIXED',
  becomes: 'defaultType'
};

export const $doctypeDecl = {
  pattern: '$doctypeDeclStart @S? ([ $internalDTD ] @S?)? >',
  emits: 'doctype end',
  takes: []
};

export const $doctypeDeclStart = {
  pattern: '<!DOCTYPE @S $name (@S $externalID)?',
  emits: 'doctype begin',
  takes: [ 'name', 'publicID', 'systemID' ]
};

export const $document = {
  pattern: '$prolog $element $misc* @EOF',
  emits: 'end of file',
  takes: []
};

export const $element = {
  pattern:
    `$elementOpenTagBegin ( @WS $attribute )* @WS?
      (
        $elementSelfClose |
        > ( $elementContent )* $elementCloseTag
      )`
};

export const $elementCloseTag = {
  pattern: '@CLOSE $name @S? >',
  emits: 'element end',
  takes: [ 'name' ]
};

export const $elementContent = {
  pattern: '$element | $cdSect | $procInst | $comment | $text'
  expands: '@GEREF'
};

export const $elementDecl = {
  pattern: '<!ELEMENT @S $name @S $contentSpec @S? >'
  emits: 'element declaration end',
  takes: []
};

export const $elementDeclBegin = {
  pattern: '<!ELEMENT @S $name @S',
  emits: 'element declaration begin',
  takes: [ 'name' ]
};

export const $elementOpenTagBegin = {
  pattern: '< $name',
  emits: 'element begin',
  takes: [ 'name' ]
};

export const $elementSelfClose = {
  pattern: '@SELFCLOSE',
  emits: 'element end',
  takes: []
};

export const $encodingDecl = {
  pattern: `@S encoding @EQ ( " $encodingName " | ' $encodingName ' )`
};

export const $encodingName = {
  pattern: '@ENCNAME',
  becomes: 'encoding'
};

export const $entityDecl = {
  pattern:
    `<!ENTITY @S (
      $percent @S $name @S ($entityValue | $externalID) |
      $name ($entityValue | $externalID (@S NDATA @S $ndataName)? )
    ) >`,
  emits: 'entity declaration',
  takes: [ 'isParameter', 'name', 'systemID', 'publicID', 'value', 'ndata' ]
};

export const $entityValue = {
  pattern: `" $entityValueDQ " | ' $entityValueSQ '`
};

export const $entityValueDQ = {
  pattern: '@ENTVALDQ*',
  expands: '@GEREF | @PEREF',
  becomes: 'value'
};

export const $entityValueSQ = {
  pattern: '@ENTVALSQ*',
  expands: '@GEREF | @PEREF',
  becomes: 'value'
};

export const $externalDTD = {
  pattern: '$textDecl? $extSubset @EOF',
  emits: 'end of file',
  takes: []
};

export const $externalEntity = {
  pattern: '$textDecl? $externalEntityValue? @EOF',
  emits: 'external entity value',
  takes: [ 'value' ]
};

export const $externalEntityValue = {
  pattern: '@ANYTHING',
  takes: 'value'
};

export const $externalID = {
  pattern: 'SYSTEM @S $systemID | PUBLIC @S $publicID @S $systemID'
};

export const $extSubset = {
  pattern:
    `(
      $extDeclaration |
      $conditionalSect |
      $procInst | $comment | @S
    )*`,
  expands: '@PEREF',
  childrenExpand: true
};

export const $extDeclaration = {
  pattern: `$elementDecl | $attlistDecl | $entityDecl | $notationDecl`,
  expands: '@PEREF',
  childrenExpand: true
};

export const $fragment = {
  pattern: '$textDecl? $elementContent* @EOF',
  emits: 'end of file',
  takes: []
};

export const $ignored = {
  pattern: '@IGNORE? (<![ $ignored ]]> @IGNORE?)*'
};

export const $instruction = {
  pattern: '@INSTRUCTION',
  becomes: 'instruction'
};

export const $internalDTD = {
  pattern:
    `(
      $elementDecl |
      $attlistDecl |
      $entityDecl |
      $notationDecl |
      $procInst | $comment | @S
    )*`,
  expands: '@PEREF'
};

export const $misc = {
  pattern: '$comment | $procInst | @S'
};

export const $name = {
  pattern: '@NAME',
  becomes: 'name'
};

export const $ndataName = {
  pattern: '@NAME',
  becomes: 'ndata'
};

export const $notationDecl = {
  pattern: '<!NOTATION @S $name @S $notationID @S? >',
  emits: 'notation declaration',
  takes: [ 'name', 'systemID', 'publicID' ]
};

export const $notationID = {
  pattern: 'SYSTEM @S $systemID | PUBLIC @S $publicID (@S $systemID)?'
};

export const $percent = {
  pattern: '%',
  becomes: 'isParameter'
};

export const $procInst = {
  pattern: '<? $target (@S $instruction?)? ?>',
  emits: 'processing instruction',
  takes: [ 'target', 'instruction' ]
};

export const $prolog = {
  pattern: '$xmlDecl? $misc* ($doctypeDecl $misc*)?'
};

export const $publicID = {
  pattern: `" $publicIDDQ " | ' $publicIDSQ '`
};

export const $publicIDDQ = {
  pattern: '@PIDDQ?',
  becomes: 'publicID'
};

export const $publicIDSQ = {
  pattern: '@PIDSQ?',
  becomes: 'publicID'
};

export const $quant = {
  pattern: '* | + | ?',
  becomes: 'quantifier'
};

export const $standaloneDecl = {
  pattern: `@S standalone @EQ ( " $standaloneVal " | ' $standaloneVal ' )`
};

export const $standaloneVal = {
  pattern: '@SDDVAL',
  becomes: 'standalone'
};

export const $systemID = {
  pattern: `" $systemIDDQ " | ' $systemIDSQ '`
};

export const $systemIDDQ = {
  pattern: '@SIDDQ?',
  becomes: 'systemID'
};

export const $systemIDSQ = {
  pattern: '@SIDSQ?',
  becomes: 'systemID'
};

export const $target = {
  pattern: '@TARGET',
  becomes: 'target'
};

export const $text = {
  pattern: '@CDATA',
  becomes: 'content',
  emits: 'text',
  takes: [ 'content' ]
};

export const $textDecl = {
  pattern: '<?xml $versionDecl? $encodingDecl @S? ?>',
  emits: 'text declaration',
  takes: [ 'version', 'encoding' ]
};

export const $versionDecl = {
  pattern: `@S version @EQ ( " $versionNum " | ' $versionNum ' )`
};

export const $versionNum = {
  pattern: '1. @DIGITS',
  becomes: 'version'
};

export const $xmlDecl = {
  pattern: '<?xml $versionDecl $encodingDecl? $standaloneDecl? @S? ?>',
  emits: 'xml declaration',
  takes: [ 'version', 'encoding', 'standalone' ]
};

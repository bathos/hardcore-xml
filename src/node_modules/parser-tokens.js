
// CHAR CLASS RANGE COMPONENTS /////////////////////////////////////////////////

const $chr = /[\u{9}\u{A}\u{D}\u{20}-\uD7FF\uE000-\uFFFD\u{10000}-\u{10FFFF}]/u.source;
const $ncs = /[:A-Z_a-z\u{C0}-\u{D6}\u{D8}-\u{F6}\u{F8}-\u{2FF}\u{370}-\u{37D}\u{37F}-\u{1FFF}\u{200C}-\u{200D}\u{2070}-\u{218F}\u{2C00}-\u{2FEF}\u{3001}-\u{D7FF}\u{F900}-\u{FDCF}\u{FDF0}-\u{FFFD}\u{10000}-\u{EFFFF}]/u.source;
const $ncc = /[:A-Z_a-z\u{C0}-\u{D6}\u{D8}-\u{F6}\u{F8}-\u{2FF}\u{370}-\u{37D}\u{37F}-\u{1FFF}\u{200C}-\u{200D}\u{2070}-\u{218F}\u{2C00}-\u{2FEF}\u{3001}-\u{D7FF}\u{F900}-\u{FDCF}\u{FDF0}-\u{FFFD}\u{10000}-\u{EFFFF}\-\.0-9\u{B7}\u{300}-\u{36F}\u{203F}-\u{2040}]*/u.source;
const $wsp = /[\n\r\t ]/u.source;

const $name = (new RegExp(`${ $ncs }(?:${ ncs }|${ ncc })*`)).source;

const $permissiveNC = /[^\s\!"#%&'\(\)\*\+,\/<=>\?\[\]\|]/u.source;

// TOKENS //////////////////////////////////////////////////////////////////////
//
// Tokens are represented as pairs of regex patterns. The first is the ‘strict’
// pattern corresponding to the formal XML spec; the second is a more permissive
// pattern used when parsing in sloppy or html mode. The second pattern may be
// omitted if it is not different from the first.
//
// Token patterns should never be able to match zero characters. Any such
// pattern should be refactored so that its zero-character match is instead
// represented with a ? or + quantifier in productions that employ it.
//
// Keep in mind that Babel can only transpile u-flagged pattern literals; there
// is no runtime support for ES6 regex flags. Reusable character classes that
// include higher unicode ranges are created above (note that the values are the
// *source strings*, not the regex patterns themselves) so that they can be
// integrated into constructor-instantiated patterns without the flag below.
//
// You may note that XML actually needs far more tokens than those described
// here. The other tokens are created implicitly based on literal string values
// in the production definitions. This is done for tokens that always have a
// single, literal form, like "<?xml", and helps keep the productions easy to
// read.
//
// Tokens that are arbitrarily consumptive barring some delimiter sequence are
// not modeled like in antlr. This sort of thing is what regex is good at, so
// we avail ourselves by way of negative lookaheads.
//
// The permissive tokens for text sequences in positions that may contain entity
// references will eat ampersands / percent signs when in the first position
// and not after because this plays nice with how entity ref matches take place
// while still allowing errant punc that isn’t part of a genuine reference to
// pass through. Also note char refs are always allowed through, because
// expanding char refs is actually done at the node construction level.

export const ANYTHING = [
  // The ANYTHING token is a special case for reading external entity values.
  // After the optional text declaration, we wish to eat everything
  // indiscriminately, even categorically invalid characters. This is because a
  // malformed external entity value does not lead to an error until (and
  // unless) it is actually used; that’s when it really gets parsed.
  /[\S\s]+/u
];

export const ATTVALDQ = [
  /^(?:&#(?:[0-9]+|x[0-9A-Fa-f]+);|[\t\r\n\u0020-\u0021\u0023-\u0025\u0027-\u003B\u003D-\uD7FF\uE000-\uFFFD\u{10000}-\u{10FFFF}]+)/u,
  /^&?[^"&]+/u
];

export const ATTVALSQ = [
  /^(?:&#(?:[0-9]+|x[0-9A-Fa-f]+);|[\t\r\n\u0020-\u0025\u0028-\u003B\u003D-\uD7FF\uE000-\uFFFD\u{10000}-\u{10FFFF}]+)/u,
  /^&?[^'&]+/u
];

export const CDATA = [
  /^(?:(?:(?!\]\]>)&#(?:[0-9]+|x[0-9A-Fa-f]+);|[\t\r\n\u0020-\u0025\u0027-\u003B\u003D-\uD7FF\uE000-\uFFFD\u{10000}-\u{10FFFF}]))+/u,
  /^[^<]+/u
];

export const CDSTEXT = [
  new RegExp(`^(?:(?!\\]\\]>)${ $char })*`),
  /^(?:(?!\]\]>)[\S\s])*/u
];

export const CLOSE = [
  /^<\//,
  /^<\s*\//u
];

export const COMMA = [
  /^[\n\r\t ]*,[\n\r\t ]*/,
  /^\s*,\s*/u
];

export const COMTEXT = [
  /^(?:(?!--)[\t\r\n\u0020-\uD7FF\uE000-\uFFFD\u{10000}-\u{10FFFF}])+/u,
  /^(?:(?!-->)[\S\s])+/u
];

export const DIGITS = [
  /^[0-9]+/
];

export const ENCNAME = [
  /^[A-Z][A-Z0-9\._\-]*/i,
  /^[^"']+/u
];

export const ENTVALDQ = [
  /^(?:&#(?:[0-9]+|x[0-9A-Fa-f]+);|[\t\r\n\u0020-\u0021\u0023-\u0024\u0027-\u003B\u003D-\uD7FF\uE000-\uFFFD\u{10000}-\u{10FFFF}]+)/u,
  /^[&%]?[^"&%]+/u
];

export const ENTVALSQ = [
  /^(?:&#(?:[0-9]+|x[0-9A-Fa-f]+);|[\t\r\n\u0020-\u0024\u0028-\u003B\u003D-\uD7FF\uE000-\uFFFD\u{10000}-\u{10FFFF}]+)/u,
  /^[&%]?[^'&%]+/u
];

export const EOF = [
  // We use the ETX character code (which is illegal in XML anyway) as an EOF
  // signal for finalizing the Document production.
  /^\u0003/
];

export const EQ = [
  new RegExp(`^${ $wsp }*=${ $wsp }*`),
  /^\s*=\s*/u
];

export const GEREF = [
  new RegExp(`^&${ $name };`)
];

export const IGNORE = [
  /^(?:(?!<!\[|\]\]>)[\t\r\n\u0020-\uD7FF\uE000-\uFFFD\u{10000}-\u{10FFFF}])+/u,
  /^(?:(?!<!\[|\]\]>)[\S\s])+/u
];

export const INSTRUCTION = [
  new RegExp(`(?:(?!\\?>)${ $chr })*`),
  /^(?:(?!\?>)[\S\s])*/u
];

export const LP = [
  /^\([\n\r\t ]*/,
  /^\s*\(/u
];

export const NAME = [
  new RegExp(`^${ $name }`),
  new RegExp(`^${ permissiveNC }+`)
];

export const NMTOKEN = [
  new RegExp(`^(?:${ ncs }|${ ncc })+`),
  new RegExp(`^${ permissiveNC }+`)
];

export const P = [
  /^[\n\r\t ]*\|[\n\r\t ]*/,
  /^\s*\|\s*/u
];

export const PEREF = [
  new RegExp(`^%${ $name };`)
];

export const PIDDQ = [
  /^[\n\r !#-%'-;=\?-Z_a-z]+/,
  /^[^"]+/u
];

export const PIDSQ = [
  /^[\n\r !#-%\(-;=\?-Z_a-z]+/,
  /^[^']+/u
];

export const RP = [
  /^[\n\r\t ]*\)/,
  /^\s*\)/u
];

export const S = [
  new RegExp(`^${ $wsp }+`),
  /^\s+/u
];

export const SDDVAL = [
  /^(?:yes|no)/,
  /^\s*(?:true|false|y(?:es)?|no?|[10])\s*/iu
];

export const SELFCLOSE = [
  /^\/>/,
  /^\/\s*>/u
];

export const SIDDQ = [
  /^[\t\r\n\u0020-\u0021\u0023-\uD7FF\uE000-\uFFFD\u{10000}-\u{10FFFF}]+/u,
  /^[^"]+/u
];

export const SIDSQ = [
  /^[\t\r\n\u0020-\u0026\u0028-\uD7FF\uE000-\uFFFD\u{10000}-\u{10FFFF}]+/u,
  /^[^']+/u
];

export const TARGET = [
  new RegExp(`^(?![Xx][Mm][Ll](?=[ \\n\\r\\t\\?]))${ $name }`)
  new RegExp(`^(?![Xx][Mm][Ll](?=[ \\n\\r\\t\\?]))${ $permissiveNC }+`)
];

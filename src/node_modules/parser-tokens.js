
// CHAR CLASS RANGE COMPONENTS /////////////////////////////////////////////////

const $chr = /[\u{9}\u{A}\u{D}\u{20}-\uD7FF\uE000-\uFFFD\u{10000}-\u{10FFFF}]/u.source;
const $ncs = /[:A-Z_a-z\u{C0}-\u{D6}\u{D8}-\u{F6}\u{F8}-\u{2FF}\u{370}-\u{37D}\u{37F}-\u{1FFF}\u{200C}-\u{200D}\u{2070}-\u{218F}\u{2C00}-\u{2FEF}\u{3001}-\u{D7FF}\u{F900}-\u{FDCF}\u{FDF0}-\u{FFFD}\u{10000}-\u{EFFFF}]/u.source;
const $ncc = /[:A-Z_a-z\u{C0}-\u{D6}\u{D8}-\u{F6}\u{F8}-\u{2FF}\u{370}-\u{37D}\u{37F}-\u{1FFF}\u{200C}-\u{200D}\u{2070}-\u{218F}\u{2C00}-\u{2FEF}\u{3001}-\u{D7FF}\u{F900}-\u{FDCF}\u{FDF0}-\u{FFFD}\u{10000}-\u{EFFFF}\-\.0-9\u{B7}\u{300}-\u{36F}\u{203F}-\u{2040}]*/u.source;

const $name = (new RegExp(`${ $ncs }(?:${ ncs }|${ ncc })*`)).source;

const $permissiveNC = /[^\s\!"#%&'\(\)\*\+,\/<=>\?\[\]\|]/u.source;

// TOKENS //////////////////////////////////////////////////////////////////////
//
// Tokens are represented as pairs of regex patterns. The first is the ‘strict’
// pattern corresponding to the formal XML spec; the second is a more permissive
// pattern used when parsing in sloppy or html mode. The second pattern may be
// omitted if it is not different from the first.
//
// In fact this is not really the list of XML tokens at all. Rather, this module
// describes the subset of tokens which cannot be represented in "literal" form.
// Many of these tokens share a common form: a character class match paired with
// a negative lookahead. This departs significantly from the antlr model, but I
// found it considerably more direct than the alternative, which is to tokenize
// at the level of the individual character (so that the delimiter token can
// be the higher precendence match at every position). That model is really just
// a less efficient and more complex way of saying exactly what these regex
// patterns convey elegantly.
//
// It is critical that every token pattern described here matches on *at least
// one character* and also, with extremely limited conditions, *on* one. That is
// to say, no pattern may begin with characters that match only when a later
// condition is satisfied, though they may act in reverse (they may match
// *except* when a later condition is satisfied). This arrangement lets us deal
// with our asynchronous, at-any-point-possibly-incomplete input stream; that
// a single character match is guaranteed (if any might occur) in turn means
// that a non-match is really not a match. Meanwhile literal tokens can be
// understood to require some specific number of characters to be read
// unambiguously.
//
// Keep in mind that Babel can only transpile u-flagged pattern literals; there
// is no runtime support for ES6 regex flags. Reusable character classes that
// include higher unicode ranges are created above (note that the values are the
// *source strings*, not the regex patterns themselves) so that they can be
// integrated into constructor-instantiated patterns without the flag below.
//
// The permissive tokens for text sequences in positions that may contain entity
// references will eat ampersands / percent signs when in the first position
// and not after because this plays nice with how entity ref matches take place
// while still allowing errant punc that isn’t part of a genuine reference to
// pass through. Also note char refs are always allowed through, because
// expanding char refs is actually done at the node construction level.

export const ANYTHING = [
  // The ANYTHING token is a special case for reading external entity values.
  // After the optional text declaration, we wish to eat everything
  // indiscriminately, even categorically invalid characters. This is because a
  // malformed external entity value does not lead to an error until (and
  // unless) it is actually used; that’s when it really gets parsed.
  /[\S\s]+/u
];

export const ATTVALDQ = [
  /^(?:&#(?:[0-9]+|x[0-9A-Fa-f]+);|[\t\r\n\u0020-\u0021\u0023-\u0025\u0027-\u003B\u003D-\uD7FF\uE000-\uFFFD\u{10000}-\u{10FFFF}]+)/u,
  /^&?[^"&]+/u
];

export const ATTVALSQ = [
  /^(?:&#(?:[0-9]+|x[0-9A-Fa-f]+);|[\t\r\n\u0020-\u0025\u0028-\u003B\u003D-\uD7FF\uE000-\uFFFD\u{10000}-\u{10FFFF}]+)/u,
  /^&?[^'&]+/u
];

export const CDATA = [
  /^(?:(?:(?!\]\]>)&#(?:[0-9]+|x[0-9A-Fa-f]+);|[\t\r\n\u0020-\u0025\u0027-\u003B\u003D-\uD7FF\uE000-\uFFFD\u{10000}-\u{10FFFF}]))+/u,
  /^[^<]+/u
];

export const CDSTEXT = [
  new RegExp(`^(?:(?!\\]\\]>)${ $char })+`),
  /^(?:(?!\]\]>)[\S\s])+/u
];

export const COMTEXT = [
  /^(?:(?!--)[\t\r\n\u0020-\uD7FF\uE000-\uFFFD\u{10000}-\u{10FFFF}])+/u,
  /^(?:(?!-->)[\S\s])+/u
];

export const DIGITS = [
  /^[0-9]+/
];

export const ENCNAME = [
  /^[A-Z][A-Z0-9\._\-]*/i,
  /^[^"']+/u
];

export const ENTVALDQ = [
  /^(?:&#(?:[0-9]+|x[0-9A-Fa-f]+);|[\t\r\n\u0020-\u0021\u0023-\u0024\u0027-\u003B\u003D-\uD7FF\uE000-\uFFFD\u{10000}-\u{10FFFF}]+)/u,
  /^[&%]?[^"&%]+/u
];

export const ENTVALSQ = [
  /^(?:&#(?:[0-9]+|x[0-9A-Fa-f]+);|[\t\r\n\u0020-\u0024\u0028-\u003B\u003D-\uD7FF\uE000-\uFFFD\u{10000}-\u{10FFFF}]+)/u,
  /^[&%]?[^'&%]+/u
];

export const EOF = [
  // We use the ETX character code (which is illegal in XML anyway) as an EOF
  // signal for finalizing the Document production.
  /^\u0003/
];

export const IGNORE = [
  /^(?:(?!<!\[|\]\]>)[\t\r\n\u0020-\uD7FF\uE000-\uFFFD\u{10000}-\u{10FFFF}])+/u,
  /^(?:(?!<!\[|\]\]>)[\S\s])+/u
];

export const INSTRUCTION = [
  new RegExp(`(?:(?!\\?>)${ $chr })*`),
  /^(?:(?!\?>)[\S\s])*/u
];

export const LP = [
  /^\([\n\r\t ]*/,
  /^\(\s*/u
];

export const NAME = [
  new RegExp(`^${ $name }`),
  new RegExp(`^${ $permissiveNC }+`)
];

export const NMTOKEN = [
  new RegExp(`^(?:${ $ncs }|${ $ncc })+`),
  new RegExp(`^${ $permissiveNC }+`)
];

export const P = [
  /^\|/,
];

export const PIDDQ = [
  /^[\n\r !#-%'-;=\?-Z_a-z]+/,
  /^[^"]+/u
];

export const PIDSQ = [
  /^[\n\r !#-%\(-;=\?-Z_a-z]+/,
  /^[^']+/u
];

export const RP = [
  /^\)/,
  /^\)/u
];

export const S = [
  /^[\n\r\t ]+/
  /^\s+/u
];

export const SIDDQ = [
  /^[\t\r\n\u0020-\u0021\u0023-\uD7FF\uE000-\uFFFD\u{10000}-\u{10FFFF}]+/u,
  /^[^"]+/u
];

export const SIDSQ = [
  /^[\t\r\n\u0020-\u0026\u0028-\uD7FF\uE000-\uFFFD\u{10000}-\u{10FFFF}]+/u,
  /^[^']+/u
];

export const TARGET = [
  new RegExp(`^(?![Xx][Mm][Ll](?=[ \\n\\r\\t\\?]))${ $name }`)
  new RegExp(`^(?![Xx][Mm][Ll](?=[ \\n\\r\\t\\?]))${ $permissiveNC }+`)
];

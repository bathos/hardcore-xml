
// IMPORTS /////////////////////////////////////////////////////////////////////

import ParseError   from 'parse-error';
import msg          from 'msg';
import { Writable } from 'stream';

// PATTERNS ////////////////////////////////////////////////////////////////////

const divide   = /^(?:<([^>]+)>|([^<>]+))/;
const white    = /^[\t\r\n ]+$/;
const whiteOpt = /^[\t\r\n ]*$/

const anyAttrVal    = '[^>\\n\\r\\t ]+';
const encName       = '[A-Za-z]([A-Za-z\\d\\.\\-_])*';
const equals        = `${ whiteOpt }=${ whiteOpt }`;
const standalone    = 'no|yes';
const versionNumber = '1\\.\\d+';

const xmlDeclPattern = new RegExp(
	`^\\?xml${ white }version${ equals }` +
	`(?:"(${ versionNumber })"|'(${ versionNumber })'|(${ anyAttrVal }))` +
		`(?:${ white }encoding${ equals }` +
		`(?:"(${ encName })"|'(${ encName })')|(${ anyAttrVal }))?` +
		`(?:${ white }standalone${ equals }` +
		`(?:"(${ standalone })"|'(${ standalone })'|(${ anyAttrVal }))` +
		`)?` +
	`${ whiteOpt }>$`
);

// DECORATORS //////////////////////////////////////////////////////////////////

const unwritable = (target, name, descriptor) => {
	descriptor.writable = false;
	return descriptor;	
};

// NODE CLASSES ////////////////////////////////////////////////////////////////

class XMLNode {
	
}

class XMLDocument extends XMLNode {
	constructor() {
		super();

		this.version    = null;
		this.encoding   = null;
		this.standalone = null;
		this.docType    = null;
	}
}

// PARSER SYMBOLS //////////////////////////////////////////////////////////////

const $activeNode        = Symbol('prop: active node');
const $discardWhitespace = Symbol('prop: discard whitespace');
const $document          = Symbol('prop: document');
const $documentPosition  = Symbol('prop: document position');
const $processTag        = Symbol('method: process tag');
const $processText       = Symbol('method: process text');
const $text              = Symbol('prop: text buffer');

const $start            = Symbol('state: start');
const $afterXMLDecl     = Symbol('state: after xml declaration');
const $afterDocTypeDecl = Symbol('state: after doctype declaration');
const $afterPrologue    = Symbol('state: after prologue');
const $inDocument       = Symbol('state: in document');

// PARSER //////////////////////////////////////////////////////////////////////

export default class XMLParser extends Writable {
	constructor({ discardWhitespace=true }={}) {
		super({ decodeStrings: false });

		this[$discardWhitespace] = discardWhitespace;
		this[$document]          = new XMLDocument();
		this[$documentPosition]  = $start;
		this[$activeNode]        = this[$document];
		this[$text]              = '';

		this.on('finish', () => {
			const text = this[$text];
			if (text) {
				const err = new ParseError(msg.badEnd, text, text.length - 1);
				this.emit('error', err);
			}
		});
	}

	@unwritable
	_write(chunk, enc, cb) {
		chunk = this[$text] + chunk.toString();

		// In older versions of this, when I was concerned with very predictable
		// documents and didn’t bother with the more obscure parts of the XML
		// spec, the whole thing was a char-by-char state machine. Once I began
		// handling doctypes and entities this was no longer practical -- there
		// are too many tokens comprised by longer sequences of characters to
		// deal with. So we first break up incoming data into ‘tags’ and ‘text’
		// to be processed as units (though note that where a tag will always be
		// whole, text can pass through incomplete). For our purposes the tags
		// group includes things like CDATA -- it’s anything enclosed in <>.

		// For our matching loop, exec is not currently an option because the
		// sticky flag has not yet been implemented.

		try {

			let [ match, tag, text ] = chunk.match(divide) || [];

			while (match) {

				if (tag)
					this[$processTag](tag);
				else if (text)
					this[$processText](text);

				chunk = chunk.substr(match.length);

				[ match, tag, text ] = chunk.match(divide) || [];
			}

			this[$text] = chunk;

			cb();

		} catch (err) {
			this.emit('error', err);
		}
	}

	@unwritable
	write() {
		super.write(...arguments);
	}

	[$processTag](str) {
		const basis = `<${ str }>`;

		let parts = str.split(white);

		let [ initial ] = parts.unshift();

		if (!initial) throw new ParseError(str, msg.illegalWhitespace);

		// XML DECLARATION /////////////////////////////////////////////////////

		if (initial == '?xml') {
			if (this[$documentPosition] == $start) {
				const [
					versionA, versionB, versionC,
					encodingA, encodingB, encodingC,
					standaloneA, standaloneB, standaloneC
				] = str.match(xmlDeclPattern) || [];

				if (versionC) {
					const i = str.indexOf(versionC);
					throw new ParseError(msg.badVersion(versionC), basis, i);
				}

				if (encodingC) {
					const i = str.indexOf(encodingC);
					throw new ParseError(msg.badEncoding(encodingC), basis, i);
				}

				if (standaloneC) {
					const i = str.indexOf(standaloneC);
					throw new ParseError(msg.badSDD(standaloneC), basis, i);
				}

				const version = versionA || versionB;
				const encoding = encodingA || encodingB;
				const standalone = standaloneA || standaloneB;

				if (!version)
					throw new ParseError(msg.badXMLDecl, basis, 2);

				const doc = this[$document];

				doc.version = parseFloat(version);
				if (encoding) doc.encoding = encoding;
				if (standalone) doc.standalone = standalone == 'yes';

				this[$documentPosition] = $afterXMLDecl;

				return;
			} else {
				throw new ParseError(msg.misplacedXMLDecl, basis, 2);
			}
		}

		// DOCTYPE DECLARATION /////////////////////////////////////////////////

		console.log('tag: ', str);
	}

	[$processText](str) {
		if (!this[$documentPosition] != $inDocument)
			throw new ParseError(msg.illegalAtRoot, str);

		if (this[$discardWhitespace] && str.match(white)) return;

		console.log('text: ', str);
	}
}



//var h = (new (require('./lib/node_modules/parser.js'))());h.write('<hello> there</hello> <goodbye> yes</goodbye>');

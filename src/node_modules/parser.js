
// IMPORTS /////////////////////////////////////////////////////////////////////

import 'babel/polyfill';

import ParseError   from 'parse-error';
import msg          from 'msg';
import { Writable } from 'stream';

// PATTERN COMPONENTS //////////////////////////////////////////////////////////

// const char        = '[\\t\\r\\n -\uD7FF\uE000-\uFFFD\u{10000}-\u{10FFFF}]';
const char          = '[\\t\\r\\n -\uD7FF\uE000-\uFFFD]';
const whiteReq      = '[\\t\\r\\n ]+';
const whiteOpt      = '[\\t\\r\\n ]*';

const nameStart = [
	'A-Za-z:_',
	'\u00C0-\u00D6', '\u00D8-\u00F6', '\u00F8-\u02FF',
	'\u0370-\u037D', '\u037F-\u1FFF', '\u200C-\u200D',
	'\u2070-\u218F', '\u2C00-\u2FEF', '\u3001-\uD7FF',
	'\uF900-\uFDCF', '\uFDF0-\uFFFD' //, '\u{10000}-\u{EFFFF}'
].join('');

const nameContinue = [
	nameStart, '\\-\\.\\d', '\u00B7', '\u0300-\u036F', '\u203F-\u2040'
].join('');

const anyAttrVal    = '[^>\\t\\r\\n ]+';
const encName       = '[A-Za-z]([A-Za-z\\d\\.\\-_])*';
const equals        = `${ whiteOpt }=${ whiteOpt }`;
const standalone    = 'no|yes';
const versionNumber = '1\\.\\d+';

// PATTERNS: LOW-LEVEL /////////////////////////////////////////////////////////

const divide =
	/^(?:<!--(.+)-->|<!\[CDATA\[(.+)\]\]>|<([^>]+"[^"]*"[^>]*|[^>]+'[^']*'[^>]*|[^>]+)>|([^<>]+)(?=<))/u;

const white         = new RegExp(`^${ whiteReq }$`);
const whiteAnywhere = new RegExp(whiteReq);

// PATTERNS: VALIDATION & PARSING //////////////////////////////////////////////
// Babel provides partial support for the ‘u’ flag by expanding class symbols
// like ‘.’ in regex literals. However, proper handling of the SMP is out of
// reach, as is the use of the ‘u’ flag in non-literals (at least without some
// kind of runtime augmentation, and I doubt the masses are clamoring for it).
// Once the ‘u’ flag gets native support in V8, the commented out pattern
// components above should be activated and the patterns below with the asterisk
// comments should be given the flag.

const charsEntirely     = new RegExp(`^${ char }+$`);                       // *
const charsFromStart    = new RegExp(`^${ char }+`);                        // *
const encNamePattern    = new RegExp(`^${ encName }$`);

const namePattern = new RegExp(`^[${ nameStart }][${ nameContinue }]*$`);   // *

const tagNamePattern = new RegExp(                                          // *
	`^(?:([${ nameStart }][${ nameContinue }]*):)?` +
	`([${ nameStart }][${ nameContinue }]*)$`
);	

const permissiveTagNamePattern = /(?:([^:\t\r\n ]+):)?([^\t\r\n ]+)/;

const xmlDeclPattern = new RegExp(
	`^\\?xml${ whiteReq }version${ equals }` +
	`(?:"(${ versionNumber })"|'(${ versionNumber })'|(${ anyAttrVal }))` +
		`(?:${ whiteReq }encoding${ equals }` +
		`(?:"(${ encName })"|'(${ encName })')|(${ anyAttrVal }))?` +
		`(?:${ whiteReq }standalone${ equals }` +
		`(?:"(${ standalone })"|'(${ standalone })'|(${ anyAttrVal }))` +
		`)?` +
	`${ whiteOpt }>$`
);

const xmlPattern = /^xml$/i;

const attrPattern = new RegExp(
	`([^\\n\\r\\t= ]+)(?:${ equals }(?:"([^"]*)"|'([^']*)'|([^\\n\\r\\t ]+)))?`
);

// PATTERNS: TRANSFORMATION ////////////////////////////////////////////////////

const badAmpersand = new RegExp(                                            // *
	`&(?!#\\d+;|#x[\\dA-Fa-f]+;|[${ nameStart }][${ nameContinue }]+;)`, 'g'
);

const badLT = /</g;

const badThingie = /\]\]>/g;

// UTIL ////////////////////////////////////////////////////////////////////////

const cleanAttVal = val => {
	val = String(val);

	return val.replace(badAmpersand, '&amp;').replace(badLT, '&lt;');
};

const cleanText = val => {
	val = String(val);

	return cleanAttVal(val).replace(badThingie, ']]&gt;');
};

const escapeQuote = quote => (quote == '"') ? '&quot;' : '&apos;';

const indent = (depth, ws) => new Array(depth + 1).join(String(ws) || '');

const validQuote = quote => (quote == '"' || quote == '\'') ? quote : '"';

// DECORATORS //////////////////////////////////////////////////////////////////

const unwritable = (target, name, descriptor) => {
	descriptor.writable = false;
	return descriptor;	
};

const accessor = (target, name, descriptor) => {
	descriptor.enumerable = true;
	descriptor.configurable = false;
	return descriptor;
}

// NODE SYMBOLS ////////////////////////////////////////////////////////////////

const $attributes     = Symbol('prop: attributes of a node');
const $children       = Symbol('prop: children of a node');
const $constructor    = Symbol('prop: the legal type of a restricted array');
const $content        = Symbol('prop: text content');
const $doctype        = Symbol('prop: doctype');
const $encoding       = Symbol('prop: xml encoding');
const $externalID     = Symbol('prop: external doctype ID');
const $instruction    = Symbol('prop: property instruction content');
const $internalSubset = Symbol('prop: internal doctype subset');
const $key            = Symbol('prop: attribute key');
const $name           = Symbol('prop: tag name');
const $namespace      = Symbol('prop: namespace');
const $parent         = Symbol('prop: parent node (used for parsing only)');
const $standalone     = Symbol('prop: xml standalone');
const $target         = Symbol('prop: property instruction target');
const $validate       = Symbol('method: throw type error for restricted array');
const $value          = Symbol('prop: attribute value');
const $version        = Symbol('prop: xml version');

// RESTRICTED ARRAYS ///////////////////////////////////////////////////////////

// This section should be updated once we have Proxy :(

class RestrictedArray extends Array {
	constructor(constructor) {
		super();

		this[$constructor] = constructor;
	}

	[$validate](...args) {
		const constructor = this[$constructor];
		const valid = args.every(arg => arg instanceof constructor);

		if (!valid) throw new TypeError(msg.invalidType(constructor.name));
	}

	@unwritable
	concat() {
		this[$validate](...arguments);
		super.concat(...arguments);
	}

	// Note: push, unshift, splice, and fill, the mutative methods, all rely on
	// concat internally. This was interesting to discover -- at first it wasn’t
	// obvious why I was hitting the stack ceiling.
}

class Attributes extends RestrictedArray {
	constructor() {
		super(Attribute);
	}

	[$validate](...args) {
		super[$validate](...args);

		const keys = args.concat(this).map(attr => attr.key);

		for (const key of keys)
			if (~keys.indexOf(key, keys.indexOf(key) + 1))
				throw new TypeError(msg.cannotHaveDuplicateKeys(key));
	}

	@unwritable
	toString({ withNamespace=true, quote='"' }={}) {
		this[$validate]();

		return this.map(
			attr => attr.toString({ withNamespace, quote })
		).join(' ');
	}
}

class Children extends RestrictedArray {
	constructor() {
		super(Node);
	}

	@unwritable
	toString({ withNamespace=true, whitespace='\t', quote='"', d=0 }={}) {
		this[$validate]();

		return this.map(
			child => child.toString({ withNamespace, whitespace, quote, d })
		).join(whitespace ? '\n' : '');
	}
}

class DocChildren extends Children {
	constructor() {
		super();
	}

	[$validate](...args) {
		super[$validate](...args);

		let valid = args.every(arg => !(arg instanceof Text));

		if (!valid) throw new TypeError(msg.invalidType('Text'));

		valid = args.every(arg => !(arg instanceof CDATA));

		if (!valid) throw new TypeError(msg.invalidType('CDATA'));

		valid = 1 >= args.concat(this)
			.reduce((acc, arg) => acc + (arg instanceof Element), 0);

		if (!valid) throw new TypeError(msg.cannotHaveMultipleRoots);
	}

}

// DOCUMENT ////////////////////////////////////////////////////////////////////

class Document {
	constructor() {
		this.children = new DocChildren();
	}

	@accessor
	get children() { return this[$children]; }
	set children(val) {
		this[$children] =
			(val instanceof DocChildren) ? val : new DocChildren();
	}

	@accessor
	get version() { return this[$version]; }
	set version(val) {
		val = parseFloat(val);

		if (val >= 1 && val < 2)
			this[$version] = val;
	}

	@accessor
	get encoding() { return this[$encoding]; }
	set encoding(val) {
		val = String(val);

		if (encNamePattern.test(val))
			this[$encoding] = val;
	}

	@accessor
	get standalone() { return this[$standalone]; }
	set standalone(val) {
		if (val === true || val === false) {
			this[$standalone] = val;
			return;
		}

		if (val instanceof Boolean) {
			this[$standalone] = val.valueOf();
			return;
		}

		val = String(val);

		if (val === 'yes')
			this[$standalone] = true;
		else if (val === 'no')
			this[$standalone] = false;
	}

	@accessor
	get doctype() { return this[$doctype]; }
	set doctype(val) {
		if (val instanceof Doctype || val === undefined)
			this[$doctype] = val;
	}

	@unwritable
	toString({ withNamespace=true, whitespace='\t', quote='"' }={}) {
		quote = validQuote(quote);

		const doc = [];

		let version = this.version;

		if (version) {
			version = version == 1 ? '1.0' : version.toString();

			const encoding   = this.encoding;
			const standalone = this.standalone;

			doc.push(`<?xml version=${ quote }${ version }${ quote }${
				encoding ? ` encoding=${ quote }${ encoding }${ quote }` : ''
			}${
				standalone !== undefined ? ` standalone=${ quote }${
					standalone ? 'yes' : 'no'
				}${ quote }` : ''
			} ?>`);
		}

		if (this.doctype) doc.push(this.doctype.toString());

		if (this.children.length) doc.push(
			this.children.toString({ withNamespace, whitespace, quote })
		);

		return doc.join(whitespace ? '\n' : '');
	}
}

// NODE ////////////////////////////////////////////////////////////////////////

class Node { }

class NamedNode extends Node {
	constructor(name, namespace) {
		super();

		this[$name]       = name;
		this[$namespace]  = namespace;
	}

	@accessor
	get name() { return this[$name]; }
	set name(val) {
		if (val === undefined) {
			this[$name] = val;
			return;
		}

		val = String(val);

		if (namePattern.test(val))
			this[$name] = val;
	}

	@accessor
	get namespace() { return this[$namespace]; }
	set namespace(val) {
		if (val === undefined) {
			this[$namespace] = val;
			return;
		}

		val = String(val);

		if (namePattern.test(val))
			this[$namespace] = val;
	}

	@accessor
	get fullName() {
		return (this.namespace) ? this.namespace + ':' + this.name : this.name;
	}
}

class Element extends NamedNode {
	constructor() {
		super(...arguments);

		this[$attributes] = new Attributes();
		this[$children]   = new Children();
	}

	@accessor
	get last() {
		const children = this[$children];
		return children[children.length - 1];
	}

	@accessor
	get children() { return this[$children]; }
	set children(val) {
		this[$children] =
			(val instanceof Children) ? val : new Children();
	}

	@accessor
	get attributes() { return this[$attributes]; }
	set attributes(val) {
		this[$attributes] =
			(val instanceof Attributes) ? val : new Attributes();
	}

	@unwritable
	toString({ withNamespace=true, whitespace='\t', quote='"', d=0 }={}) {
		quote = validQuote(quote);

		const p = indent(d, whitespace);

		d++;

		const children =
			this.children.toString({ withNamespace, whitespace, quote, d });

		const attributes = this.attributes.toString({ withNamespace, quote });

		const openTag =
			(withNamespace ? this.fullName : this.name) +
			(attributes ? ` ${ attributes }` : '');

		if (!children)
			return `${ p }<${ openTag }/>`;

		return `${ p }<${ openTag }>\n${ children }\n${ p }</${ this.name }>`;
	}
}

// DOCTYPE /////////////////////////////////////////////////////////////////////

class Doctype extends Node {
	constructor(doctypeName, externalID, internalSubset) {
		super();

		// TODO
	}

	@unwritable
	toString() {
		// TODO
	}
}

// ATTRIBUTE ///////////////////////////////////////////////////////////////////

class Attribute {
	constructor(key, value) {
		this.key   = key;
		this.value = value;
	}

	@accessor
	get key() { return this[$key]; }
	set key(val) {
		val = String(val);

		if (namePattern.test(val))
			this[$key] = val;
	}

	@accessor
	get value() { return this[$value]; }
	set value(val) {
		if (val === undefined) {
			this[$key] = '';
			return;
		}

		this[$value] = cleanAttVal(val);
	}

	@unwritable
	toString({ withNamespace=true, quote='"' }={}) {
		quote = validQuote(quote);

		let value = this.value || '';
		let key = this.key;

		if (~value.indexOf(quote)) {
			const replacement = escapeQuote(quote);
			value = value.replace(new RegExp(quote, 'g'), replacement);
		}

		return `${ key }=${ quote }${ value }${ quote }`;
	}
}

// TEXT ////////////////////////////////////////////////////////////////////////

class Text extends Node {
	constructor(str) {
		super();
		this.content = str;
	}

	@accessor
	get content() { return this[$content]; }
	set content(val) {
		this[$content] = val === undefined ? '' : cleanText(val);
	}

	@unwritable
	toString({ whitespace='\t', d=0 }={}) {
		return indent(d, whitespace) + this.content;
	}
}

// CDATA ///////////////////////////////////////////////////////////////////////

class CDATA extends Node {
	constructor(str) {
		super();
		this.content = str;
	}

	@accessor
	get content() { return this[$content]; }
	set content(val) {
		if (val === undefined) {
			this[$content] = '';
			return;
		}

		val = String(val);

		// Note: ]]> within a CDATA node is not only invalid, it’s unescapable.
		// This means we can’t clean up in this case. Of course it is possible
		// to include such a thing effectively since you could use two CDATA
		// nodes or a combination of text and CDATA nodes, but there’s nothing
		// we can do to facilitate this in the constructor, which doesn’t know
		// its ultimate context.

		this[$content] = badThingie.test(val) ? '' : val;
	}

	@unwritable
	toString({ whitespace='\t', d=0 }={}) {
		return `${ indent(d, whitespace) }<![CDATA[ ${ this.content } ]]>`;
	}
}

// COMMENT /////////////////////////////////////////////////////////////////////

class Comment extends Node {
	constructor(str) {
		super();

		this.content = str;
	}

	@accessor
	get content() { return this[$content]; }
	set content(val) {
		if (val === undefined) {
			this.content = val;
			return;
		}

		val = String(val);

		// Like CDATA’s ]]>, a comment cannot include -- and it can’t be
		// escaped.

		const invalid = ~val.indexOf('--') || !charsEntirely.test(val);

		this[$content] = invalid ? '' : val;
	}

	@unwritable
	toString({ whitespace='\t', d=0 }={}) {
		return `${ indent(d, whitespace) }<!-- ${ this.content } -->`;
	}
}

// PROCESSING INSTRUCTION //////////////////////////////////////////////////////

class ProcessingInstruction extends Node {
	constructor(target, instruction) {
		super();

		this.target      = target;
		this.instruction = instruction;
	}

	@accessor
	get target() { return this[$target]; }
	set target(val) {
		val = String(val);

		if (xmlPattern.match(val))
			this[$target] = val;
	}

	@accessor
	get instruction() { return this[$instruction]; }
	set instruction(val) {
		if (val === undefined) {
			this.val = undefined;
			return;
		}

		val = String(val);

		this[$instruction] = charsEntirely.test(val) ? val : undefined;
	}

	@unwritable
	toString({ whitespace='\t', d=0 }={}) {
		return `${
			indent(d, whitespace)
		}<?${
			this.target
		} ${
			(this.instruction ? this.instruction + ' ' : '')
		}?>`;
	}
}

// PARSER SYMBOLS //////////////////////////////////////////////////////////////

const $activeNode        = Symbol('prop: active node');
const $discardWhitespace = Symbol('prop: discard whitespace');
const $document          = Symbol('prop: document');
const $documentPosition  = Symbol('prop: document position');
const $permissive        = Symbol('prop: permissive');
const $processCDATA      = Symbol('method: process CDATA');
const $processCloseTag   = Symbol('method: process closing tag');
const $processComment    = Symbol('method: process comment');
const $processDoctype    = Symbol('method: process doctype declaration');
const $processOpenTag    = Symbol('method: process opening tag');
const $processPI         = Symbol('method: process processing instruction');
const $processTag        = Symbol('method: process tag');
const $processText       = Symbol('method: process text');
const $processXMLDecl    = Symbol('method: process XML declaration');
const $text              = Symbol('prop: text buffer');

const $start             = Symbol('state: start');
const $afterXMLDecl      = Symbol('state: after xml declaration');
const $afterDocTypeDecl  = Symbol('state: after doctype declaration');
const $afterPrologue     = Symbol('state: after prologue');
const $inDocument        = Symbol('state: in document root node tree');
const $afterDocument     = Symbol('state: after document root node completed');

// PARSER //////////////////////////////////////////////////////////////////////

export default class XMLParser extends Writable {
	constructor({ discardWhitespace=true, permissive=false }={}) {
		super({ decodeStrings: false });

		this[$discardWhitespace] = discardWhitespace;
		this[$document]          = new Document();
		this[$documentPosition]  = $start;
		this[$permissive]        = permissive;
		this[$activeNode]        = this[$document];
		this[$text]              = '';

		this.on('finish', () => {
			const strict = !this[$permissive];
			const text   = this[$text] || '';
			const pos    = this[$documentPosition];

			if (text || (strict && pos != $afterDocument)) {
				const err = new ParseError(msg.badEnd, text, text.length - 1);
				this.emit('error', err);
			} else {
				this.emit('document', this[$document]);
				console.log(this[$document].toString());
			}
		});
	}

	@unwritable
	_write(chunk, enc, cb) {
		chunk = this[$text] + chunk.toString();

		// In older versions of this, when I was concerned with very predictable
		// documents and didn’t bother with the more obscure parts of the XML
		// spec, the whole thing was a char-by-char state machine. Once I began
		// handling doctypes and entities this was no longer practical -- there
		// are too many tokens comprised by longer sequences of characters to
		// deal with. So we first break up incoming data into ‘tags’ and ‘text’
		// to be processed as units. For our purposes the tags group includes
		// things like CDATA -- it’s anything enclosed in <>.

		// For our matching loop, exec is not currently an option because the
		// sticky flag has not yet been implemented.

		try {

			let [ match, comment, data, tag, text ] = chunk.match(divide) || [];

			while (match) {

				if (tag)
					this[$processTag](tag);
				else if (text)
					this[$processText](text);
				else if (comment)
					this[$processComment](comment);
				else if (data)
					this[$processCDATA](data);

				chunk = chunk.substr(match.length);

				[ match, comment, data, tag, text ] = chunk.match(divide) || [];
			}

			this[$text] = chunk;

			cb();

		} catch (err) {
			this.emit('error', err);
		}
	}

	@unwritable
	write() {
		super.write(...arguments);
	}

	[$processCDATA](cdata) {
		if (!this[$permissive]) {

			const basis = '<![CDATA[' + cdata + ']]>';

			if (this[$documentPosition] != $inDocument)
				throw new ParseError(msg.misplacedCDATA, basis, 0);

			const [ validChars ] = cdata.match(charsFromStart) || [];

			if (validChars.length != cdata.length) {
				const invalidIndex = validChars.length + 4;
				throw new ParseError(msg.invalidChar, basis, invalidIndex);
			}
		}

		cdata = cdata.trim();

		this[$activeNode].children.push(new CDATA(cdata));
	}

	[$processCloseTag](basis, initial, parts) {
		const strict = !this[$permissive];
		const active = this[$activeNode];

		if (this[$documentPosition] !== $inDocument)
			throw new ParseError(msg.misplacedCloseTag, basis, 0);

		const tag = initial.substr(1);

		let [ , namespace, name ] = tag.match(tagNamePattern) || [];

		if (!name && !strict)
			[ , namespace, name ] = tag.match(permissiveTagNamePattern) || [];

		if (!name)
			throw new ParseError(msg.badTagName, basis, 2);

		if (name != active.name || namespace != active.namespace)
			throw new ParseError(msg.unmatched(active.fullName), basis, 2);

		if (strict && (parts[1] || parts.length > 2)) {
			const badIndex =
				name.length + (namespace ? namespace.length + 1 : 0) + 2;

			throw new ParseError(msg.closeTagContent, basis, badIndex);
		}

		this[$activeNode] = active[$parent];

		delete active[$parent];

		if (this[$activeNode] instanceof Document)
			this[$documentPosition] = $afterDocument;	
	}

	[$processComment](comment) {
		if (this[$documentPosition] == $start)
			this[$documentPosition] = $afterXMLDecl;

		if (!this[$permissive]) {

			const basis = `<!--${ comment }-->`;

			const badIndex = comment.indexOf('--');

			if (~badIndex)
				throw new ParseError(msg.commentDblHyphen, basis, badIndex + 4);

			if (comment.endsWith('-'))
				throw new ParseError(msg.comment3Dash, basis, basis.length - 4);

			const [ validChars ] = comment.match(charsFromStart) || [];

			if (validChars.length != comment.length) {
				const invalidIndex = validChars.length + 4;
				throw new ParseError(msg.invalidChar, basis, invalidIndex);
			}
		}

		comment = comment.trim();

		this[$activeNode].children.push(new Comment(comment));
	}

	[$processDoctype](basis, str, parts) {
		const strict = !this[$permissive];

		if (this[$documentPosition] != $afterXMLDecl)
			if (strict)
				throw new ParseError(msg.misplacedDoctype, basis, 0);
			else
				return;

		const [ , doctype ] = parts;

		if (!doctype)
			if (strict)
				throw new ParseError(msg.missingDoctypeName, basis, 10);
			else
				return;

		if (!namePattern.test(doctype) && strict)
			throw new ParseError(msg.badDoctypeName(doctype), basis, 10);

		// TODO!!!
		let extID, internal;
		// TODO!!!

		this[$document].doctype = new Doctype(doctype, extID, internal);
	}

	[$processOpenTag](basis, str, initial, parts) {
		const strict = !this[$permissive];
		const pos    = this[$documentPosition];
		const active = this[$activeNode];

		if (this[$documentPosition] == $afterDocument)
			throw new ParseError(msg.multipleRoots, basis, 0);

		this[$documentPosition] = $inDocument;

		if (initial.endsWith('/')) initial = initial.slice(0, -1);

		const [ , namespace, name ] = initial.match(tagNamePattern) || [];

		if (!name)
			throw new ParseError(msg.badTagName, basis, 2);

		const node = new Element(name, namespace);

		active.children.push(node);

		if (!str.endsWith('/') || (!strict && str.trim().endsWith('/'))) {
			node[$parent]     = active;
			this[$activeNode] = node;
		} else if (this[$activeNode] instanceof Document) {
			this[$documentPosition] = $afterDocument;	
		}

		let remainder = parts.slice(1).join(' ');

		remainder = remainder.replace(/\s*\/$/, '');

		let [ mat, key, valA, valB, valC ] = remainder.match(attrPattern) || [];

		while (mat) {
			if (strict) {
				if (!namePattern.test(key)) {
					const badIndex = basis.indexOf(mat);
					throw new ParseError(msg.invalidChar, basis, badIndex);
				}

				if (valC) {
					const badIndex = basis.indexOf(valC);
					throw new ParseError(msg.unwrappedVal, basis, badIndex);
				}

				if (valA === undefined && valB === undefined) {
					const badIndex = basis.indexOf(mat) + key.length;
					throw new ParseError(msg.missingVal, basis, badIndex);
				}
			}

			const val = valA || valB || valC || '';

			if (strict && badAmpersand.exec(val)) {
				const badIndex = badAmpersand.lastIndex + basis.indexOf(val);
				
				badAmpersand.lastIndex = 0;

				throw new ParseError(msg.illegalAmpersand, basis, badIndex);
			}

			const badIndexLT = val.indexOf('<');

			if (strict && ~badIndexLT) {
				const badIndex = badIndexLT + basis.indexOf(val);
				throw new ParseError(msg.illegalLT, basis, badIndexLT);
			}

			node.attributes.push(new Attribute(key, val));

			remainder = remainder.substr(mat.length);

			[ mat, key, valA, valB, valC ] = remainder.match(attrPattern) || [];
		}	
	}

	[$processPI](basis, str, initial) {
		const strict = !this[$permissive];
		const piTarget = initial.substr(1);

		if (!piTarget)
			throw new ParseError(msg.missingPITarget, basis, 2);

		if (strict) {

			if (xmlPattern.match(piTarget))
				throw new ParseError(msg.badPITarget(piTarget), basis, 2);

			if (!namePattern.test(piTarget))
				throw new ParseError(msg.badPITarget(piTarget), basis, 2);
		}

		let instruction = str.slice(initial.length, -2);

		if (instruction && strict) {

			const validChars = instruction.match(charsFromStart) || [];

			if (validChars.length != instruction.length) {
				const invalidIndex = validChars.length + initial.length + 1;
				throw new ParseError(msg.invalidChar, basis, invalidIndex);
			}
		}

		if (instruction) {
			instruction = instruction.trim();

			if (this[$discardWhitespace])
				instruction = instruction.replace(whiteAnywhere, ' ');
		}

		if (!str.endsWith('?') && strict)
			throw new ParseError(msg.badPIEnd, basis, basis.length - 1);

		this[$activeNode].children.push(
			new ProcessingInstruction(piTarget, instruction)
		);
	}

	[$processTag](str) {
		const strict = !this[$permissive];
		const basis = `<${ str }>`;

		let parts = str.split(whiteAnywhere);

		let [ initial ] = parts;

		if (!initial && !strict) {
			[ , initial ] = parts;
			parts.shift();
		}

		if (!initial)
			throw new ParseError(str, msg.illegalWhitespace);

		if (initial == '?xml')
			return this[$processXMLDecl](basis, str)

		if (this[$documentPosition] == $start)
			this[$documentPosition] = $afterXMLDecl;

		if (initial.startsWith('?'))
			return this[$processPI](basis, str, initial)

		if (initial == '!DOCTYPE')
			return this[$processDoctype](basis, str, parts);

		if (initial.startsWith('/'))
			return this[$processCloseTag](basis, initial, parts);

		this[$processOpenTag](basis, str, initial, parts);
	}

	[$processText](str) {
		const strict = !this[$permissive];

		if (!this[$documentPosition] != $inDocument)
			if (strict)
				throw new ParseError(msg.illegalAtRoot, str);
			else
				return;

		if (this[$discardWhitespace] && str.match(white))
			return;

		if (strict && badAmpersand.exec(str)) {
			const badIndex = badAmpersand.lastIndex;
			
			badAmpersand.lastIndex = 0;

			throw new ParseError(msg.illegalAmpersand, str, badIndex);
		}

		const badIndexCD = str.indexOf(']]>');

		if (strict && ~badIndexCD)
			throw new ParseError(msg.illegalCDATAClose, str, badIndexCD);

		const badIndexLT = str.indexOf('<');

		if (strict && ~badIndexLT)
			throw new ParseError(msg.illegalLT, str, badIndexLT);

		if (this[$discardWhitespace])
			str = str.trim().replace(whiteAnywhere, ' ');

		this[$activeNode].children.push(new Text(str));
	}

	[$processXMLDecl](basis, str) {
		const strict = !this[$permissive];

		if (this[$documentPosition] == $start) {

			this[$documentPosition] = $afterXMLDecl;

			try {
				const doc = this[$document];

				const [
					verA, verB, verC,
					encA, encB, encC,
					sddA, sddB, sddC
				] = str.match(xmlDeclPattern) || [];

				if (verC) {
					const i = str.indexOf(verC);
					throw new ParseError(msg.badVersion(verC), basis, i);
				}

				const version = verA || verB;
				const encoding = encA || encB;
				const standalone = sddA || sddB;

				if (!version)
					throw new ParseError(msg.badXMLDecl, basis, 2);

				doc.version = version;

				if (encC) {
					const i = str.indexOf(encC);
					throw new ParseError(msg.badEncoding(encC), basis, i);
				}

				if (encoding) doc.encoding = encoding;

				if (sddC) {
					const i = str.indexOf(sddC);
					throw new ParseError(msg.badSDD(sddC), basis, i);
				}

				if (standalone) doc.standalone = standalone == 'yes';

				if (!str.endsWith('?')) {
					const badIndex = basis.length - 1;
					throw new ParseError(msg.badPIEnd, basis, badIndex);
				}

				return;
			} catch(err) {
				if (strict) throw err;
			}

		} else if (strict) {
			throw new ParseError(msg.misplacedXMLDecl, basis, 2);
		}
	}

	// EXPOSED CONSTRUCTORS ////////////////////////////////////////////////////


	@accessor
	static get Attribute() { return Attribute; }

	@accessor
	static get CDATA() { return CDATA; }

	@accessor
	static get Comment() { return Comment; }

	@accessor
	static get Doctype() { return Doctype; }

	@accessor
	static get Document() { return Document; }

	@accessor
	static get Element() { return Element; }

	@accessor
	static get ProcessingInstruction() { return ProcessingInstruction; }

	@accessor
	static get Text() { return Text; }
}



//var h = (new (require('./lib/node_modules/parser.js'))());h.write('<hello> there</hello> <goodbye> yes</goodbye>');

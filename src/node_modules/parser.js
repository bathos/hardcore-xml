// IMPORTS /////////////////////////////////////////////////////////////////////

import { Writable } from 'stream';

import { HardcoreSyntaxError as HSE, HardcoreTypeError as HTE } from 'errors';

import * as isValid from 'string-validation';

import 'msg';

import {
	AttListDeclaration,
	Attribute,
	AttributeDefinition,
	CDATASection,
	ChildElementGroup,
	ChildElementName,
	Comment,
	ConditionalSection,
	Doctype,
	DoctypeExternal,
	Document,
	DocumentFragment,
	Element,
	ElementDeclaration,
	EntityDeclaration,
	NotationDeclaration,
	ParameterReference,
	ProcessingInstruction,
	Text
} from 'nodes';

// UNIT TYPE SYMBOLS ///////////////////////////////////////////////////////////

const $attListDecl     = Symbol();
const $cdata           = Symbol();
const $comment         = Symbol();
const $dtdInlineClose  = Symbol();
const $dtdInlineOpen   = Symbol();
const $dtdSimple       = Symbol();
const $elemDecl        = Symbol();
const $entityDecl      = Symbol();
const $markedSectClose = Symbol();
const $markedSectOpen  = Symbol();
const $nodeStart       = Symbol();
const $notationDecl    = Symbol();
const $paramRef        = Symbol();
const $procInst        = Symbol();
const $tagClose        = Symbol();
const $tagEmpty        = Symbol();
const $tagOpen         = Symbol();
const $text            = Symbol();
const $whitespace      = Symbol();
const $xmlDecl         = Symbol();

// PATTERNS ////////////////////////////////////////////////////////////////////

// The matching patterns used at the ‘dissect’ stage are always permissive. We
// want to make the most minimal unambiguous match that tells us where a unit
// begins and ends and what it looks like it *should* be. Therefore whitespace,
// for example, is matched with \s instead of [\n\r\t ]. By always divvying up
// with permissive patterns, strict mode benefits by being able to tell a more
// accurate story about what exactly went wrong.

// Patterns are checked in order -- the sequence often matters. If a pattern has
// a beginning and ending, and the beginning matches but the end does not, the
// dissecter considers us to have entered ambiguous territory -- unless the
// terminal flag is true, in which case it will proceed down the list.

// The final stretch of the list includes patterns that specifically match
// erroneous sequences. Some of these will be forgiven in permissive mode, and
// in strict mode these once again assist us in reporting meaningful errors. 

const patterns = [
	{
		name: $paramRef,
		pattern: /%[^;\s]+;/,
		ambiguous: true
	},
	{
		name: $dtdInlineClose,
		pattern: /^\]\s*>/
	},
	{
		name: $markedSectClose,
		pattern: /^\]\]>/
	},
	{
		name: $text,
		pattern: /^[^<]*[^<\s]+[^<]*/,
		ambiguous: true
	},
	{
		name: $whitespace,
		pattern: /^\s+/,
		ambiguous: true
	},
	{
		name: $xmlDecl,
		pattern: /^<\?xml\s[\S\s]*?>/
	},
	{
		name: $procInst,
		pattern: /^<\?[\S\s]*?\?>/
	},
	{
		name: $comment,
		pattern: /^<!--[\S\s]*?-->/
	},
	{
		name: $cdata,
		pattern: /^<\[CDATA\[[\S\s]*?\]\]>/
	},
	{
		name: $markedSectOpen,
		pattern: /^<\[(?!CDATA)[^\[]*?\[/
	},
	{
		name: $dtdSimple,
		pattern: /^<!DOCTYPE\s([^>'"\[\]]+|"[^"]*"|'[^']*')*?>/
	},
	{
		name: $dtdInlineOpen,
		pattern: /^<!DOCTYPE\s([^>'"\[\]]+|"[^"]*"|'[^']*')*?\[/
	},
	{
		name: $elemDecl,
		pattern: /^<!ELEMENT[\S\s]*?>/
	},
	{
		name: $attListDecl,
		pattern: /^<!ATTLIST([^>'"\[\]]+|"[^"]*"|'[^']*')*?>/
	},
	{
		name: $entityDecl,
		pattern: /^<!ENTITY([^>'"\[\]]+|"[^"]*"|'[^']*')*?>/
	},
	{
		name: $notationDecl,
		pattern: /^<!NOTATION([^>'"\[\]]+|"[^"]*"|'[^']*')*?>/
	},
	{
		name: $tagClose,
		pattern: /^<\s*\/([^>'"]+|"[^"]*"|'[^']*')*>/
	},
	{
		name: $tagEmpty,
		pattern: /^<(?![\?\!])([^>'"]+|"[^"]*"|'[^']*')*\/\s*>/
	},
	{
		name: $tagOpen,
		pattern: /^<(?![\?\!])([^>'"]+|"[^"]*"|'[^']*')*>/
	},
	{
		name: $nodeStart,
		pattern: /^</,
		ambiguous: true
	}
];

const attDefPattern =
	/^[\n\r\t ]+([^\n\r\t ]+)[\n\r\t ]+(?:(CDATA|ID(?:REFS?)?|ENTIT(?:Y|IES)|NMTOKENS?)|(?:(NOTATION)[\n\r\t ]+)?\(([^\)]+)\))[\n\r\t ]+(?:(#REQUIRED|#IMPLIED)|(?:(?:(#FIXED)[\n\r\t ]+)?(?:"([^"]*)"|'([^']*)')))/g;

const attListDecl_strict =
	/^<!ATTLIST[\n\r\t ]+([^\n\r\t >]+)(.*?)[\n\r\t ]*>$/;

const attListDecl_sloppy =
	/^<!ATTLIST\s+(\S+)(.*?)\s*>$/;

const attr_strict =
	/^[\n\r\t ]*([^\n\r\t =]+)[\n\r\t ]*=[\n\r\t ]*(?:"([^<"]*)"|'([^<']*)')/;

const attr_sloppy =
	/([^\s=\\\/<>])\s*=\s*(?:"([^"]+)"|'([^']+)'|([^\s=\\\/<>]))/g;

const cdataPattern =
	/^<!\[CDATA\[(.*)\]\]>$/;

const commentPattern =
	/^<!--(.*)-->$/;

const dtdOpen_strict =
	/^<!DOCTYPE[\n\r\t ]+([^\n\r\t ]+)(?:[\n\r\t ]+SYSTEM[\n\r\t ]+(?:"([^"]*)"|'([^']*)')|PUBLIC[\n\r\t ]+(?:"([^"]*)"|'([^']*)')[\n\r\t ]+(?:"([^"]*)"|'([^']*)'))?[\n\r\t ]*[\[>]$/;

const dtdOpen_sloppy =
	/^<!DOCTYPE\s+(\S+)(?:\s+SYSTEM\s+(?:"([^"]*)"|'([^']*)')|PUBLIC\s+(?:"([^"]*)"|'([^']*)')\s+(?:"([^"]*)"|'([^']*)'))?\s*[\[>]$/;

const elemDecl_strict =
	/^<!ELEMENT[\n\r\t ]+([^\n\r\t ]+)[\n\r\t ]+(?:(EMPTY|ANY)|\((?:(?:[\n\r\t ]*(#PCDATA))((?:[\n\r\t ]*\|[\n\r\t ]*[^\n\r\t ]+)*)[\n\r\t ]*|([^\)]+))\)([\*\+\?])?)[\n\r\t ]*>/;

const elemDecl_sloppy =
	/^<!ELEMENT\s+(\S+)\s+(?:(EMPTY|ANY)|\((?:(?:\s*(#PCDATA))((?:\s*\|\s*\S+)*)\s*|([^\)]+))\)([\*\+\?])?)\s*>/;

const entityDecl_strict =
	/^<!ENTITY[\n\r\t ]+(%[\n\r\t ]+)?(\S+)[\n\r\t ]+(?:"([^"]*)"|'([^']*)'|(?:SYSTEM[\n\r\t ]+"([^"]*)"|'([^']*)'|PUBLIC[\n\r\t ]+"([^"]*)"|'([^']*)'[\n\r\t ]+"([^"]*)"|'([^']*)')(?:[\n\r\t ]+NDATA[\n\r\t ]+(\S+))?)[\n\r\t ]*>$/;

const entityDecl_sloppy =
	/^<!ENTITY\s+(%\s+)?(\S+)\s+(?:"([^"]*)"|'([^']*)'|(?:SYSTEM\s+"([^"]*)"|'([^']*)'|PUBLIC\s+"([^"]*)"|'([^']*)'\s+"([^"]*)"|'([^']*)')(?:\s+NDATA\s+(\S+))?)\s*>$/

const markedSectPattern =
	/^<!\[([\[]+)\[$/;

const notation_strict = 
	/^<!NOTATION[\n\r\t ]+([^\n\r\t ]+)(?:SYSTEM[\n\r\t ]+(?:"([^"]*)"|'([^']*)')|PUBLIC[\n\r\t ]+(?:"([^"]*)"|'([^']*)')(?:[\n\r\t ]+(?:"([^"]*)"|'([^']*)'))?)?[\n\r\t ]*>$/;

const notation_sloppy =
	/^<!NOTATION\s+(\S+)(?:SYSTEM\s+(?:"([^"]*)"|'([^']*)')|PUBLIC\s+(?:"([^"]*)"|'([^']*)')(?:\s+(?:"([^"]*)"|'([^']*)'))?)?\s*>$/;

const nsPattern =
	/^(?:(.+?):)?(.+)$/;

const pi_strict =
	/^<\?(\S+)[\n\r\t ]+(.*)\?>$/;

const pi_sloppy =
	/^<\?\s*(\S+)\s+(.*)\?>$/;

const tagClose_strict =
	/^<\/([^\n\r\t ]+)[\n\r\t ]*>$/;

const tagClose_sloppy =
	/^<\s*\/\s*([^>\s]+)[^>]*>$/;

const tagOpen_strict =
	/^<([^\n\r\t ]+)(?:[\n\r\t ]+([^\n\r\t ][\S\s]*?))?[\n\r\t ]*>$/;

const tagOpen_sloppy =
	/^<\s*(\S+)\s*([^>]*?)?\s*>$/;

const xmlDecl_strict =
	/^<\?xml[\n\r\t ]+version[\n\r\t ]*=[\n\r\t ]*(?:"(1\.\d+)"|'(1\.\d+)')(?:[\n\r\t ]+encoding[\n\r\t ]*=[\n\r\t ]*(?:"([A-Za-z][A-Za-z\d\._\-]*)"|'([A-Za-z][A-Za-z\d\._\-]*)'))?(?:[\n\r\t ]+standalone[\n\r\t ]*=[\n\r\t ]*(?:"(yes|no)"|'(yes|no)'))?[\n\r\t ]*\?>$/;

// UTIL ////////////////////////////////////////////////////////////////////////

const norm = function() {
	return this.trim().replace(/\s+/g, ' ');
};

const normTarget = val => {
	if (val === undefined || val === null) return;

	if (val instanceof Object)
		val = val.constructor.name;

	if (typeof val === 'string' || val instanceof String) {
		const norm = val.toUpperCase().replace(/\s/g, '');

		if (norm == 'DOCTYPEEXTERNAL')
			return 'DoctypeExternal';
		if (norm == 'DOCUMENT')
			return 'Document';
		if (norm == 'DOCUMENTFRAGMENT')
			return 'DocumentFragment';
		if (norm == 'ELEMENT')
			return 'Element';
	}

	throw new HTE(msg.invalidTarget, val);
};

const dissect = (remainder, isTerminal, units=[]) => {
	
	// Here, we take an incoming string and break it apart into discreet
	// components for further processing, where they will be interpretted to
	// build document nodes. After extracting as many complete units as possible
	// any remaining string is the ‘remainder’. The remainder is not always
	// ‘partial’ -- it may in fact be a complete unit except that there is still
	// ambiguity because the next (unknown) character could still change its
	// meaning. However, when `isTerminal` is true there is never ambiguity
	// because it says ‘this is the final string.’ 

	for (const { name, pattern, ambiguous } of patterns) {
		const [ match ] = remainder.match(pattern) || [];

		if (match) {

			if (name == $nodeStart && isTerminal)
				return { remainder, units };

			if (!isTerminal && ambiguous && str == match)
				return { remainder, units };

			remainder = remainder.slice(match.length);

			units.push({ name, match });

			if (remainder)
				return dissect(remainder, isTerminal, units);
			else
				return { remainder, units };
		}
	}

	// I think this is actually unreachable, but just to be safe:

	return { remainder, units };
};

const toContentSpecList = (str, arr=[]) => {
	const orig = str;

	// This whole bit ought to be refactored. Not exactly a paragon of elegance.

	let match, n, quantifier, sep = 'init';

	while (str) {

		if (!sep)
			throw new HSE(msg.malformedContentSpec, orig, str);

		[ match, n, quantifier='', sep ] =
			str.match(/^\s*(\S+)([\?\*\+])?\s*([,|]|$)/) || [];

		if (n) {
			const [ , namespace, name ] = n.match(nsPattern);

			const child = new ChildElementName({ namespace, name, quantifier });

			arr.push(child);

			const prevType = arr.type;

			arr.type = sep == ',' ? 'SEQUENCE' : arr.type || 'CHOICE';

			if (prevType && prevType != arr.type)
				throw new HSE(msg.malformedContentSpecSep, orig, str);

			str = str.slice(match.length);

		} else if (str.match(/^\s*\(/)) {

			let count = 0;
			let index = -1;

			for (const char of str) {
				index++;

				if (char == '(' || char == ')') {
					if (char == '(')
						count++
					else
						count--;

					if (!count) break;
				}
			}

			if (!count) {

				let segment = str.slice(0, index);

				str = str.slice(segment.length);

				[ match, quantifier='', sep ] =
					str.match(/^([\+\?\*])?([,\|])/) || [];

				const prevType = arr.type;

				arr.type = sep == ',' ? 'SEQUENCE' : arr.type || 'CHOICE';

				if (prevType && prevType != arr.type)
					throw new HSE(msg.malformedContentSpecSep, orig, str);

				const child = new ChildElementGroup({ quantifier });

				segment = segment.replace(/^\s*\(/, '');

				toContentSpecList(segment, child);

			} else {
				throw new HSE(msg.malformedContentSpecParen, orig, str);
			}

		} else {
			throw new HSE(msg.malformedContentSpec, orig, str);
		}
	}

	return arr;
};

// PARSER STATE SYMBOLS ////////////////////////////////////////////////////////

// Initial state.
const $start = Symbol();

// We’ve seen an xml or text declaration, or we have seen any other legal node. 
const $afterXMLDecl = Symbol();

// We are in an external DTD -- this is a final state.
const $externalDTD = Symbol();

// We are in the bracketed interior of an internal DTD.
const $internalDTD = Symbol();

// We are in a document, after a DTD but before the root.
const $afterDTD = Symbol();

// Special initial state for target == Element.
const $beforeRoot = Symbol();

// We are somewhere within the element tree of a document.
const $inRoot = Symbol();

// The root element of a document has resolved -- this is a final state.
const $afterRoot = Symbol();

// PARSER SYMBOLS //////////////////////////////////////////////////////////////

const $buffer      = Symbol();
const $doc         = Symbol();
const $html        = Symbol();
const $ignoreWhite = Symbol();
const $node        = Symbol();
const $normalize   = Symbol();
const $processUnit = Symbol();
const $state       = Symbol();
const $strict      = Symbol();
const $target      = Symbol();

// PARSER //////////////////////////////////////////////////////////////////////

export default class Parser extends Writable {
	constructor({ strict=true, ignoreWhite=true, html, normalize, target }={}) {
		super({ decodeStrings: false });

		this[$html]        = !!html;
		this[$ignoreWhite] = !!ignoreWhite;
		this[$normalize]   = !!normalize;
		this[$strict]      = !!strict;
		this[$target]      = normTarget(target);

		if (this.target === 'DocumentFragment') {
			this[$state] = $inElement;
			this[$doc]   = new DocumentFragment();
			this[$node]  = this[$doc];
		} else if (this.target === 'Element') {
			this[$state] = $beforeRoot;
		} else {
			this[$state] = $start;
			this[$opts] = {};
		}

		this[$buffer] = '';

		this.on('finish', () => {

			if (this[$buffer]) {
				const { remainder, units } = dissect(this[$buffer], true);

				for (const unit of units) this[$processUnit](unit);

				if (remainder) {
					const err = new HSE(msg.malformedRemainder, remainder);

					if (this.strict)
						return this.emit('error', err);
					else
						this.emit('wat', err);
				}
			}

			if (this[$doc]) {
				if ((this[$doc] == this[$node]) && this[$doc].isValid()) {
					return this.emit('result', this[$doc]);
				} else {
					const err = new HSE(msg.incompleteTarget(this.target));
				
					if (strict) {
						return this.emit('error', err);
					} else {
						this.emit('wat', err);
						this.emit('result', this[$doc]);
					}
				}
			} else {
				this.emit('error', new HSE(msg.completeGarbage));
			}
		});
	}

	get html() {
		return this[$html];
	}

	get ignoreWhite() {
		return this[$ignoreWhite];
	}

	get normalize() {
		return this[$normalize];
	}

	get strict() {
		return this[$strict];
	}

	get target() {
		return this[$target];
	}

	_write(chunk, enc, cb) {
		chunk = this[$buffer] + chunk.toString();

		const { remainder, units } = dissect(chunk);

		try {

			for (const unit of units) this[$processUnit](unit);

			this[$buffer] = remainder;

			cb();

		} catch (err) {
			this.emit('error', err);
		}
	}

	[$processUnit]({ match, name }) {
		const state  = this.state;
		const strict = this.strict;
		const target = this.target;

		if (name == $whitespace && (this.ignoreWhite || state != $inRoot))
			return;
		else if (name == $whitespace)
			name = $text;

		if (this[$state] == $start)
			this[$state] = $afterXMLDecl;

		const isElemContent =
			name == $cdata ||
			name == $comment ||
			name == $dtdInlineClose ||
			(name == $markedSectClose && !this.strict) ||
			name == $paramRef ||
			name == $procInst ||
			name == $tagClose ||
			name == $tagEmpty ||
			name == $tagOpen ||
			name == $text;

		if (target == 'Element') {

			if (state == $afterRoot) {
				const err = new HSE(msg.multipleElements, match);

				if (strict) {
					throw err;
				} else {
					this[$state] = $inRoot;
					return this.emit('wat', err);
				}
			}

			if (state == $beforeRoot && name != $tagOpen && name != $tagEmpty) {
				const err = new HSE(msg.notElement, match);

				if (strict)
					throw err;
				else
					return this.emit('wat', err);
			}
		}

		const shouldBeElemContent =
			target == 'Element' ||
			target == 'DocumentFragment' ||
			state == $inRoot;

		if (shouldBeElemContent) {
			if (name == $paramRef ||
				name == $dtdInlineClose ||
				name == $markedSectClose) {
					name = $text;
				}

			if (isElemContent)
				return this[name](match);
			else {
				const err = new HSE(msg.illegalInElement, match);

				if (strict)
					throw err;
				else
					return this.emit('wat', err);
			}
		}

		if (state != $start && name == $xmlDecl) {
			const err = new HSE(misplacedXMLDecl, match);

			if (strict)
				throw err;
			else
				return this.emit('wat', err);
		}

		if (!target) {
			const onlyDTDE =
				name == $attListDecl ||
				name == $elemDecl ||
				name == $entityDecl ||
				name == $markedSectOpen ||
				name == $notationDecl ||
				name == $paramRef;

			if (onlyDTDE) {
				this[$state]  = $externalDTD;
				this[$target] = 'DoctypeExternal';
				this[$node]   = this[$doc] = new DoctypeExternal(this[$opts]);

				this[name](match);
			}
		}

		if (target == 'DoctypeExternal') {

			let isValid =
				name == $attListDecl ||
				name == $comment ||
				name == $elemDecl ||
				name == $entityDecl ||
				name == $markedSectClose ||
				name == $markedSectOpen ||
				name == $notationDecl ||
				name == $paramRef ||
				name == $procInst;

			if (state == $start)
				isValid = isValid || name == $xmlDecl;

			this[$state] = $externalDTD;

			if (isValid)
				this[name](match);
			else {
				const err = new HSE(msg.illegalInDTDE, match);

				if (strict)
					throw err;
				else
					return this.emit('wat', err);
			}
		}

		if (!target) {

			const onlyDoc =
				name == $dtdSimple ||
				name == $dtdInlineOpen ||
				name == $tagOpen ||
				name == $tagEmpty;

			if (onlyDoc) {
				this[$target] = 'Document';
				this[$node]   = this[$doc] = new Document(this[$opts]);

				this[name](match);
			}
		}

		if (target == 'Document') {

			let isValid = false;

			if (state == $start) {
				isValid =
					name == $comment ||
					name == $dtdInlineOpen ||
					name == $dtdSimple ||
					name == $procInst ||
					name == $tagEmpty ||
					name == $tagOpen ||
					name == $xmlDecl;
			} else if (state == $afterXMLDecl) {
				isValid =
					name == $comment ||
					name == $dtdInlineOpen ||
					name == $dtdSimple ||
					name == $procInst ||
					name == $tagEmpty ||
					name == $tagOpen;
			} else if (state == $internalDTD) {
				isValid =
					name == $attListDecl ||
					name == $comment ||
					name == $dtdInlineClose ||
					name == $elemDecl ||
					name == $entityDecl ||
					name == $notationDecl ||
					name == $paramRef ||
					name == $procInst;
			} else if (state == $afterDTD) {
				isValid =
					name == $comment ||
					name == $procInst ||
					name == $tagEmpty ||
					name == $tagOpen;
			} else if (state == $afterRoot) {
				isValid = 
					name == $comment ||
					name == $procInst;
			}

			if (isValid)
				this[name](match);
			else {
				const err = new HSE(msg.illegalOrMisplacedInDoc, match);

				if (strict)
					throw err;
				else
					return this.emit('wat', err);
			}
		}

		this[name](match);
	}

	[$attListDecl](str) {
		const pattern = this.strict ? attListDecl_strict : attListDecl_sloppy;

		const [ , n, body ] = str.match(pattern) || [];

		if (!n) {
			const err = new HSE(msg.malformedAttList, str);

			if (this.strict)
				throw err;
			else
				return this.emit('wat', err);
		}

		const [ , namespace, name ] = n.match(nsPattern);

		let attList;

		try {
			attList = new AttListDeclaration({ namespace, name });
			this[$node].children.push(attList);
		} catch (err) {
			if (this.strict)
				throw err;
			else
				return this.emit('wat', err);
		}

		if (body) {

			attDefPattern.lastIndex = 0;

			let [ m, n, t1, t2, m, d1, d2, v1, v2 ] =
				attDefPattern.exec(body) || [];

			if (!n) {
				const err = new HSE(msg.malformedAttList, str, body);
				
				if (this.strict)
					throw err;
				else
					return this.emit('wat', err);
			}

			while (m) {

				const [ , namespace, name ] = n.match(nsPattern);
				const type = t1 || t2;
				const members = m.split(/|/).map(m => m.trim());
				const defaultType = d1 || d2;
				const defaultValue = v1 || v2;

				try {

					const attDef = new AttributeDefinition({
						namespace, name, type, members,
						defaultType, defaultValue
					});

					attList.defs.push(attDef);

				} catch (err) {
					if (this.strict)
						throw err;
					else
						this.emit('wat', err);
				}

				body = body.slice(m.length);

				[ m, n, t1, t2, m, d1, d2, v1, v2 ] =
					attDefPattern.exec(body) || [];
			}

			if (body && !isValid.whitespace(body)) {
				const err = new HSE(msg.malformedAttList, str, body);
				
				if (this.strict)
					throw err;
				else
					this.emit('wat', err);
			}
		}
	}

	[$cdata](str) {
		const [ , content ] = str.match(cdataPattern) || [];

		if (this.normalize)
			content = content::norm();

		try {
			const cdata = new CDATASection({ content });
			this[$node].children.push(cdata);
		} catch (err) {
			if (this.strict)
				throw err;
			else
				this.emit('wat', err);
		}
	}

	[$comment](str) {
		const [ , content ] = str.match(commentPattern) || [];

		if (this.normalize)
			content = content::norm();

		const comment = new Comment(content);

		if (comment.content != content) {
			let index;

			for (index in content) {
				if (comment.content[index] != comment[index]) break;
			}

			const err = new HSE(msg.invalidComment, content, index);

			if (this.strict)
				throw err;
			else
				this.emit('warning', err);
		}

		this[$node].children.push(comment);
	}

	[$dtdInlineOpen](str) {
		this[$dtdSimple](str);

		const dtd = this[$node].children.last;

		if (dtd instanceof Doctype) {
			this[$state] = $internalDTD;
			this[$node]  = dtd;
		}
	}

	[$dtdInlineClose](str) {
		if (this[$node] instanceof Doctype) {
			this[$state] = $afterDTD;
			this[$node]  = this[$node].parent;
		} else {
			const err = new HSE(msg.whatIsThisEven, str);

			if (this.strict)
				throw err
			else
				this.emit('wat', err);
		}
	}

	[$dtdSimple](str) {
		this[$state] = $afterDTD;

		const pattern = this.strict ? dtdOpen_strict : dtdOpen_sloppy;

		const [ , name, s1, s2, p1, p2, s3, s4 ] = str.match(pattern) || [];

		const systemID = s1 || s2 || s3 || s4;

		const publicID = p1 || p2;

		try {
			const dtd = new Doctype({ name, systemID, publicID });
			this[$node].children.push(dtd);
		} catch (err) {
			if (this.strict)
				throw err;
			else
				this.emit('wat', err);
		}
	}

	[$elemDecl](str) {
		const pattern = this.strict ? elemDecl_strict : elemDecl_sloppy;

		const [ , n, t, pc, pcm, m, quantifier ] = str.match(pattern) || [];

		const [ , namespace, name ] = n.match(nsPattern);

		let type = t || (pc && 'MIXED');

		let members = [];

		if (pcm) {
			if (qualifier != '*') {
				const index = qualifier ? str.lastIndexOf(qualifier) : 0;
				const err = new HSE(msg.mixedEnumNotAsterisk, str, index);

				if (this.strict) {
					throw err;
				} else {
					qualifier = '*';
					this.emit('warning', err);
				}
			}

			pcm = pcm.split(/\s*\|\s*/g).slice(1);

			members = pcm.map(n => {
				const [ , namespace, name ] = n.match(nsPattern);

				try {
					return new ChildElementName({ namespace, name });
				} catch (err) {
					if (this.strict)
						throw err;
					else
						this.emit('wat', err);
				}

			}).filter(n => n);

		} else if (!pcm && pc) {
			if (qualifier) {
				const index = str.lastIndexOf(qualifier);
				const err = new HSE(msg.pcdataQualified, str, qualifier);

				if (this.strict) {
					throw err;
				} else {
					qualifier = '';
					this.emit('warning', err);
				}
			}
		} else if (m) {
			try {
				members = toContentSpecList(m);
			} catch (err) {
				if (this.strict) {
					throw err;
				} else {
					return this.emit('wat', err);
				}
			}
		}

		type = type || members.type;

		if (type != members.type) {
			const index = str.indexOf('(');
			const err = new HSE(msg.incompatibleContentSpecType, str, index);

			if (this.strict)
				throw err;
			else
				this.emit('wat', err);
		}

		try {
			const elemDecl = new ElementDeclaration({
				namespace, name, quantifier, type
			});

			for (const member of members)
				elemDecl.contentSpec.push(member);

			this[$node].children.push(elemDecl);
		} catch (err) {
			if (this.strict)
				throw err;
			else
				this.emit('wat', err);
		}
	}

	[$entityDecl](str) {
		const pattern = this.strict ? entityDecl_strict : entityDecl_sloppy;

		const [ , isParameter, name, v1, v2, s1, s2, p1, p2, s3, s4, ndata ] =
			str.match(pattern) || [];

		if (!name) {
			const err = new HSE(msg.malformedEntityDecl, str);

			if (this.strict)
				throw err
			else
				return this.emit('wat', err);
		}

		const systemID = s1 || s2 || s3 || s4;
		const publicID = p1 || p2;

		try {
			const entityDecl = new EntityDeclaration({
				isParameter, name, ndata, publicID, systemID, value
			});

			this[$node].children.push(entityDecl);

		} catch (err) {
			if (this.strict)
				throw err;
			else
				this.emit('wat', err);
		}
	}

	[$markedSectClose](str) {
		if (this[$node] instanceof ConditionalSection) {
			this[$node] = this[$node].parent;
		} else {
			const err = new HSE(msg.whatIsThisEven, str);

			if (this.strict)
				throw err
			else
				this.emit('wat', err);
		}
	}

	[$markedSectOpen](str) {

		const [ , keyword ] = markedSectPattern || [];

		try {
			const markedSect = new ConditionalSection(keyword);

			this[$node].children.push(markedSect);

			this[$node] = markedSect;
		} catch (err) {
			if (this.strict)
				throw err;
			else
				this.emit('wat', err);
		}
	}

	[$notationDecl](str) {

		const pattern = this.strict ? notation_strict : notation_sloppy;

		const [ , n, s1, s2, p1, p2, s3, s4 ] = str.match(pattern) || [];

		if (!n) {
			const err = new HSE(msg.malformedNotationDecl, str);

			if (this.strict)
				throw err;
			else
				return this.emit('wat', err);
		}

		const [ , namespace, name ] = n.match(nsPattern);

		const systemID = s1 || s2 || s3 || s4;
		const publicID = p1 || p2;

		try {
			const notationDecl = new NotationDeclatation({
				name, namespace, publicID, systemID
			});

			this[$node].children.push(notationDecl);
		} catch (err) {
			if (this.strict)
				throw err;
			else
				this.emit('wat', err);
		}
	}

	[$paramRef](str) {
		try {
			const pr = new ParameterReference(str);
			this[$node].children.push(pr);
		} catch (err) {
			if (this.strict)
				throw err;
			else
				this.emit('wat', err);
		}
	}

	[$procInst](str) {

		const pattern = this.strict ? pi_strict : pi_sloppy;

		const [ , target, instruction ] = str.match(pattern) || [];

		if (!target) {
			const err = new HSE(msg.malformedPI, str);

			if (this.strict)
				throw err;
			else
				return this.emit('wat', err);
		}

		try {
			const pi = new ProcessingInstruction({ target, instruction });
			this[$node].children.push(pi);
		} catch (err) {
			if (this.strict)
				throw err;
			else
				this.emit('wat', err);
		}
	}

	[$tagClose](str) {
		const pattern = this.strict ? tagClose_strict : tagClose_sloppy;

		const [ , n ] = str.match(pattern) || [];

		if (!n) {
			// A very odd case. The permissive pattern is very permissive, so
			// it seems unrecoverable regardless of mode. One last thing to try,
			// though...

			const err = new HSE(msg.malformedClosingTag, str);

			if (this.strict) {
				throw err;
			} else {
				const expected = this[$node].name;

				if (!expected) return this.emit('wat', err);

				if (~str.indexOf(expected)) {
					this[$node] = this[$node].parent;

					if (!this[$node].parent)
						this[$state] = $afterRoot;

					this.emit('wat', err);
				}

				throw err;
			}
		}

		if (this[$node].fullName == n) {
			this[$node] = this[$node].parent;

			if (!this[$node].parent)
				this[$state] = $afterRoot;

		} else if (this[$node] instanceof Element) {
			const err = new HSE(msg.unmatchedTag(this[$node].fullName), str);

			if (this.strict) throw err;

			// In the event of a closing tag that doesn’t balance in sloppy mode
			// we can try to recover if it appears that intermediate closing
			// tags were accidentally omitted. This is a gambit: while that’s
			// a *possible* explanation, we (a) don’t know for sure and (b)
			// don’t know where the end tags really should have been positioned.

			// This is the approach taken by browsers when facing malformed HTML
			// though, so I think that it’s probably the recovery type that
			// people are accustomed to.

			// <a><b>text<c></a> would therefore become <a><b>text<c/></b></a>.

			const realNode = this[$node].parents.find(p => p.fullName == n);

			if (realNode) {
				this[$node] = realNode;
				this.emit('wat', err);
			} else {
				throw err;
			}
		} else {
			const err = new HSE(msg.unmatchableTag(n), str);

			if (this.strict)
				throw err;
			else
				this.emit('wat', err);
		}
	}

	[$tagEmpty](str) {
		const orig = str;

		if (this.strict)
			str = str.replace(/\/>$/, '>');
		else
			str = str.replace(/\/\s*>$/, '>');

		if (str == orig) {
			const err = new HSE(msg.malformedEmptyTag, str);

			if (this.strict)
				throw err;
			else
				return this.emit('wat', err);
		}

		const origNode = this[$node];
		let outerErr;

		try {
			this[$tagOpen](str);
		} catch (err) {
			outerErr = err;
		} finally {
			if (this[$node] != origNode) {
				this[$node] = this[$node].parent;

				if (!this[$node].parent)
					this[$state] = $afterRoot;
			}

			if (outerErr) throw outerErr;
		}
	}

	[$tagOpen](str) {
		this[$state] = $inRoot;

		const pattern = this.strict ? tagOpen_strict : tagOpen_sloppy;

		let [ , n, body ] = str.match(pattern) || [];

		if (!n) {
			const err = new HSE(msg.malformedOpenTag, str);

			if (this.strict)
				throw err;
			else
				return this.emit('wat', err);
		}

		const [ , namespace, name ] = n.match(nsPattern);

		let elem;

		try {
			elem = new Element({ namespace, name });

			this[$node].children.push(elem);

			this[$node] = elem;

		} catch (err) {
			if (this.strict)
				throw err;
			else
				return this.emit('wat', err);
		}

		if (body && !strict) {

			attr_sloppy.lastIndex = 0;

			let [ match, k, val1, val2, val3 ] = attr_sloppy.exec(str) || [];

			while (k) {

				const value = val1 || val2 || val3 || '';

				const [ , namespace, key ] = key.match(nsPattern);

				try {
					elem.setAttribute({ namespace, key, value });
				} catch (err) {
					this.emit('wat', err);
				}

				if (attr.value != value) {
					const err = new HSE(msg.illegalAttrChar, str, match);
					this.emit('warning', err);
				}

				body = body.slice(match.length);

				[ match, k, val1, val2, val3 ] = attr_sloppy.exec(str) || [];
			}

		} else if (body) {

			let [ match, k, val1, val2 ] = body.match(attr_strict) || [];

			while (match) {
				const value = val1 || val2;

				const [ , namespace, key ] = key.match(nsPattern);

				const attr = new Attribute({ namespace, key, value });

				if (attr.value != value)
					throw new HSE(msg.illegalAttrChar, str, match);

				elem.attributes.push(attr);

				body = body.slice(match.length);

				[ match, key, val1, val2 ] = body.match(attr_strict) || [];
			}

			if (body && !isValid.whitespace(body))
				throw new HSE(msg.malformedOpenTag, str, body);
		}
	}

	[$text](content) {
		if (this.normalize)
			content = content::norm();

		let before = content;
		let after;

		const prev = this[$node].children.last;

		if (prev && prev instanceof Text) {
			// In theory, we could be dealing with a sequence where first text
			// was matched using a DTD closer etc, but it got recognized as text
			// after, and then there was additional text. Here we can stitch
			// them back together. It’s slightly problematic since it could mean
			// losing some whitespace in the text node, but it’s probably very
			// rare that this will ever occur.

			before       = prev.content + content;
			prev.content = before;
			after        = prev.content;
		} else {
			const text = new Text({ content });

			after = text.content;

			this[$node].children.push(text);
		}

		if (before != after) {

			let index;

			for (index in before) {
				if (before[index] != after[index]) break;
			}

			const err = new HSE(msg.illegalTextChars, content, index);

			if (this.strict)
				throw err;
			else
				this.emit('warning', err);
		}
	}

	[$xmlDecl](str) {
		// At xml declaration, it’s possible that we still have an ambiguous
		// target. This may be cleared up if "standalone" exists; that means
		// this is a Document. But it also may remain ambiguous, in which case
		// we save the results to $opts for instantiating the correct type
		// later.

		let v1, v2, e1, e2, s1, s2;
		let version, encoding, standalone;

		if (this.strict) {
			[ , v1, v2, e1, e2, s1, s2 ] = str.match(xmlDecl_strict) || [];

			version    = v1 || v2;
			encoding   = e1 || e2;
			standalone = s1 || s2;

		} else {

			attr_sloppy.lastIndex = 0;

			let [ , key, val1, val2, val3 ] = attr_sloppy.exec(str) || [];

			while (key) {
				switch (key.toLowerCase()) {
					case 'version':
						version = val1 || val2 || val3;

						if (version) version = parseFloat(version);

						if (version && ((version < 1) || (version >= 2))) {
							version = null;
							const err = new HSE(msg.xmlDeclBadVers, str, key);
							this.emit('warning', err);
						}

						break;
					case 'encoding':
						encoding = val1 || val2 || val3;

						if (encoding && !isValid.encoding(encoding)) {
							encoding = null;
							const err = new HSE(msg.xmlDeclBadEnc, str, key);
							this.emit('warning', err);
						}

						break;
					case 'standalone':
						standalone = val1 || val2 || val3;

						if (standalone) {
							standalone = standalone.trim.toLowerCase();

							if (standalone != 'yes' && standalone != 'no') {
								standalone = null;
								const err = new HSE(msg.xmlDeclBadSD, str, key);
								this.emit('warning', err);
							}
						}

						break;
				}

				[ , key, val1, val2, val3 ] = attr_sloppy.exec(str) || [];
			}

			const [ strictMatch ] = str.match(xmlDecl_strict) || [];

			if (!strictMatch)
				this.emit('warning', new HSE(msg.malformedXMLDecl, str));
		}

		if (standalone && !this.target)
			this[$target] = 'Document';
		else if (encoding && !version)
			this[$target] = 'DoctypeExternal';

		if ((this.target == 'Document') && !version) {
			const err = new HSE(msg.xmlDeclBadVers, str);

			if (this.strict)
				throw err;
			else
				this.emit('warning', err);
		} else if (this.target == 'DoctypeVersion' && standalone) {
			const err = new HSE(msg.malformedTextDecl, str);

			if (this.strict)
				throw err;
			else
				this.emit('warning', err);
		}

		try {
			if (this.target == 'Document')
				this[$node] = this[$doc] =
					new Document({ version, encoding, standalone });
			else if (this.target == 'DoctypeExternal')
				this[$node] = this[$doc] =
					new DoctypeExternal({ version, encoding });
			else
				this[$opts] = { version, encoding };
		} catch (err) {
			if (this.strict)
				throw err;
			else
				this.emit('wat', err);
		}
	}
}

// IMPORTS /////////////////////////////////////////////////////////////////////

import { Writable } from 'stream';

import { HardcoreSyntaxError as HSE, HardcoreTypeError as HTE } from 'errors';

import * as isValid from 'string-validation';

import msg from 'msg';

import {
	AttListDeclaration,
	Attribute,
	AttributeDefinition,
	CDATASection,
	ChildElementGroup,
	ChildElementName,
	Comment,
	ConditionalSection,
	Doctype,
	DoctypeExternal,
	Document,
	DocumentFragment,
	Element,
	ElementDeclaration,
	EntityDeclaration,
	HTMLAttribute,
	HTMLElement,
	HTMLElementASC,
	HTMLElementPre,
	NotationDeclaration,
	ParameterReference,
	ProcessingInstruction,
	Text
} from 'nodes';

// UNIT TYPE SYMBOLS ///////////////////////////////////////////////////////////

const $attListDecl     = Symbol();
const $cdata           = Symbol();
const $comment         = Symbol();
const $dtdInlineClose  = Symbol();
const $dtdInlineOpen   = Symbol();
const $dtdSimple       = Symbol();
const $elemDecl        = Symbol();
const $entityDecl      = Symbol();
const $markedSectClose = Symbol();
const $markedSectOpen  = Symbol();
const $nodeStart       = Symbol();
const $notationDecl    = Symbol();
const $paramRef        = Symbol();
const $procInst        = Symbol();
const $tagClose        = Symbol();
const $tagEmpty        = Symbol();
const $tagOpen         = Symbol();
const $text            = Symbol();
const $whitespace      = Symbol();
const $xmlDecl         = Symbol();

// PATTERNS ////////////////////////////////////////////////////////////////////

// The matching patterns used at the ‘dissect’ stage are always permissive. We
// want to make the most minimal unambiguous match that tells us where a unit
// begins and ends and what it looks like it *should* be. Therefore whitespace,
// for example, is matched with \s instead of [\n\r\t ]. By always divvying up
// with permissive patterns, strict mode benefits by being able to tell a more
// accurate story about what exactly went wrong.

// Patterns are checked in order -- the sequence often matters. If a pattern has
// a beginning and ending, and the beginning matches but the end does not, the
// dissecter considers us to have entered ambiguous territory -- unless the
// terminal flag is true, in which case it will proceed down the list.

// The final stretch of the list includes patterns that specifically match
// erroneous sequences. Some of these will be forgiven in permissive mode, and
// in strict mode these once again assist us in reporting meaningful errors. 

const patterns = [
	{
		name: $paramRef,
		pattern: /%[^;\s]+;/,
		ambiguous: true
	},
	{
		name: $dtdInlineClose,
		pattern: /^\]\s*>/
	},
	{
		name: $markedSectClose,
		pattern: /^\]\]>/
	},
	{
		name: $text,
		pattern: /^[^<]*[^<\s]+[^<]*/,
		ambiguous: true
	},
	{
		name: $whitespace,
		pattern: /^\s+/,
		ambiguous: true
	},
	{
		name: $xmlDecl,
		pattern: /^<\?xml\s[\S\s]*?>/
	},
	{
		name: $procInst,
		pattern: /^<\?[\S\s]*?\?>/
	},
	{
		name: $comment,
		pattern: /^<!--[\S\s]*?-->/
	},
	{
		name: $cdata,
		pattern: /^<!\[CDATA\[[\S\s]*?\]\]>/
	},
	{
		name: $markedSectOpen,
		pattern: /^<!\[(?!CDATA)[^\[]*?\[/
	},
	{
		name: $dtdSimple,
		pattern: /^<!DOCTYPE\s([^>'"\[]+|"[^"]*"|'[^']*')*?>/
	},
	{
		name: $dtdInlineOpen,
		pattern: /^<!DOCTYPE\s([^>'"\[\]]+|"[^"]*"|'[^']*')*?\[/
	},
	{
		name: $elemDecl,
		pattern: /^<!ELEMENT[\S\s]*?>/
	},
	{
		name: $attListDecl,
		pattern: /^<!ATTLIST([^>'"\[\]]+|"[^"]*"|'[^']*')*?>/
	},
	{
		name: $entityDecl,
		pattern: /^<!ENTITY([^>'"\[\]]+|"[^"]*"|'[^']*')*?>/
	},
	{
		name: $notationDecl,
		pattern: /^<!NOTATION([^>'"\[\]]+|"[^"]*"|'[^']*')*?>/
	},
	{
		name: $tagClose,
		pattern: /^<\s*\/([^>'"]+|"[^"]*"|'[^']*')*>/
	},
	{
		name: $tagEmpty,
		pattern: /^<(?!\s*[\?\!\/])([^>'"]+|"[^"]*"|'[^']*')*\/\s*>/
	},
	{
		name: $tagOpen,
		pattern: /^<(?!\s*[\?\!\/])([^>'"]+|"[^"]*"|'[^']*')*>/
	},
	{
		name: $nodeStart,
		pattern: /^</,
		ambiguous: true
	}
];

const attDefPattern =
	/^[\n\r\t ]+([^\n\r\t ]+)[\n\r\t ]+(?:(CDATA|ID(?:REFS?)?|ENTIT(?:Y|IES)|NMTOKENS?)|(?:(NOTATION)[\n\r\t ]+)?\(([^\)]+)\))[\n\r\t ]+(?:(#REQUIRED|#IMPLIED)|(?:(?:(#FIXED)[\n\r\t ]+)?(?:"([^"]*)"|'([^']*)')))/;

const attListDecl_strict =
	/^<!ATTLIST[\n\r\t ]+([^\n\r\t >]+)(.*?)[\n\r\t ]*>$/;

const attListDecl_sloppy =
	/^<!ATTLIST\s+(\S+)(.*?)\s*>$/;

const attr_strict =
	/^[\n\r\t ]*([^\n\r\t =]+)[\n\r\t ]*=[\n\r\t ]*(?:"([^<"]*)"|'([^<']*)')/;

const attr_sloppy =
	/([^\s=\/>]+)(?:\s*=\s*"([^"]+)"|\s*=\s*'([^']+)'|\s*=\s*([^\s='"\/>]*)|)/g;

const cdataPattern =
	/^<!\[CDATA\[(.*)\]\]>$/;

const commentPattern =
	/^<!--(.*)-->$/;

const dtdOpen_strict =
	/^<!DOCTYPE[\n\r\t ]+([^\n\r\t ]+)(?:[\n\r\t ]+SYSTEM[\n\r\t ]+(?:"([^"]*)"|'([^']*)')|PUBLIC[\n\r\t ]+(?:"([^"]*)"|'([^']*)')[\n\r\t ]+(?:"([^"]*)"|'([^']*)'))?[\n\r\t ]*[\[>]$/;

const dtdOpen_sloppy =
	/^<!DOCTYPE\s+(\S+)(?:\s+SYSTEM\s+(?:"([^"]*)"|'([^']*)')|PUBLIC\s+(?:"([^"]*)"|'([^']*)')\s+(?:"([^"]*)"|'([^']*)'))?\s*[\[>]$/;

const elemDecl_strict =
	/^<!ELEMENT[\n\r\t ]+([^\n\r\t ]+)[\n\r\t ]+(?:(EMPTY|ANY)|\((?:(?:[\n\r\t ]*(#PCDATA))((?:[\n\r\t ]*\|[\n\r\t ]*[^\n\r\t ]+)*)[\n\r\t ]*|([^\>]+))\)([\*\+\?])?)[\n\r\t ]*>/;

const elemDecl_sloppy =
	/^<!ELEMENT\s+(\S+)\s+(?:(EMPTY|ANY)|\((?:(?:\s*(#PCDATA))((?:\s*\|\s*\S+)*)\s*|([^\>]+))\)([\*\+\?])?)\s*>/;

const entityDecl_strict =
	/^<!ENTITY[\n\r\t ]+(%[\n\r\t ]+)?(\S+)[\n\r\t ]+(?:"([^"]*)"|'([^']*)'|(?:SYSTEM[\n\r\t ]+"([^"]*)"|'([^']*)'|PUBLIC[\n\r\t ]+"([^"]*)"|'([^']*)'[\n\r\t ]+"([^"]*)"|'([^']*)')(?:[\n\r\t ]+NDATA[\n\r\t ]+(\S+))?)[\n\r\t ]*>$/;

const entityDecl_sloppy =
	/^<!ENTITY\s+(%\s+)?(\S+)\s+(?:"([^"]*)"|'([^']*)'|(?:SYSTEM\s+"([^"]*)"|'([^']*)'|PUBLIC\s+"([^"]*)"|'([^']*)'\s+"([^"]*)"|'([^']*)')(?:\s+NDATA\s+(\S+))?)\s*>$/

const markedSectPattern =
	/^<!\[([\[]+)\[$/;

const notation_strict = 
	/^<!NOTATION[\n\r\t ]+([^\n\r\t ]+)(?:SYSTEM[\n\r\t ]+(?:"([^"]*)"|'([^']*)')|PUBLIC[\n\r\t ]+(?:"([^"]*)"|'([^']*)')(?:[\n\r\t ]+(?:"([^"]*)"|'([^']*)'))?)?[\n\r\t ]*>$/;

const notation_sloppy =
	/^<!NOTATION\s+(\S+)(?:SYSTEM\s+(?:"([^"]*)"|'([^']*)')|PUBLIC\s+(?:"([^"]*)"|'([^']*)')(?:\s+(?:"([^"]*)"|'([^']*)'))?)?\s*>$/;

const nsPattern =
	/^(?:(.+?):)?(.+)$/;

const pi_strict =
	/^<\?(\S+)[\n\r\t ]+(.*)\?>$/;

const pi_sloppy =
	/^<\?\s*(\S+)\s+(.*)\?>$/;

const tagClose_strict =
	/^<\/([^\n\r\t ]+)[\n\r\t ]*>$/;

const tagClose_sloppy =
	/^<\s*\/\s*([^>\s]+)[^>]*>$/;

const tagOpen_strict =
	/^<([^\n\r\t ]+)(?:[\n\r\t ]+([^\n\r\t ][\S\s]*?))?[\n\r\t ]*>$/;

const tagOpen_sloppy =
	/^<\s*(\S+)\s*([^>]*?)?\s*>$/;

const xmlDecl_strict =
	/^<\?xml[\n\r\t ]+version[\n\r\t ]*=[\n\r\t ]*(?:"(1\.\d+)"|'(1\.\d+)')(?:[\n\r\t ]+encoding[\n\r\t ]*=[\n\r\t ]*(?:"([A-Za-z][A-Za-z\d\._\-]*)"|'([A-Za-z][A-Za-z\d\._\-]*)'))?(?:[\n\r\t ]+standalone[\n\r\t ]*=[\n\r\t ]*(?:"(yes|no)"|'(yes|no)'))?[\n\r\t ]*\?>$/;

// HTML DATA ///////////////////////////////////////////////////////////////////

const htmlHeadElements = new Set([
	'base', 'link', 'meta', 'noscript', 'script', 'style', 'template', 'title'
]);

const htmlPClosers = new Set([
	'address', 'article', 'aside', 'blockquote', 'div', 'dl', 'fieldset',
	'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'header', 'hgroup',
	'hr', 'main', 'nav', 'ol', 'p', 'pre', 'section', 'table', 'ul'
]);

// UTIL ////////////////////////////////////////////////////////////////////////

const norm = function() {
	return this.trim().replace(/\s+/g, ' ');
};

const normTarget = val => {
	if (val === undefined || val === null) return;

	if (val instanceof Object)
		val = val.constructor.name;

	if (typeof val === 'string' || val instanceof String) {
		const norm = val.toUpperCase().replace(/\s/g, '');

		if (norm == 'DOCTYPEEXTERNAL')
			return 'DoctypeExternal';
		if (norm == 'DOCUMENT')
			return 'Document';
		if (norm == 'DOCUMENTFRAGMENT')
			return 'DocumentFragment';
		if (norm == 'ELEMENT')
			return 'Element';
	}

	throw new HTE(msg.invalidParseTarget, val);
};

const dissect = (remainder, isTerminal, units=[]) => {
	
	// Here, we take an incoming string and break it apart into discreet
	// components for further processing, where they will be interpretted to
	// build document nodes. After extracting as many complete units as possible
	// any remaining string is the ‘remainder’. The remainder is not always
	// ‘partial’ -- it may in fact be a complete unit except that there is still
	// ambiguity because the next (unknown) character could still change its
	// meaning. However, when `isTerminal` is true there is never ambiguity
	// because it says ‘this is the final string.’ 

	for (const { name, pattern, ambiguous } of patterns) {
		const [ match ] = remainder.match(pattern) || [];

		if (match) {

			if (name == $nodeStart && isTerminal)
				return { remainder, units };

			const no = (remainder == match) || (name == $nodeStart);

			if (!isTerminal && ambiguous && no)
				return { remainder, units };

			remainder = remainder.slice(match.length);

			units.push({ name, match });

			if (remainder)
				return dissect(remainder, isTerminal, units);
			else
				return { remainder, units };
		}
	}

	// I think this is actually unreachable, but just to be safe:

	return { remainder, units };
};

const toContentSpecList = (str, arr=[]) => {
	const orig = str;

	// This whole bit ought to be refactored. Not exactly a paragon of elegance.

	let match, n, quantifier, sep = 'init';

	while (str) {

		if (!sep)
			throw new HSE(msg.malformedContentSpec, orig, str);

		[ match, n, quantifier='', sep ] =
			str.match(/^\s*([^\s,|\()]+?)([\?\*\+])?\s*([,|]|$)/) || [];

		if (n) {
			const [ , namespace, name ] = n.match(nsPattern);

			const child = new ChildElementName({ namespace, name, quantifier });

			arr.push(child);

			const prevType = arr.type;

			arr.type = sep == ',' ? 'SEQUENCE' : arr.type || 'CHOICE';

			if (prevType && prevType != arr.type)
				throw new HSE(msg.malformedContentSpecSep, orig, str);

			str = str.slice(match.length);

		} else if (str.match(/^\s*\(/)) {

			let count = 0;
			let index = -1;

			for (const char of str) {
				index++;

				if (char == '(') {
					count++;
				} else if (char == ')') {
					count--;
					if (!count) break;
				}
			}

			if (!count) {

				let segment = str.slice(0, index);

				str = str.slice(segment.length);

				segment = segment.replace(/^\s*\(/, '');

				[ match, quantifier='', sep ] =
					str.match(/^\)([\+\?\*])?([,\|])\s*/) || [];

				str = str.slice(match.length);

				const prevType = arr.type;

				arr.type = sep == ',' ? 'SEQUENCE' : arr.type || 'CHOICE';

				if (prevType && prevType != arr.type)
					throw new HSE(msg.malformedContentSpecSep, orig, str);

				const child = new ChildElementGroup({ quantifier });

				arr.push(child);

				toContentSpecList(segment, child);

			} else {
				throw new HSE(msg.malformedContentSpecParen, orig, str);
			}

		} else {
			throw new HSE(msg.malformedContentSpec, orig, str);
		}
	}

	return arr;
};

// PARSER STATE SYMBOLS ////////////////////////////////////////////////////////

// Initial state.
const $start = Symbol();

// We’ve seen an xml or text declaration, or we have seen any other legal node. 
const $afterXMLDecl = Symbol();

// We are in an external DTD -- this is a final state.
const $externalDTD = Symbol();

// We are in the bracketed interior of an internal DTD.
const $internalDTD = Symbol();

// We are in a document, after a DTD but before the root.
const $afterDTD = Symbol();

// Special initial state for target == Element.
const $beforeRoot = Symbol();

// We are somewhere within the element tree of a document.
const $inRoot = Symbol();

// The root element of a document has resolved -- this is a final state.
const $afterRoot = Symbol();

// PARSER SYMBOLS //////////////////////////////////////////////////////////////

const $buffer      = Symbol();
const $doc         = Symbol();
const $html        = Symbol();
const $ignoreWhite = Symbol();
const $node        = Symbol();
const $normalize   = Symbol();
const $opts        = Symbol();
const $processUnit = Symbol();
const $state       = Symbol();
const $strict      = Symbol();
const $target      = Symbol();

// PARSER //////////////////////////////////////////////////////////////////////

export default class Parser extends Writable {
	constructor({ strict, ignoreWhite=true, html, normalize, target }={}) {
		super({ decodeStrings: false });

		if (strict === undefined)
			strict = !html;

		if (normalize === undefined)
			normalize = html;

		if (html)
			ignoreWhite = true;

		this[$html]        = !!html;
		this[$ignoreWhite] = !!ignoreWhite;
		this[$normalize]   = !!normalize;
		this[$strict]      = !!strict;
		this[$target]      = normTarget(target);

		if (this.target === 'DocumentFragment') {
			this[$state] = $inRoot;
			this[$doc]   = new DocumentFragment();
			this[$node]  = this[$doc];
		} else if (this.target === 'Element') {
			this[$state] = $beforeRoot;
		} else {
			this[$state] = $start;
			this[$opts] = { children: [] };
		}

		this[$buffer] = '';

		this.on('finish', () => {

			if (this.html && !this[$buffer] && !this[$doc])
				this[$buffer] =
					'<!DOCTYPE html><html><head></head><body></body></html>';

			if (this[$buffer]) {
				const { remainder, units } = dissect(this[$buffer], true);

				try {
					for (const unit of units) this[$processUnit](unit);
				} catch (err) {
					return this.emit('error', err);
				}
				if (remainder) {
					const err = new HSE(msg.malformedRemainder, remainder);

					if (this.strict)
						return this.emit('error', err);
					else
						this.emit('wat', err);
				}
			}

			const doc = this[$doc];

			if (doc) {

				if (this.html && (doc instanceof Document) && !doc.doctype) {
					doc.doctype = new Doctype({ name: 'html' });
				}

				const isDoc = this[$node] instanceof Document;

				if (this.html && isDoc && !this[$node].root) {
					const html = new HTMLElement({ name: 'html' });
					this[$node].children.push(html);
					this[$node] = html;
				}

				if (this.html && this[$node].name == 'html') {
					if (!this[$node].children.some(e => e.name == 'head')) {
						const head = new HTMLElement({ name: 'head' });
						this[$node].children.push(head);
					}
					if (!this[$node].children.some(e => e.name == 'body')) {
						const body = new HTMLElement({ name: 'body' });
						this[$node].children.push(body);
					}
				}

				if (this.html && this[$node].name == 'head') {
					const body = new HTMLElement({ name: 'body' });

					this[$node] = this[$node].parent;
					this[$node].children.push(body);
				}

				const permittedOmission = this.html && (
					this[$node].name == 'html' ||
					this[$node].name == 'body'
				);

				if (permittedOmission) this[$node] = this[$doc];

				if ((doc == this[$node]) && doc.isValid()) {
					return this.emit('result', doc);
				} else {
					const err = new HSE(msg.incompleteTarget(this.target));
				
					if (strict) {
						return this.emit('error', err);
					} else {
						this.emit('wat', err);
						this.emit('result', doc);
					}
				}
			} else {
				this.emit('error', new HSE(msg.completeGarbage));
			}
		});
	}

	get html() {
		return this[$html];
	}

	get ignoreWhite() {
		return this[$ignoreWhite];
	}

	get normalize() {
		return this[$normalize];
	}

	get strict() {
		return this[$strict];
	}

	get target() {
		return this[$target];
	}

	_write(chunk, enc, cb) {
		chunk = this[$buffer] + chunk.toString();

		const { remainder, units } = dissect(chunk);

		try {

			for (const unit of units) this[$processUnit](unit);

			this[$buffer] = remainder;

			cb();

		} catch (err) {
			this.emit('error', err);
		}
	}

	[$processUnit]({ match, name }) {
		const state  = this[$state];
		const strict = this.strict;
		const target = this.target;

		if (name == $whitespace && (this.ignoreWhite || (state != $inRoot)))
			return;
		else if (name == $whitespace)
			name = $text;

		if (state == $start)
			this[$state] = $afterXMLDecl;

		if (target == 'Element') {

			if (state == $afterRoot) {
				const err = new HSE(msg.multipleElements, match);

				if (strict) {
					throw err;
				} else {
					this[$state] = $inRoot;
					return this.emit('wat', err);
				}
			}

			if (state == $beforeRoot && name != $tagOpen && name != $tagEmpty) {
				const err = new HSE(msg.notElement, match);

				if (strict)
					throw err;
				else
					return this.emit('wat', err);
			}
		}

		const shouldBeElemContent =
			target == 'Element' ||
			target == 'DocumentFragment' ||
			state == $inRoot;

		if (shouldBeElemContent) {
			if (name == $paramRef ||
				name == $dtdInlineClose ||
				name == $markedSectClose) {
					name = $text;
				}

			const isElemContent =
				name == $cdata ||
				name == $comment ||
				name == $dtdInlineClose ||
				(name == $markedSectClose && !this.strict) ||
				name == $paramRef ||
				name == $procInst ||
				name == $tagClose ||
				name == $tagEmpty ||
				name == $tagOpen ||
				name == $text;

			if (isElemContent)
				return this[name](match);
			else {
				const err = new HSE(msg.illegalInElement, match);

				if (strict)
					throw err;
				else
					return this.emit('wat', err);
			}
		}

		if (state != $start && name == $xmlDecl) {
			const err = new HSE(misplacedXMLDecl, match);

			if (strict)
				throw err;
			else
				return this.emit('wat', err);
		}

		if (!target && !this.html) {
			const onlyDTDE =
				name == $attListDecl ||
				name == $elemDecl ||
				name == $entityDecl ||
				name == $markedSectOpen ||
				name == $notationDecl ||
				name == $paramRef;

			if (onlyDTDE) {
				this[$state]  = $externalDTD;
				this[$target] = 'DoctypeExternal';
				this[$node]   = this[$doc] = new DoctypeExternal(this[$opts]);

				return this[name](match);
			}
		}

		if (target == 'DoctypeExternal') {

			let isValid =
				name == $attListDecl ||
				name == $comment ||
				name == $elemDecl ||
				name == $entityDecl ||
				name == $markedSectClose ||
				name == $markedSectOpen ||
				name == $notationDecl ||
				name == $paramRef ||
				name == $procInst;

			if (state == $start)
				isValid = isValid || name == $xmlDecl;

			this[$state] = $externalDTD;

			if (isValid)
				return this[name](match);
			else {
				const err = new HSE(msg.illegalInDTDE, match);

				if (strict)
					throw err;
				else
					return this.emit('wat', err);
			}
		}

		if (!target) {

			const onlyDoc =
				name == $dtdSimple ||
				name == $dtdInlineOpen ||
				name == $tagOpen ||
				name == $tagEmpty;

			if (onlyDoc) {
				this[$target] = 'Document';
				this[$node]   = this[$doc] = new Document(this[$opts]);

				return this[name](match);
			}
		}

		if (target == 'Document') {

			let isValid = false;

			if (state == $start) {
				isValid =
					name == $comment ||
					name == $dtdInlineOpen ||
					name == $dtdSimple ||
					name == $procInst ||
					name == $tagEmpty ||
					name == $tagOpen ||
					name == $xmlDecl;
			} else if (state == $afterXMLDecl) {
				isValid =
					name == $comment ||
					name == $dtdInlineOpen ||
					name == $dtdSimple ||
					name == $procInst ||
					name == $tagEmpty ||
					name == $tagOpen;
			} else if (state == $internalDTD) {
				isValid =
					name == $attListDecl ||
					name == $comment ||
					name == $dtdInlineClose ||
					name == $elemDecl ||
					name == $entityDecl ||
					name == $notationDecl ||
					name == $paramRef ||
					name == $procInst;
			} else if (state == $afterDTD) {
				isValid =
					name == $comment ||
					name == $procInst ||
					name == $tagEmpty ||
					name == $tagOpen;
			} else if (state == $afterRoot) {
				isValid = 
					name == $comment ||
					name == $procInst;
			}

			if (isValid)
				return this[name](match);
			else {
				const err = new HSE(msg.illegalOrMisplacedInDoc, match);

				if (strict)
					throw err;
				else
					return this.emit('wat', err);
			}
		}

		if (name == $comment || name == $procInst || name == $xmlDecl)
			return this[name](match);

		const err = new HSE(msg.illegalNode, match);

		if (this.strict)
			throw err;
		else
			this.emit('wat', err);
	}

	[$attListDecl](str) {
		const pattern = this.strict ? attListDecl_strict : attListDecl_sloppy;

		let [ , n, body ] = str.match(pattern) || [];

		if (!n) {
			const err = new HSE(msg.malformedAttList, str);

			if (this.strict)
				throw err;
			else
				return this.emit('wat', err);
		}

		const [ , namespace, name ] = n.match(nsPattern);

		let attList;

		try {
			attList = new AttListDeclaration({ namespace, name });
			this[$node].children.push(attList);
		} catch (err) {
			if (this.strict)
				throw err;
			else
				return this.emit('wat', err);
		}

		if (body) {

			let [ match, n, t1, t2, m, d1, d2, v1, v2 ] =
				body.match(attDefPattern) || [];

			while (match) {

				if (!n) {
					const err = new HSE(msg.malformedAttList, str, body);
					
					if (this.strict)
						throw err;
					else
						return this.emit('wat', err);
				}

				const [ , namespace, name ] = n.match(nsPattern);
				const type = t1 || t2;
				const members = m && m.split(/\s*\|\s*/g);
				const defaultType = d1 || d2;
				const defaultValue = v1 || v2;

				try {

					const attDef = new AttributeDefinition({
						namespace, name, type, members,
						defaultType, defaultValue
					});

					attList.defs.push(attDef);

				} catch (err) {
					if (this.strict)
						throw err;
					else
						this.emit('wat', err);
				}

				body = body.slice(match.length);

				[ match, n, t1, t2, m, d1, d2, v1, v2 ] =
					body.match(attDefPattern) || [];
			}

			if (body && !isValid.whitespace(body)) {
				const err = new HSE(msg.malformedAttList, str, body);
				
				if (this.strict)
					throw err;
				else
					this.emit('wat', err);
			}
		}
	}

	[$cdata](str) {
		let [ , content ] = str.match(cdataPattern) || [];

		if (this.normalize) {
			content = content::norm();
			if (!content) return;
		}

		try {
			const cdata = new CDATASection({ content });
			this[$node].children.push(cdata);
		} catch (err) {
			if (this.strict)
				throw err;
			else
				this.emit('wat', err);
		}
	}

	[$comment](str) {
		let [ , content ] = str.match(commentPattern) || [];

		if (this.normalize) {
			content = content::norm();
			if (!content) return;
		}

		const comment = new Comment(content);

		if (comment.content != content) {
			let index;

			for (index in content) {
				if (comment.content[index] != comment[index]) break;
			}

			const err = new HSE(msg.invalidComment, content, index);

			if (this.strict)
				throw err;
			else
				this.emit('warning', err);
		}

		if (this[$node])
			this[$node].children.push(comment);
		else
			this[$opts].children.push(comment);
	}

	[$dtdInlineOpen](str) {
		this[$dtdSimple](str);

		const dtd = this[$node].children.last;

		if (dtd instanceof Doctype) {
			this[$state] = $internalDTD;
			this[$node]  = dtd;
		}
	}

	[$dtdInlineClose](str) {
		if (this[$node] instanceof Doctype) {
			this[$state] = $afterDTD;
			this[$node]  = this[$node].parent;
		} else {
			const err = new HSE(msg.whatIsThisEven, str);

			if (this.strict)
				throw err
			else
				this.emit('wat', err);
		}
	}

	[$dtdSimple](str) {
		this[$state] = $afterDTD;

		const pattern = this.strict ? dtdOpen_strict : dtdOpen_sloppy;

		const [ , name, s1, s2, p1, p2, s3, s4 ] = str.match(pattern) || [];

		const systemID = s1 || s2 || s3 || s4;

		const publicID = p1 || p2;

		try {
			const dtd = new Doctype({ name, systemID, publicID });
			this[$node].children.push(dtd);
		} catch (err) {
			if (this.strict)
				throw err;
			else
				this.emit('wat', err);
		}
	}

	[$elemDecl](str) {
		const pattern = this.strict ? elemDecl_strict : elemDecl_sloppy;

		let [ , n, t, pc, pcm, m, quantifier ] = str.match(pattern) || [];

		if (!n) {
			const err = new HSE(msg.malformedElemDecl, str);

			if (this.strict)
				throw err;
			else
				return this.emit('wat', err);
		}

		const [ , namespace, name ] = n.match(nsPattern);

		let type = t || (pc && 'MIXED');

		let members = [];

		if (pcm) {
			if (quantifier != '*') {
				const index = quantifier ? str.lastIndexOf(quantifier) : 0;
				const err = new HSE(msg.mixedEnumNotAsterisk, str, index);

				if (this.strict) {
					throw err;
				} else {
					quantifier = '*';
					this.emit('warning', err);
				}
			}

			members = pcm.split(/\s*\|\s*/g).slice(1).map(n => {
				const [ , namespace, name ] = n.match(nsPattern);

				try {
					return new ChildElementName({ namespace, name });
				} catch (err) {
					if (this.strict)
						throw err;
					else
						this.emit('wat', err);
				}

			}).filter(n => n);

		} else if (!pcm && pc) {
			if (quantifier) {
				const index = str.lastIndexOf(quantifier);
				const err = new HSE(msg.pcdataQualified, str, quantifier);

				if (this.strict) {
					throw err;
				} else {
					quantifier = '';
					this.emit('warning', err);
				}
			}
		} else if (m) {
			try {
				members = toContentSpecList(m);
			} catch (err) {
				if (this.strict) {
					throw err;
				} else {
					return this.emit('wat', err);
				}
			}
		}

		type = type || members.type;
		members.type = members.type || type;

		if (type != members.type) {
			const index = str.indexOf('(');
			const err = new HSE(msg.incompatibleContentSpecType, str, index);

			if (this.strict)
				throw err;
			else
				this.emit('wat', err);
		}

		try {
			const elemDecl = new ElementDeclaration({
				namespace, name, quantifier, type
			});

			for (const member of members)
				elemDecl.contentSpec.push(member);

			this[$node].children.push(elemDecl);
		} catch (err) {
			if (this.strict)
				throw err;
			else
				this.emit('wat', err);
		}
	}

	[$entityDecl](str) {
		const pattern = this.strict ? entityDecl_strict : entityDecl_sloppy;

		const [ , isParameter, name, v1, v2, s1, s2, p1, p2, s3, s4, ndata ] =
			str.match(pattern) || [];

		if (!name) {
			const err = new HSE(msg.malformedEntityDecl, str);

			if (this.strict)
				throw err
			else
				return this.emit('wat', err);
		}

		const systemID = s1 || s2 || s3 || s4;
		const publicID = p1 || p2;

		try {
			const entityDecl = new EntityDeclaration({
				isParameter, name, ndata, publicID, systemID, value
			});

			this[$node].children.push(entityDecl);

		} catch (err) {
			if (this.strict)
				throw err;
			else
				this.emit('wat', err);
		}
	}

	[$markedSectClose](str) {
		if (this[$node] instanceof ConditionalSection) {
			this[$node] = this[$node].parent;
		} else {
			const err = new HSE(msg.whatIsThisEven, str);

			if (this.strict)
				throw err
			else
				this.emit('wat', err);
		}
	}

	[$markedSectOpen](str) {

		const [ , keyword ] = markedSectPattern || [];

		try {
			const markedSect = new ConditionalSection(keyword);

			this[$node].children.push(markedSect);

			this[$node] = markedSect;
		} catch (err) {
			if (this.strict)
				throw err;
			else
				this.emit('wat', err);
		}
	}

	[$notationDecl](str) {

		const pattern = this.strict ? notation_strict : notation_sloppy;

		const [ , n, s1, s2, p1, p2, s3, s4 ] = str.match(pattern) || [];

		if (!n) {
			const err = new HSE(msg.malformedNotationDecl, str);

			if (this.strict)
				throw err;
			else
				return this.emit('wat', err);
		}

		const [ , namespace, name ] = n.match(nsPattern);

		const systemID = s1 || s2 || s3 || s4;
		const publicID = p1 || p2;

		try {
			const notationDecl = new NotationDeclatation({
				name, namespace, publicID, systemID
			});

			this[$node].children.push(notationDecl);
		} catch (err) {
			if (this.strict)
				throw err;
			else
				this.emit('wat', err);
		}
	}

	[$paramRef](str) {
		try {
			const pr = new ParameterReference(str);
			this[$node].children.push(pr);
		} catch (err) {
			if (this.strict)
				throw err;
			else
				this.emit('wat', err);
		}
	}

	[$procInst](str) {

		const pattern = this.strict ? pi_strict : pi_sloppy;

		const [ , target, instruction ] = str.match(pattern) || [];

		if (!target) {
			const err = new HSE(msg.malformedPI, str);

			if (this.strict)
				throw err;
			else
				return this.emit('wat', err);
		}

		try {
			const pi = new ProcessingInstruction({ target, instruction });

			if (this[$node])
				this[$node].children.push(pi);
			else
				this[$opts].children.push(pi);

		} catch (err) {
			if (this.strict)
				throw err;
			else
				this.emit('wat', err);
		}
	}

	[$tagClose](str) {
		const pattern = this.strict ? tagClose_strict : tagClose_sloppy;

		let [ , n ] = str.match(pattern) || [];

		if (!n) {
			// A very odd case. The permissive pattern is very permissive, so
			// it seems unrecoverable regardless of mode. One last thing to try,
			// though...

			const err = new HSE(msg.malformedClosingTag, str);

			if (this.strict) {
				throw err;
			} else {
				const expected = this[$node].name;

				if (!expected) return this.emit('wat', err);

				if (~str.indexOf(expected)) {
					this[$node] = this[$node].parent;

					if (!this[$node].parent)
						this[$state] = $afterRoot;

					this.emit('wat', err);
				}

				throw err;
			}
		}

		if (this.html) n = n.toLowerCase();

		if (this[$node].fullName == n) {
			this[$node] = this[$node].parent;

			if (!this[$node].parent)
				this[$state] = $afterRoot;

		} else if (this[$node] instanceof Element) {
			const err = new HSE(msg.unmatchedTag(this[$node].fullName), str);

			if (this.strict) throw err;

			// In the event of a closing tag that doesn’t balance in sloppy mode
			// we can try to recover if it appears that intermediate closing
			// tags were accidentally omitted. This is a gambit: while that’s
			// a *possible* explanation, we (a) don’t know for sure and (b)
			// don’t know where the end tags really should have been positioned.

			// This is the approach taken by browsers when facing malformed HTML
			// though, so I think that it’s probably the recovery type that
			// people are accustomed to.

			// <a><b>text<c></a> would therefore become <a><b>text<c/></b></a>.

			const realNode = this[$node].parents.find(p => p.fullName == n);

			if (realNode) {
				this[$node] = realNode;
				this.emit('wat', err);
			} else {
				throw err;
			}
		} else {
			const err = new HSE(msg.unmatchableTag(n), str);

			if (this.strict)
				throw err;
			else
				this.emit('wat', err);
		}
	}

	[$tagEmpty](str) {
		const orig = str;

		if (this.strict)
			str = str.replace(/\/>$/, '>');
		else
			str = str.replace(/\/\s*>$/, '>');

		if (str == orig) {
			const err = new HSE(msg.malformedEmptyTag, str);

			if (this.strict)
				throw err;
			else
				return this.emit('wat', err);
		}

		const origNode = this[$node];
		let outerErr;

		try {
			this[$tagOpen](str);
		} catch (err) {
			outerErr = err;
		} finally {
			if (this[$node] != origNode) {
				this[$node] = this[$node].parent;

				if (!this[$node].parent)
					this[$state] = $afterRoot;
			}

			if (outerErr) throw outerErr;
		}
	}

	[$tagOpen](str) {

		this[$state] = $inRoot;

		const pattern = this.strict ? tagOpen_strict : tagOpen_sloppy;

		let [ , n, body ] = str.match(pattern) || [];

		if (!n) {
			const err = new HSE(msg.malformedOpenTag, str);

			if (this.strict)
				throw err;
			else
				return this.emit('wat', err);
		}

		if (this.html) n = n.toLowerCase();

		const [ , namespace, name ] = n.match(nsPattern);

		let elem;

		try {
			if (this.html) {

				const Constructor =
					!namespace && HTMLElementPre.nodes[name] ? HTMLElementPre :
					!namespace && HTMLElementASC.nodes[name] ? HTMLElementASC :
					HTMLElement;

				elem = new Constructor({ namespace, name });

			} else {
				elem = new Element({ namespace, name });
			}

			let node = this[$node];

			if (this.html) {
				// HTML allows some super weird shit.

				const n1 = node.name;
				const n2 = name;

				// Elements with implied closing

				const impliedClose = (
					(n1 == 'head' && n2 == 'body') ||
					(n1 == 'p' && htmlPClosers.has(n2)) ||
					(n1 == 'li' && n2 == 'li') ||
					(n1 == 'tr' && n2 == 'tr') ||
					(n1 == 'td' && n2 == 'td') ||
					(n1 == 'th' && n2 == 'th') ||
					(n1 == 'optgroup' && n2 == 'optgroup') ||
					(
						(n1 == 'option') &&
						(n2 == 'optgroup' || n2 == 'option')
					) || (
						(n1 == 'dt' || n1 == 'dd') &&
						(n2 == 'dt' || n2 == 'dd')
					) || (
						(n1 == 'rb' || n1 == 'rt' || n1 == 'rp') &&
						(n2 == 'rb' || n2 == 'rt' || n2 == 'rp' || n2 == 'rtc')
					) || (
						(n1 == 'rtc') &&
						(n2 == 'rb' || n2 == 'rp' || n2 == 'rtc')
					) || (
						(n1 == 'colgroup') &&
						(n2 != 'col' && n2 != 'template')
					) || (
						(n1 == 'tbody' || n1 == 'thead' || n1 == 'tfoot') &&
						(n2 != 'tr' && n2 != 'script' && n2 != 'template')
					)
				);

				if (impliedClose)
					this[$node] = node = node.parent;

				// Elements with implied opening

				if ((node instanceof Document) && n2 != 'html') {
					node.children.push(new HTMLElement({ name: 'html' }));
					this[$node] = node = node.children.last;
				}

				const isInHead = htmlHeadElements.has(name);

				if (node.name == 'html') {
					const hasHead = node.children.some(e => e.name == 'head');
					const hasBody = node.children.some(e => e.name == 'body');

					if (!hasHead && name != 'head') {
						const head = new HTMLElement({ name: 'head' });

						node.children.push(head);

						if (isInHead) {
							this[$node] = node = head;
						} else if (name != 'body') {
							const body = new HTMLElement({ name: 'body' });
							node.children.push(body);
							this[$node] = node = body;
						}
					} else if (!hasBody && name != 'head' && name != 'body') {
						const body = new HTMLElement({ name: 'body' });
						node.children.push(body);
						this[$node] = node = body;
					} else if (hasBody && name == 'body') {
						return this.emit('wat', new HSE(msg.multipleBodies));
					} else if (hasHead && name == 'head') {
						return this.emit('wat', new HSE(msg.multipleHeads));
					}
				} else if (node.name == 'head' && !isInHead && name != 'body') {
					const body = new HTMLElement({ name: 'body' });
					node.parent.children.push(body);
					this[$node] = node = body;

				} else if (node.name == 'table' && name == 'tr') {
					node.children.push(new HTMLElement({ name: 'tbody' }));
					this[$node] = node = node.children.last;

				} else if (node.name == 'table' && name == 'col') {
					node.children.push(new HTMLElement({ name: 'colgroup' }));
					this[$node] = node = node.children.last;
				}
			}

			node.children.push(elem);

			if (!(elem instanceof HTMLElementASC)) this[$node] = elem;

		} catch (err) {
			if (this.strict)
				throw err;
			else
				return this.emit('wat', err);
		}

		if (body && !this.strict) {

			attr_sloppy.lastIndex = 0;

			let [ match, k, val1, val2, val3 ] = attr_sloppy.exec(str) || [];

			while (k) {

				const value = val1 || val2 || val3 || '';

				if (this.html) k = k.toLowerCase();

				const [ , namespace, key ] = k.match(nsPattern);

				try {
					elem.setAttribute({ namespace, key, value });

					if (elem.attributes.last.value != value) {
						const err = new HSE(msg.illegalAttrChar, str, match);
						this.emit('warning', err);
					}
				} catch (err) {
					this.emit('wat', err);
				}

				body = body.slice(match.length);

				[ match, k, val1, val2, val3 ] = attr_sloppy.exec(str) || [];
			}

		} else if (body) {

			const AttrConst = this.html ? HTMLAttribute : Attribute;

			let [ match, k, val1, val2 ] = body.match(attr_strict) || [];

			while (match) {
				const value = val1 || val2;

				if (this.html) k = k.toLowerCase();

				let [ , namespace, key ] = k.match(nsPattern);

				const attr = new AttrConst({ namespace, key, value });

				if (attr.value != value)
					throw new HSE(msg.illegalAttrChar, str, match);

				elem.attributes.push(attr);

				body = body.slice(match.length);

				[ match, k, val1, val2 ] = body.match(attr_strict) || [];
			}

			if (body && !isValid.whitespace(body))
				throw new HSE(msg.malformedOpenTag, str, body);
		}
	}

	[$text](content) {
		const pre = [ ...this[$node].lineage() ].some(
			e => e instanceof HTMLElementPre
		);

		if (this.normalize && !pre) {
			content = content::norm();
			if (!content) return;
		}

		const nn = this[$node] && this[$node].name;

		if (this.html && (!nn || nn == 'html' || nn == 'head')) {
			this[$tagEmpty]('<hack/>'); // just do that crap please
			this[$node].children.last.remove(); // thanks!
		}

		let before = content;
		let after;

		const prev = this[$node].children.last;

		if (prev && prev instanceof Text) {
			// In theory, we could be dealing with a sequence where first text
			// was matched using a DTD closer etc, but it got recognized as text
			// after, and then there was additional text. Here we can stitch
			// them back together. It’s slightly problematic since it could mean
			// losing some whitespace in the text node, but it’s probably very
			// rare that this will ever occur.

			before       = prev.content + content;
			prev.content = before;
			after        = prev.content;
		} else {
			const text = new Text({ content });

			after = text.content;

			this[$node].children.push(text);
		}

		if (before != after) {

			let index;

			for (index in before) {
				if (before[index] != after[index]) break;
			}

			const err = new HSE(msg.illegalTextChars, content, index);

			if (this.strict)
				throw err;
			else
				this.emit('warning', err);
		}
	}

	[$xmlDecl](str) {
		// At xml declaration, it’s possible that we still have an ambiguous
		// target. This may be cleared up if "standalone" exists; that means
		// this is a Document. But it also may remain ambiguous, in which case
		// we save the results to $opts for instantiating the correct type
		// later.

		let v1, v2, e1, e2, s1, s2;
		let version, encoding, standalone;

		if (this.strict) {
			[ , v1, v2, e1, e2, s1, s2 ] = str.match(xmlDecl_strict) || [];

			version    = v1 || v2;
			encoding   = e1 || e2;
			standalone = s1 || s2;

		} else {

			attr_sloppy.lastIndex = 0;

			let [ , key, val1, val2, val3 ] = attr_sloppy.exec(str) || [];

			while (key) {
				switch (key.toLowerCase()) {
					case 'version':
						version = val1 || val2 || val3;

						if (version) version = parseFloat(version);

						if (version && ((version < 1) || (version >= 2))) {
							version = null;
							const err = new HSE(msg.xmlDeclBadVers, str, key);
							this.emit('warning', err);
						}

						break;
					case 'encoding':
						encoding = val1 || val2 || val3;

						if (encoding && !isValid.encoding(encoding)) {
							encoding = null;
							const err = new HSE(msg.xmlDeclBadEnc, str, key);
							this.emit('warning', err);
						}

						break;
					case 'standalone':
						standalone = val1 || val2 || val3;

						if (standalone) {
							standalone = standalone.trim.toLowerCase();

							if (standalone != 'yes' && standalone != 'no') {
								standalone = null;
								const err = new HSE(msg.xmlDeclBadSD, str, key);
								this.emit('warning', err);
							}
						}

						break;
				}

				[ , key, val1, val2, val3 ] = attr_sloppy.exec(str) || [];
			}

			const [ strictMatch ] = str.match(xmlDecl_strict) || [];

			if (!strictMatch)
				this.emit('warning', new HSE(msg.malformedXMLDecl, str));
		}

		if (standalone && !this.target)
			this[$target] = 'Document';
		else if (encoding && !version)
			this[$target] = 'DoctypeExternal';

		if ((this.target == 'Document') && !version) {
			const err = new HSE(msg.xmlDeclBadVers, str);

			if (this.strict)
				throw err;
			else
				this.emit('warning', err);
		} else if (this.target == 'DoctypeVersion' && standalone) {
			const err = new HSE(msg.malformedTextDecl, str);

			if (this.strict)
				throw err;
			else
				this.emit('warning', err);
		}

		try {
			if (this.target == 'Document')
				this[$node] = this[$doc] =
					new Document({ version, encoding, standalone });
			else if (this.target == 'DoctypeExternal')
				this[$node] = this[$doc] =
					new DoctypeExternal({ version, encoding });
			else
				this[$opts] = { version, encoding, children: [] };
		} catch (err) {
			if (this.strict)
				throw err;
			else
				this.emit('wat', err);
		}
	}
}

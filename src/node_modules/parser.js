
import { PassThrough } from 'stream';

import Decoder   from 'parser-decoder';
import Grammar   from 'parser-grammar';
import Tokenizer from 'parser-tokenizer';

// OPTIONS NORMALIZATION ///////////////////////////////////////////////////////

const norm = str => str.toLowerCase().replace(/\s/g, '');

const modes = new Set([
  'validating', 'strict', 'sloppy', 'html'
]);

const targets = new Set([
  'document', 'fragment', 'externaldtd', 'externalentity'
]);

// PARSER //////////////////////////////////////////////////////////////////////

export default class Parser extends PassThrough {
  constructor({ encoding, mode='strict', target='document' }={}) {
    mode   = norm(mode);
    target = norm(target);

    if (!modes.has(mode))
      throw new TypeError(msg.invalidMode);

    if (!targets.has(target))
      throw new TypeError(msg.invalidTarget);

    this.decoder   = new Decoder(encoding);
    this.tokenizer = new Tokenizer(decoder);
    this.grammar   = new Grammar(mode, target, tokenizer);
    this.assembler = new Assembler(mode, target, this.grammar, this.decoder);

    this.assembler.on('error', err => { /*TODO*/ });
    this.assembler.on('result', res => { /*TODO*/ });

    this.pipe(decoder).pipe(tokenizer);
  }

  static parse(input, opts, cb) {
    if (!cb && opts instanceof Function) {
      cb   = opts;
      opts = {};
    }

    return new Promise((resolve, reject) => {
      const parser = new Parser(opts);

      parser.on('error', err => {
        reject(err);
        if (cb) cb(err);
      });
      
      parser.on('result', res => {
        resolve(res);
        if (cb) cb(null, res);
      });

      parser.write(input);
      parser.end();
    });
  }
}

// IMPORTS /////////////////////////////////////////////////////////////////////

import ParseError   from 'parse-error';
import msg          from 'msg';
import { Writable } from 'stream';

// PATTERN COMPONENTS //////////////////////////////////////////////////////////

const char          = '[\\t\\r\\n -\uD7FF\uE000-\uFFFD\u{10000}-\u{10FFFF}]';
const whiteReq      = '[\\t\\r\\n ]+';
const whiteOpt      = '[\\t\\r\\n ]*';

const nameStart = [
	'A-Za-z:_',
	'\u{000C0}-\u{000D6}', '\u{000D8}-\u{000F6}', '\u{000F8}-\u{002FF}',
	'\u{00370}-\u{0037D}', '\u{0037F}-\u{01FFF}', '\u{0200C}-\u{0200D}',
	'\u{02070}-\u{0218F}', '\u{02C00}-\u{02FEF}', '\u{03001}-\u{0D7FF}',
	'\u{0F900}-\u{0FDCF}', '\u{0FDF0}-\u{0FFFD}', '\u{10000}-\u{EFFFF}'
].join('');

const nameContinue = [
	nameStart, '\\-\\.\\d', '\u00B7', '\u0300-\u036F', '\u203F-\u2040'
].join('');

const anyAttrVal    = '[^>\\t\\r\\n ]+';
const encName       = '[A-Za-z]([A-Za-z\\d\\.\\-_])*';
const equals        = `${ whiteOpt }=${ whiteOpt }`;
const standalone    = 'no|yes';
const versionNumber = '1\\.\\d+';

// PATTERNS: LOW-LEVEL /////////////////////////////////////////////////////////

const divide = /^(?:<!--(.+)-->|<!\[CDATA\[(.+)\]\]>|<([^>]+)>|([^<>]+)(?=<))/;

const white         = new RegExp(`^${ whiteReq }$`);
const whiteAnywhere = new RegExp(whiteReq);

// PATTERNS: VALIDATION & PARSING //////////////////////////////////////////////

const charsEntirely     = new RegExp(`^${ char }+$`, 'u');
const charsFromStart    = new RegExp(`^${ char }+`, 'u');
const encNamePattern    = new RegExp(`^${ encName }$`);

const namePattern = new RegExp(`^[${ nameStart }][${ nameContinue }]+$`, 'u');

const tagNamePattern = new RegExp(
	`^(?:(${ nameStart }][${ nameContinue }]+):)?` +
	`(${ nameStart }][${ nameContinue }]+)$`, 'u'
);

const permissiveTagNamePattern = /(?:([^:\t\r\n ]+):)?([^\t\r\n ]++)/;

const xmlDeclPattern = new RegExp(
	`^\\?xml${ whiteReq }version${ equals }` +
	`(?:"(${ versionNumber })"|'(${ versionNumber })'|(${ anyAttrVal }))` +
		`(?:${ whiteReq }encoding${ equals }` +
		`(?:"(${ encName })"|'(${ encName })')|(${ anyAttrVal }))?` +
		`(?:${ whiteReq }standalone${ equals }` +
		`(?:"(${ standalone })"|'(${ standalone })'|(${ anyAttrVal }))` +
		`)?` +
	`${ whiteOpt }>$`
);

const xmlPattern = /^xml$/i;

// PATTERNS: TRANSFORMATION ////////////////////////////////////////////////////

const badAmpersand = new RegExp(
	`&(?!#\\d+;|#x[\\dA-Fa-f]+;|[${ nameStart }][${ nameContinue }]+;)`, 'ug'
);

const badLT = /</g;

const badThingie = /\]\]>/g;

// UTIL ////////////////////////////////////////////////////////////////////////

const cleanAttVal = val => {
	val = String(val);

	return val.replace(badAmpersand, '&amp;').replace(badLT, '&lt;');
};

const cleanText = val => {
	return cleanAttVal(val).replace(badThingie, ']]&gt;');
};

const escapeQuote = quote => (quote == '"') ? '&quot;' : '&apos;';

const indent = (depth, ws) => new Array(depth + 1).join(String(ws) || '');

const validQuote = quote => (quote == '"' || quote == '\'') ? quote : '"';

// DECORATORS //////////////////////////////////////////////////////////////////

const unwritable = (target, name, descriptor) => {
	descriptor.writable = false;
	return descriptor;	
};

const accessor = (target, name, descriptor) => {
	descriptor.enumerable = true;
	descriptor.configurable = false;
	return descriptor;
}

// NODE SYMBOLS ////////////////////////////////////////////////////////////////

const $attributes     = Symbol('prop: attributes of a node');
const $children       = Symbol('prop: children of a node');
const $constructor    = Symbol('prop: the legal type of a restricted array');
const $content        = Symbol('prop: text content');
const $doctype        = Symbol('prop: doctype');
const $encoding       = Symbol('prop: xml encoding');
const $externalID     = Symbol('prop: external doctype ID');
const $instruction    = Symbol('prop: property instruction content');
const $internalSubset = Symbol('prop: internal doctype subset');
const $key            = Symbol('prop: attribute key');
const $name           = Symbol('prop: tag name');
const $namespace      = Symbol('prop: namespace');
const $parent         = Symbol('prop: parent node (used for parsing only)');
const $standalone     = Symbol('prop: xml standalone');
const $target         = Symbol('prop: property instruction target');
const $validate       = Symbol('method: throw type error for restricted array');
const $value          = Symbol('prop: attribute value');
const $version        = Symbol('prop: xml version');

// NODE HELPER CLASSES /////////////////////////////////////////////////////////

class RestrictedArray extends Array {
	constructor(constructor) {
		super();

		this[$constructor] = constructor;
	}

	[$validate](...args) {
		const constructor = this[$constructor];
		const valid = args.some(arg => arg instanceof constructor);

		if (!valid) throw new TypeError(msg.invalidType(constructor.name));
	}

	@unwritable
	concat() {
		this[$validate](...arguments);
		super.concat(...arguments);
	}

	@unwritable
	fill(value) {
		this[$validate](value);
		super.fill(...arguments);
	}

	@unwritable
	push() {
		this[$validate](...arguments);
		super.push(...arguments);
	}

	@unwritable
	splice(start, deleteCount, ...values) {
		this[$validate](...values);
		super.splice(...arguments);
	}
}

class Children extends RestrictedArray {
	constructor() {
		super(XMLNode);
	}

	@unwritable
	toString({ withNamespace=true, whitespace='\t', quote='"', d=0 }={}) {
		return this.map(
			child => child.toString({ withNamespace, whitespace, quote, d })
		).join(whitespace ? '\n' : '');
	}
}

class Attributes extends RestrictedArray {
	constructor() {
		super(Attributes);
	}

	@unwritable
	toString({ withNamespace=true, quote='"' }={}) {
		return this.map(
			attr => attr.toString({ withNamespace, quote })
		).join(' ');
	}
}

// NODE CLASSES (WITH CHILDREN) ////////////////////////////////////////////////

class XMLNode {
	constructor(name, namespace) {
		this[$name]       = name;
		this[$namespace]  = namespace;
		this[$attributes] = new Attributes();
		this[$children]   = new Children();
	}

	@accessor
	get last() {
		const children = this[$children];
		return children[children.length - 1];
	}

	@accessor
	get children() { return this[$children]; }
	set children(val) {
		this[$children] =
			(val instanceof Children) ? val : new Children();
	}

	@accessor
	get attributes() { return this[$attributes]; }
	set attributes(val) {
		this[$attributes] =
			(val instanceof Attributes) ? val : new Attributes();
	}

	@accessor
	get name() { return this[$name]; }
	set name(val) {
		if (val === undefined) {
			this[$name] = val;
			return;
		}

		val = String(val);

		if (namePattern.test(val))
			this[$name] = val;
	}

	@accessor
	get namespace() { return this[$namespace]; }
	set namespace(val) {
		if (val === undefined) {
			this[$namespace] = val;
			return;
		}

		val = String(val);

		if (namePattern.test(val))
			this[$namespace] = val;
	}

	@accessor
	get fullName() {
		return (this.namespace) ? this.namespace + ':' + this.name : this.name;
	}

	@unwritable
	toString({ withNamespace=true, whitespace='\t', quote='"', d=0 }={}) {
		quote = validQuote(quote);

		const p = indent(d, whitespace);

		d++;

		const children =
			this.children.toString({ withNamespace, whitespace, quote, d });

		const attributes = this.attributes.toString({ withNamespace, quote });

		const openTag =
			(withNamespace ? this.fullName : this.name) +
			(attributes ? ` ${ attributes }` : '');

		if (!children)
			return `${ p }<${ openTag }/>`;

		return `${ p }<${ openTag }>\n${ children }\n${ p }</${ this.name }>`;
	}
}

class XMLDocument {
	constructor() {
		this.children = new Children();
	}

	@accessor
	get children() { return this[$children]; }
	set children(val) {
		this[$children] =
			(val instanceof Children) ? val : new Children();
	}

	@accessor
	get version() { return this[$version]; }
	set version(val) {
		val = parseFloat(val);

		if (val >= 1 && val < 2)
			this[$version] = val;
	}

	@accessor
	get encoding() { return this[$encoding]; }
	set encoding(val) {
		val = String(val);

		if (encNamePattern.test(val))
			this[$encoding] = val;
	}

	@accessor
	get standalone() { return this[$standalone]; }
	set standalone(val) {
		if (val === true || val === false) {
			this[$standalone] = val;
			return;
		}

		if (val instanceof Boolean) {
			this[$standalone] = val.valueOf();
			return;
		}

		val = String(val);

		if (val === 'yes')
			this[$standalone] = true;
		else if (val === 'no')
			this[$standalone] = false;
	}

	@accessor
	get doctype() { return this[$doctype]; }
	set doctype(val) {
		if (val instanceof XMLDoctype || val === undefined)
			this[$doctype] = val;
	}

	@unwritable
	toString({ withNamespace=true, whitespace='\t', quote='"' }={}) {
		quote = validQuote(quote);

		const doc = [];

		let version = this.version;

		if (version) {
			version = version == 1 ? '1.0' : version.toString();

			const encoding   = this.encoding;
			const standalone = this.standalone;

			doc.push(`<?xml version=${ quote }${ version }${ quote }${
				encoding ? ` encoding=${ quote }${ encoding }${ quote }` : ''
			}${
				standalone !== undefined ? ` standalone=${ quote }${
					standalone ? 'yes' : 'no'
				}${ quote }` : ''
			} ?>`);
		}

		if (this.doctype) doc.push(this.doctype.toString());

		if (children.length) doc.push(
			this.children.toString({ withNamespace, whitespace, quote })
		);

		return doc.join(whitespace ? '\n' : '');
	}
}

class XMLDoctype extends XMLNode {
	constructor(doctypeName, externalID, internalSubset) {
		this.name = doctypeName;
	}

	@accessor
	get namespace() { return undefined; }

	@unwritable
	toString() {
		// TODO
	}
}

// NODE CLASSES (WITHOUT CHILDREN) /////////////////////////////////////////////

class XMLChildlessNode extends XMLNode {
	constructor() {
		super();
	}

	@accessor
	set attributes() { return undefined; }

	@accessor
	get children() { return undefined; }

	@accessor
	get name() { return undefined; }

	@accessor
	get namespace() { return undefined; }
}

class XMLAttribute extends XMLChildlessNode {
	constructor(key, value) {
		super();

		this.key   = key;
		this.value = value;
	}

	@accessor
	get key() { return this[$key]; }
	set key(val) {
		if (val === undefined) {
			this[$key] = val;
			return;
		}

		val = String(val);

		if (namePattern.test(val))
			this[$key] = val;
	}

	@accessor
	get value() { return this[$value]; }
	set value(val) {
		if (val === undefined) {
			this[$key] = val;
			return;
		}

		this[$value] = cleanAttVal(val);
	}

	@unwritable
	toString({ withNamespace=true, quote='"' }={}) {
		quote = validQuote(quote);

		const value = this.value;

		if (!value) return key;

		if (~value.indexOf(quote)) {
			const replacement = escapeQuote(quote);
			value = value.replace(new RegExp(quote, 'g'), replacement);
		}

		return `${ key }=${ quote }${ value }${ quote }`;
	}
}

class XMLComment extends XMLChildlessNode {
	constructor(str) {
		super();

		this.content = str;
	}

	@accessor
	get content() { return this[$content]; }
	set content(val) {
		if (val === undefined) {
			this.content = val;
			return;
		}

		val = String(val);

		if (~val.indexOf('--') || !charsEntirely.test(val)) return;

		this[$content] = val;
	}

	@unwritable
	toString({ whitespace='\t', d=0 }={}) {
		return `${ indent(d, whitespace) }<!-- ${ this.content } -->`;
	}
}

class XMLProcessingInstruction extends XMLChildlessNode {
	constructor(target, instruction) {
		super();

		this.target = target;

		if (instruction) this.instruction = instruction;
	}

	@accessor
	get target() { return this[$target]; }
	set target(val) {
		val = String(val);

		if (xmlPattern.match(piTarget))
			this[$target] = val;
	}

	@accessor
	get instruction() { return this[$instruction]; }
	set instruction(val) {
		val = String(val);

		if (charsEntirely.test(val)) this[$instruction] = val;
	}

	@unwritable
	toString({ whitespace='\t', d=0 }={}) {
		return `${
			indent(d, whitespace)
		}<?${
			this.target
		} ${
			(this.instruction ? this.instruction + ' ' : '')
		}?>`;
	}
}

class CDATA extends XMLChildlessNode {
	constructor(str) {
		super();
		this.content = str;
	}

	@accessor
	get content() { return this[$content]; }
	set content(val) {
		this[$content] = val === undefined ? '' : cleanText(val);
	}

	@unwritable
	toString({ whitespace='\t', d=0 }={}) {
		return `${ indent(d, whitespace) }<![CDATA[ ${ this.content } ]]>`;
	}
}

class XMLText extends XMLChildlessNode {
	constructor(str) {
		super();
		this.content = str;
	}

	@accessor
	get content() { return this[$content]; }
	set content(val) {
		this[$content] = val === undefined ? '' : cleanText(val);
	}

	@unwritable
	toString({ whitespace='\t', d=0 }={}) {
		return indent(d, whitespace) + this.content;
	}
}

// PARSER SYMBOLS //////////////////////////////////////////////////////////////

const $activeNode        = Symbol('prop: active node');
const $discardWhitespace = Symbol('prop: discard whitespace');
const $document          = Symbol('prop: document');
const $documentPosition  = Symbol('prop: document position');
const $permissive        = Symbol('prop: permissive');
const $processCDATA      = Symbol('method: process CDATA');
const $processComment    = Symbol('method: process comment');
const $processTag        = Symbol('method: process tag');
const $processText       = Symbol('method: process text');
const $text              = Symbol('prop: text buffer');

const $start             = Symbol('state: start');
const $afterXMLDecl      = Symbol('state: after xml declaration');
const $afterDocTypeDecl  = Symbol('state: after doctype declaration');
const $afterPrologue     = Symbol('state: after prologue');
const $inDocument        = Symbol('state: in document root node tree');
const $afterDocument     = Symbol('state: after document root node completed');

// PARSER //////////////////////////////////////////////////////////////////////

export default class XMLParser extends Writable {
	constructor({ discardWhitespace=true, permissive=false }={}) {
		super({ decodeStrings: false });

		this[$discardWhitespace] = discardWhitespace;
		this[$document]          = new XMLDocument();
		this[$documentPosition]  = $start;
		this[$permissive]        = permissive;
		this[$activeNode]        = this[$document];
		this[$text]              = '';

		this.on('finish', () => {
			const text = this[$text];
			if (text) {
				const err = new ParseError(msg.badEnd, text, text.length - 1);
				this.emit('error', err);
			}
		});
	}

	@unwritable
	_write(chunk, enc, cb) {
		chunk = this[$text] + chunk.toString();

		// In older versions of this, when I was concerned with very predictable
		// documents and didn’t bother with the more obscure parts of the XML
		// spec, the whole thing was a char-by-char state machine. Once I began
		// handling doctypes and entities this was no longer practical -- there
		// are too many tokens comprised by longer sequences of characters to
		// deal with. So we first break up incoming data into ‘tags’ and ‘text’
		// to be processed as units. For our purposes the tags group includes
		// things like CDATA -- it’s anything enclosed in <>.

		// For our matching loop, exec is not currently an option because the
		// sticky flag has not yet been implemented.

		try {

			let [ match, comment, data, tag, text ] = chunk.match(divide) || [];

			while (match) {

				if (tag)
					this[$processTag](tag);
				else if (text)
					this[$processText](text);
				else if (comment)
					this[$processComment](comment);
				else if (data)
					this[$processCDATA](data);

				chunk = chunk.substr(match.length);

				[ match, comment, data, tag, text ] = chunk.match(divide) || [];
			}

			this[$text] = chunk;

			cb();

		} catch (err) {
			this.emit('error', err);
		}
	}

	@unwritable
	write() {
		super.write(...arguments);
	}

	[$processCDATA](cdata) {
		if (!this[$permissive]) {

			const basis = '<![CDATA[' + cdata + ']]>';

			if (this[$documentPosition] != $inDocument)
				throw new ParseError(msg.misplacedCDATA, basis, 0);

			const [ validChars ] = cdata.match(charsFromStart) || [];

			if (validChars.length != cdata.length) {
				const invalidIndex = validChars.length + 4;
				throw new ParseError(msg.invalidChar, basis, invalidIndex);
			}
		}

		cdata = cdata.trim();

		this[$activeNode].children.push(new CDATA(cdata));
	}

	[$processComment](comment) {
		if (this[$documentPosition] == $start)
			this[$documentPosition] = $afterXMLDecl;

		if (!this[$permissive]) {

			const basis = `<!--${ comment }-->`;

			const badIndex = comment.indexOf('--');

			if (~badIndex)
				throw new ParseError(msg.commentDblHyphen, basis, badIndex + 4);

			if (comment.endsWith('-'))
				throw new ParseError(msg.comment3Dash, basis, basis.length - 4);

			const [ validChars ] = comment.match(charsFromStart) || [];

			if (validChars.length != comment.length) {
				const invalidIndex = validChars.length + 4;
				throw new ParseError(msg.invalidChar, basis, invalidIndex);
			}
		}

		comment = comment.trim();

		this[$activeNode].children.push(new XMLComment(comment));
	}

	[$processTag](str) {
		const strict = !this[$permissive];
		const basis = `<${ str }>`;

		let parts = str.split(white);

		let [ initial ] = parts;

		if (!initial && !strict) {
			[ , initial ] = parts;
			parts.shift();
		}

		if (!initial)
			throw new ParseError(str, msg.illegalWhitespace);

		// XML DECLARATION /////////////////////////////////////////////////////

		if (initial == '?xml') {
			if (this[$documentPosition] == $start) {

				this[$documentPosition] = $afterXMLDecl;

				try {
					const doc = this[$document];

					const [
						verA, verB, verC,
						encA, encB, encC,
						sddA, sddB, sddC
					] = str.match(xmlDeclPattern) || [];

					if (verC) {
						const i = str.indexOf(verC);
						throw new ParseError(msg.badVersion(verC), basis, i);
					}

					const version = verA || verB;
					const encoding = encA || encB;
					const standalone = sddA || sddB;

					if (!version)
						throw new ParseError(msg.badXMLDecl, basis, 2);

					doc.version = version;

					if (encC) {
						const i = str.indexOf(encC);
						throw new ParseError(msg.badEncoding(encC), basis, i);
					}

					if (encoding) doc.encoding = encoding;

					if (sddC) {
						const i = str.indexOf(sddC);
						throw new ParseError(msg.badSDD(sddC), basis, i);
					}

					if (standalone) doc.standalone = standalone == 'yes';

					if (!str.endsWith('?')) {
						const badIndex = basis.length - 1;
						throw new ParseError(msg.badPIEnd, basis, badIndex);
					}

					return;
				} catch(err) {
					if (strict) throw err;
				}

			} else if (strict) {
				throw new ParseError(msg.misplacedXMLDecl, basis, 2);
			}
		}

		if (this[$documentPosition] == $start)
			this[$documentPosition] = $afterXMLDecl;

		// PROCESSING INSTRUCTION //////////////////////////////////////////////

		if (initial.startsWith('?')) {
			const piTarget = initial.substr(1);

			if (!piTarget)
				throw new ParseError(msg.missingPITarget, basis, 2);

			if (strict) {

				if (xmlPattern.match(piTarget))
					throw new ParseError(msg.badPITarget(piTarget), basis, 2);

				if (!namePattern.test(piTarget))
					throw new ParseError(msg.badPITarget(piTarget), basis, 2);
			}

			let instruction = str.slice(initial.length, -2);

			if (instruction && strict) {

				const validChars = instruction.match(charsFromStart) || [];

				if (validChars.length != comment.length) {
					const invalidIndex = validChars.length + initial.length + 1;
					throw new ParseError(msg.invalidChar, basis, invalidIndex);
				}
			}

			if (instruction) {

				instruction = instruction.trim();

				if (this[$discardWhitespace])
					instruction = instruction.replace(whiteAnywhere, ' ');
			}

			if (!str.endsWith('?') && strict)
				throw new ParseError(msg.badPIEnd, basis, basis.length - 1);

			this[$activeNode].children.push(
				new XMLProcessingInstruction(piTarget, instruction)
			);

			return;
		}

		// DOCTYPE DECLARATION /////////////////////////////////////////////////

		if (initial == '!DOCTYPE') {
			if (this[$documentPosition] != $afterXMLDecl)
				if (strict)
					throw new ParseError(msg.misplacedDoctype, basis, 0);
				else
					return;

			const [ , doctype ] = parts;

			if (!doctype)
				if (strict)
					throw new ParseError(msg.missingDoctypeName, basis, 10);
				else
					return;

			if (!namePattern.test(doctype) && strict)
				throw new ParseError(msg.badDoctypeName(doctype), basis, 10);

			// TODO!!!

			this[$document].doctype = new XMLDoctype(doctype, extID, internal);
		}

		const pos    = this[$documentPosition];
		const active = this[$activeNode];

		// NORMAL ELEMENT CLOSE ////////////////////////////////////////////////

		if (initial.startsWith('/')) {

			if (this[$documentPosition] !== $inDocument)
				throw new ParseError(msg.misplacedCloseTag, basis, 0);

			const tag = initial.substr(1).replace(finalGT, '');

			let [ namespace, name ] = tag.match(tagNamePattern) || [];

			if (!name && !strict)
				[ namespace, name ] = tag.match(permissiveTagNamePattern) || [];

			if (!name)
				throw new ParseError(msg.badTagName, basis, 2);

			if (name != active.name || namespace != active.namespace)
				throw new ParseError(msg.unmatched(active.fullName), basis, 2);

			if (strict && (parts[1] || parts.length > 2)) {
				const badIndex =
					name.length + (namespace ? namespace.length + 1 : 0) + 2;

				throw new ParseError(msg.closeTagContent, basis, badIndex);
			}

			this[$activeNode] = active[$parent];

			delete active[$parent];

			if (this[$activeNode] instanceof XMLDocument)
				this[$documentPosition] = $afterDocument;

			return;
		}

		// NORMAL ELEMENT OPEN /////////////////////////////////////////////////

		if (this[$documentPosition] == $afterDocument)
			throw new ParseError(msg.multipleRoots, basis, 0);

		this[$documentPosition] = $inDocument;

		const [ namespace, name ] = initial.match(tagNamePattern) || [];

		if (!name)
			throw new ParseError(msg.badTagName, basis, 2);

		const node = new XMLNode(name, namespace);

		node[$parent] = active;

		this[$activeNode] = node;
	}

	[$processText](str) {
		const strict = !this[$permissive];

		if (!this[$documentPosition] != $inDocument)
			if (strict)
				throw new ParseError(msg.illegalAtRoot, str);
			else
				return;

		if (this[$discardWhitespace] && str.match(white))
			return;

		if (strict && badAmpersand.exec(str)) {
			const badIndex = badAmpersand.lastIndex;
			
			badAmpersand.lastIndex = 0;

			throw new ParseError(msg.illegalAmpersand, str, badIndex);
		}

		const badIndexCD = str.indexOf(']]>');

		if (strict && ~badIndexCD)
			throw new ParseError(msg.illegalCDATAClose, str, badIndexCD);

		const badIndexLT = str.indexOf('<');

		if (strict && ~badIndexLT)
			throw new ParseError(msg.illegalLT, str, badIndexLT);

		if (this[$discardWhitespace])
			str = str.trim().replace(whiteAnywhere, ' ');

		this[$activeNode].children.push(new XMLText(str));
	}

	// EXPOSED CONSTRUCTORS ////////////////////////////////////////////////////

	@accessor
	static get CDATA() { return CDATA; }

	@accessor
	static get XMLAttribute() { return XMLAttribute; }

	@accessor
	static get XMLComment() { return XMLComment; }

	@accessor
	static get XMLDoctype() { return XMLDoctype; }

	@accessor
	static get XMLDocument() { return XMLDocument; }

	@accessor
	static get XMLNode() { return XMLNode; }

	@accessor
	static get XMLProcessingInstruction() { return XMLProcessingInstruction; }

	@accessor
	static get XMLText() { return XMLText; }
}



//var h = (new (require('./lib/node_modules/parser.js'))());h.write('<hello> there</hello> <goodbye> yes</goodbye>');

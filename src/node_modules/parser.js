// IMPORTS /////////////////////////////////////////////////////////////////////

import { Writable } from 'stream';

import { ParseError } from 'errors';

import * as isValid from 'string-validation';

import {
	AttListDeclaration,
	Attribute,
	AttributeDefinition,
	CDATASection,
	ChildElementGroup,
	ChildElementName,
	Comment,
	ConditionalSection,
	Doctype,
	DoctypeExternal,
	Document,
	DocumentFragment,
	Element,
	ElementDeclaration,
	EntityDeclaration,
	NotationDeclaration,
	ParameterReference,
	ProcessingInstruction,
	Text
} from 'nodes';

// UNIT TYPE SYMBOLS ///////////////////////////////////////////////////////////

const $attListDecl     = Symbol();
const $cdata           = Symbol();
const $comment         = Symbol();
const $dtdInlineClose  = Symbol();
const $dtdInlineOpen   = Symbol();
const $dtdSimple       = Symbol();
const $elemDecl        = Symbol();
const $entityDecl      = Symbol();
const $markedSectClose = Symbol();
const $markedSectOpen  = Symbol();
const $nodeStart       = Symbol();
const $notationDecl    = Symbol();
const $paramRef        = Symbol();
const $procInst        = Symbol();
const $tagClose        = Symbol();
const $tagEmpty        = Symbol();
const $tagOpen         = Symbol();
const $text            = Symbol();
const $whitespace      = Symbol();
const $xmlDecl         = Symbol();

// PATTERNS ////////////////////////////////////////////////////////////////////

// The matching patterns used at the ‘dissect’ stage are always permissive. We
// want to make the most minimal unambiguous match that tells us where a unit
// begins and ends and what it looks like it *should* be. Therefore whitespace,
// for example, is matched with \s instead of [\n\r\t ]. By always divvying up
// with permissive patterns, strict mode benefits by being able to tell a more
// accurate story about what exactly went wrong.

// Patterns are checked in order -- the sequence often matters. If a pattern has
// a beginning and ending, and the beginning matches but the end does not, the
// dissecter considers us to have entered ambiguous territory -- unless the
// terminal flag is true, in which case it will proceed down the list.

// The final stretch of the list includes patterns that specifically match
// erroneous sequences. Some of these will be forgiven in permissive mode, and
// in strict mode these once again assist us in reporting meaningful errors. 

const patterns = [
	{
		name: $paramRef,
		pattern: /%[^;\s]+;/,
		ambiguous: true
	},
	{
		name: $dtdInlineClose,
		pattern: /^\]\s*>/
	},
	{
		name: $markedSectClose,
		pattern: /^\]\]>/
	},
	{
		name: $text,
		pattern: /^[^<]*[^<\s]+[^<]*/,
		ambiguous: true
	},
	{
		name: $whitespace,
		pattern: /^\s+/,
		ambiguous: true
	},
	{
		name: $xmlDecl,
		pattern: /^<\?xml\s[\S\s]*?>/
	},
	{
		name: $procInst,
		pattern: /^<\?[\S\s]*?\?>/
	},
	{
		name: $comment,
		pattern: /^<!--[\S\s]*?-->/
	},
	{
		name: $cdata,
		pattern: /^<\[CDATA\[[\S\s]*?\]\]>/
	},
	{
		name: $markedSectOpen,
		pattern: /^<\[(?!CDATA)[^\[]*?\[/
	},
	{
		name: $dtdSimple,
		pattern: /^<!DOCTYPE\s([^>'"\[\]]+|"[^"]*"|'[^']*')*?>/
	},
	{
		name: $dtdInlineOpen,
		pattern: /^<!DOCTYPE\s([^>'"\[\]]+|"[^"]*"|'[^']*')*?\[/
	},
	{
		name: $elemDecl,
		pattern: /^<!ELEMENT[\S\s]*?>/
	},
	{
		name: $attListDecl,
		pattern: /^<!ATTLIST([^>'"\[\]]+|"[^"]*"|'[^']*')*?>/
	},
	{
		name: $entityDecl,
		pattern: /^<!ENTITY([^>'"\[\]]+|"[^"]*"|'[^']*')*?>/
	},
	{
		name: $notationDecl,
		pattern: /^<!NOTATION([^>'"\[\]]+|"[^"]*"|'[^']*')*?>/
	},
	{
		name: $tagClose,
		pattern: /^<\s*\/([^>'"]+|"[^"]*"|'[^']*')*>/
	},
	{
		name: $tagEmpty,
		pattern: /^<(?![\?\!])([^>'"]+|"[^"]*"|'[^']*')*\/\s*>/
	},
	{
		name: $tagOpen,
		pattern: /^<(?![\?\!])([^>'"]+|"[^"]*"|'[^']*')*>/
	},
	{
		name: $nodeStart,
		pattern: /^</,
		ambiguous: true
	}
];

const attDefPattern =
	/^[\n\r\t ]+([^\n\r\t ]+)[\n\r\t ]+(?:(CDATA|ID(?:REFS?)?|ENTIT(?:Y|IES)|NMTOKENS?)|(?:(NOTATION)[\n\r\t ]+)?\(([^\)]+)\))[\n\r\t ]+(?:(#REQUIRED|#IMPLIED)|(?:(?:(#FIXED)[\n\r\t ]+)?(?:"([^"]*)"|'([^']*)')))/g;

const attListDecl_strict =
	/^<!ATTLIST[\n\r\t ]+([^\n\r\t >]+)(.*?)[\n\r\t ]*>$/;

const attListDecl_sloppy =
	/^<!ATTLIST\s+(\S+)(.*?)\s*>$/;

const attr_strict =
	/^[\n\r\t ]*([^\n\r\t =]+)[\n\r\t ]*=[\n\r\t ]*(?:"([^<"]*)"|'([^<']*)')/;

const attr_sloppy =
	/([^\s=\\\/<>])\s*=\s*(?:"([^"]+)"|'([^']+)'|([^\s=\\\/<>]))/g;

const cdataPattern =
	/^<!\[CDATA\[(.*)\]\]>$/;

const commentPattern =
	/^<!--(.*)-->$/;

const dtdOpen_strict =
	/^<!DOCTYPE[\n\r\t ]+([^\n\r\t ]+)(?:[\n\r\t ]+SYSTEM[\n\r\t ]+(?:"([^"]*)"|'([^']*)')|PUBLIC[\n\r\t ]+(?:"([^"]*)"|'([^']*)')[\n\r\t ]+(?:"([^"]*)"|'([^']*)'))?[\n\r\t ]*[\[>]$/;

const dtdOpen_sloppy =
	/^<!DOCTYPE\s+(\S+)(?:\s+SYSTEM\s+(?:"([^"]*)"|'([^']*)')|PUBLIC\s+(?:"([^"]*)"|'([^']*)')\s+(?:"([^"]*)"|'([^']*)'))?\s*[\[>]$/;

const elemDecl_strict =
	/^<!ELEMENT[\n\r\t ]+([^\n\r\t ]+)[\n\r\t ]+(?:(EMPTY|ANY)|\((?:(?:[\n\r\t ]*(#PCDATA))((?:[\n\r\t ]*\|[\n\r\t ]*[^\n\r\t ]+)*)[\n\r\t ]*|([^\)]+))\)([\*\+\?])?)[\n\r\t ]*>/;

const elemDecl_sloppy =
	/^<!ELEMENT\s+(\S+)\s+(?:(EMPTY|ANY)|\((?:(?:\s*(#PCDATA))((?:\s*\|\s*\S+)*)\s*|([^\)]+))\)([\*\+\?])?)\s*>/;

const entityDecl_strict =
	/^<!ENTITY[\n\r\t ]+(%[\n\r\t ]+)?(\S+)[\n\r\t ]+(?:"([^"]*)"|'([^']*)'|(?:SYSTEM[\n\r\t ]+"([^"]*)"|'([^']*)'|PUBLIC[\n\r\t ]+"([^"]*)"|'([^']*)'[\n\r\t ]+"([^"]*)"|'([^']*)')(?:[\n\r\t ]+NDATA[\n\r\t ]+(\S+))?)[\n\r\t ]*>$/;

const entityDecl_sloppy =
	/^<!ENTITY\s+(%\s+)?(\S+)\s+(?:"([^"]*)"|'([^']*)'|(?:SYSTEM\s+"([^"]*)"|'([^']*)'|PUBLIC\s+"([^"]*)"|'([^']*)'\s+"([^"]*)"|'([^']*)')(?:\s+NDATA\s+(\S+))?)\s*>$/

const markedSectPattern =
	/^<!\[([\[]+)\[$/;

const notation_strict = 
	/^<!NOTATION[\n\r\t ]+([^\n\r\t ]+)(?:SYSTEM[\n\r\t ]+(?:"([^"]*)"|'([^']*)')|PUBLIC[\n\r\t ]+(?:"([^"]*)"|'([^']*)')(?:[\n\r\t ]+(?:"([^"]*)"|'([^']*)'))?)?[\n\r\t ]*>$/;

const notation_sloppy =
	/^<!NOTATION\s+(\S+)(?:SYSTEM\s+(?:"([^"]*)"|'([^']*)')|PUBLIC\s+(?:"([^"]*)"|'([^']*)')(?:\s+(?:"([^"]*)"|'([^']*)'))?)?\s*>$/;

const nsPattern =
	/^(?:(.+?):)?(.+)$/;

const pi_strict =
	/^<\?(\S+)[\n\r\t ]+(.*)\?>$/;

const pi_sloppy =
	/^<\?\s*(\S+)\s+(.*)\?>$/;

const tagClose_strict =
	/^<\/([^\n\r\t ]+)[\n\r\t ]*>$/;

const tagClose_sloppy =
	/^<\s*\/\s*([^>\s]+)[^>]*>$/;

const tagOpen_strict =
	/^<([^\n\r\t ]+)(?:[\n\r\t ]+([^\n\r\t ][\S\s]*?))?[\n\r\t ]*>$/;

const tagOpen_sloppy =
	/^<\s*(\S+)\s*([^>]*?)?\s*>$/;

const xmlDecl_strict =
	/^<\?xml[\n\r\t ]+version[\n\r\t ]*=[\n\r\t ]*(?:"(1\.\d+)"|'(1\.\d+)')(?:[\n\r\t ]+encoding[\n\r\t ]*=[\n\r\t ]*(?:"([A-Za-z][A-Za-z\d\._\-]*)"|'([A-Za-z][A-Za-z\d\._\-]*)'))?(?:[\n\r\t ]+standalone[\n\r\t ]*=[\n\r\t ]*(?:"(yes|no)"|'(yes|no)'))?[\n\r\t ]*\?>$/;

// UTIL ////////////////////////////////////////////////////////////////////////

const norm = function() {
	return this.trim().replace(/\s+/g, ' ');
};

const normTarget = val => {
	if (val === undefined || val === null) return;

	if (val instanceof Object)
		val = val.constructor.name;

	if (typeof val === 'string' || val instanceof String) {
		const norm = val.toUpperCase().replace(/\s/g, '');

		if (norm == 'DOCTYPEEXTERNAL')
			return 'DoctypeExternal';
		if (norm == 'DOCUMENT')
			return 'Document';
		if (norm == 'DOCUMENTFRAGMENT')
			return 'DocumentFragment';
		if (norm == 'ELEMENT')
			return 'Element';
	}

	throw new InvalidTargetError(val);
};

const dissect = (str, isTerminal, units=[]) => {
	
	// Here, we take an incoming string and break it apart into discreet
	// components for further processing, where they will be interpretted to
	// build document nodes. After extracting as many complete units as possible
	// any remaining string is the ‘remainder’. The remainder is not always
	// ‘partial’ -- it may in fact be a complete unit except that there is still
	// ambiguity because the next (unknown) character could still change its
	// meaning. However, when `isTerminal` is true there is never ambiguity
	// because it says ‘this is the final string.’ 

	for (const { name, pattern, ambiguous } of patterns) {
		const [ match ] = str.match(pattern) || [];

		if (match) {

			if (name == $nodeStart && isTerminal)
				return [ str, units ];

			if (!isTerminal && ambiguous && str == match)
				return [ str, units ];

			str = str.slice(match.length);

			units.push({ name, match });

			if (str)
				return dissect(str, isTerminal, units);
			else
				return [ str, units ];
		}
	}

	// I think this is actually unreachable, but just to be safe:

	return [ str, units ];
};

const toContentSpecList = (str, arr) => {

	// This whole bit ought to be refactored. Not exactly a paragon of elegance.

	let match, n, quantifier, sep = 'init';

	while (str) {

		if (!sep)
			throw new ParseError();

		[ match, n, quantifier='', sep ] =
			str.match(/^\s*(\S+)([\?\*\+])?\s*([,|]|$)/) || [];

		if (n) {
			const [ , namespace, name ] = n.match(nsPattern);

			const child = new ChildElementName({ namespace, name, quantifier });

			arr.push(child);

			const prevType = arr.type;

			arr.type = sep == ',' ? 'SEQUENCE' : arr.type || 'CHOICE';

			if (prevType && prevType != arr.type)
				throw new ParseError();

			str = str.slice(match.length);

		} else if (str.match(/^\s*\(/)) {

			let count = 0;
			let index = -1;

			for (const char of str) {
				index++;

				if (char == '(' || char == ')') {
					if (char == '(')
						count++
					else
						count--;

					if (!count) break;
				}
			}

			if (!count) {

				let segment = str.slice(0, index);

				str = str.slice(segment.length);

				[ match, quantifier='', sep ] =
					str.match(/^([\+\?\*])?([,\|])/);

				const prevType = arr.type;

				arr.type = sep == ',' ? 'SEQUENCE' : arr.type || 'CHOICE';

				if (prevType && prevType != arr.type)
					throw new ParseError();

				const child = new ChildElementGroup({ quantifier });

				segment = segment.replace(/^\s*\(/, '');

				toContentSpecList(segment, child);

			} else {
				throw new ParseError();
			}

		} else {
			throw new ParseError();
		}
	}

	return arr;
};

// PARSER STATE SYMBOLS ////////////////////////////////////////////////////////

// Initial state.
const $start = Symbol();

// We’ve seen an xml or text declaration, or we have seen any other legal node. 
const $afterXMLDecl = Symbol();

// We are in an external DTD -- this is a final state.
const $externalDTD = Symbol();

// We are in the bracketed interior of an internal DTD.
const $internalDTD = Symbol();

// We are in a document, after a DTD but before the root.
const $afterDTD = Symbol();

// Special initial state for target == Element.
const $beforeRoot = Symbol();

// We are somewhere within the element tree of a document.
const $inRoot = Symbol();

// The root element of a document has resolved -- this is a final state.
const $afterRoot = Symbol();

// PARSER SYMBOLS //////////////////////////////////////////////////////////////

const $buffer      = Symbol();
const $doc         = Symbol();
const $html        = Symbol();
const $ignoreWhite = Symbol();
const $node        = Symbol();
const $normalize   = Symbol();
const $processUnit = Symbol();
const $state       = Symbol();
const $strict      = Symbol();
const $target      = Symbol();

// PARSER //////////////////////////////////////////////////////////////////////

export default class Parser extends Writable {
	constructor({ strict=true, ignoreWhite=true, html, normalize, target }={}) {
		super({ decodeStrings: false });

		this[$html]        = !!html;
		this[$ignoreWhite] = !!ignoreWhite;
		this[$normalize]   = !!normalize;
		this[$strict]      = !!strict;
		this[$target]      = normTarget(target);

		if (this.target === 'DocumentFragment') {
			this[$state] = $inElement;
			this[$doc]   = new DocumentFragment();
			this[$node]  = this[$doc];
		} else if (this.target === 'Element') {
			this[$state] = $beforeRoot;
		} else {
			this[$state] = $start;
			this[$opts] = {};
		}

		this[$buffer] = '';

		this.on('finish', () => {

			if (this[$buffer])
				const [ remainder, units ] = dissect(this[$buffer], true);

				for (const unit of units) this[$processUnit](unit);

				if (remainder) {
					const err = new ParseError();

					if (this.strict)
						return this.emit('error', err);
					else
						this.emit('wat', err);
				}
		});
	}

	get html() {
		return this[$html];
	}

	get ignoreWhite() {
		return this[$ignoreWhite];
	}

	get normalize() {
		return this[$normalize];
	}

	get strict() {
		return this[$strict];
	}

	get target() {
		return this[$target];
	}

	_write(chunk, enc, cb) {
		chunk = this[$buffer] + chunk.toString();

		const { remainder, units } = dissect(chunk);

		try {

			for (const unit of units) this[$processUnit](unit);

			this[$buffer] = remainder;

			cb();

		} catch (err) {
			this.emit('error', err);
		}
	}

	[$processUnit]({ match, name }) {
		const state  = this.state;
		const strict = this.strict;
		const target = this.target;

		if (name == $whitespace && (this.ignoreWhite || state != $inRoot))
			return;
		else if (name == $whitespace)
			name = $text;

		const isElemContent =
			name == $cdata ||
			name == $comment ||
			name == $dtdInlineClose ||
			(name == $markedSectClose && !this.strict) ||
			name == $paramRef ||
			name == $procInst ||
			name == $tagClose ||
			name == $tagEmpty ||
			name == $tagOpen ||
			name == $text;

		if (target == 'Element') {

			if (state == $afterRoot) {
				if (strict)
					throw new ParseError();
				else
					this.emit('wat', new ParseError());

				return;
			}

			if (state == $beforeRoot && name != $tagOpen && name != $tagEmpty) {
				if (strict)
					throw new ParseError();
				else
					this.emit('wat', new ParseError());

				return;
			}
		}

		const shouldBeElemContent =
			target == 'Element' ||
			target == 'DocumentFragment' ||
			state == $inRoot;

		if (shouldBeElemContent) {
			if (name == $paramRef ||
				name == $dtdInlineClose ||
				name == $markedSectClose)
					name = $text;

			if (isElemContent)
				this[name](match);
			else if (strict)
				throw new ParseError();
			else
				this.emit('wat', new ParseError());

			return;
		}

		if (state != $start && name == $xmlDecl) {
			if (strict)
				throw new ParseError();
			else
				this.emit('wat', new ParseError());

			return;
		}

		if (!target) {

			const onlyDTDE =
				name == $attListDecl ||
				name == $elemDecl ||
				name == $entityDecl ||
				name == $markedSectOpen ||
				name == $notationDecl ||
				name == $paramRef;

			if (onlyDTDE) {
				this[$target] = 'DoctypeExternal';
				this[$node] = this[$doc] = new DoctypeExternal(this[$opts]);
				this[name](match);
			}
		}

		if (target == 'DoctypeExternal') {

			let isValid =
				name == $attListDecl ||
				name == $comment ||
				name == $elemDecl ||
				name == $entityDecl ||
				name == $markedSectClose ||
				name == $markedSectOpen ||
				name == $notationDecl ||
				name == $paramRef ||
				name == $procInst;

			if (state == $start)
				isValid = isValid || name == $xmlDecl;

			if (isDTDEContent)
				this[name](match);
			else if (strict)
				throw new ParseError();
			else
				this.emit('wat', new ParseError());

			return;
		}

		if (!target) {

			const onlyDoc =
				name == $dtdSimple ||
				name == $dtdInlineOpen ||
				name == $tagOpen ||
				name == $tagEmpty;

			if (onlyDoc) {
				this[$target] = 'Document';
				this[$node] = this[$doc] = new Document(this[$opts]);
				this[name](match);
			}
		}

		if (target == 'Document') {

			let isValid = false;

			if (state == $start) {
				isValid =
					name == $comment ||
					name == $dtdInlineOpen ||
					name == $dtdSimple ||
					name == $procInst ||
					name == $tagEmpty ||
					name == $tagOpen ||
					name == $xmlDecl;
			} else if (state == $afterXMLDecl) {
				isValid =
					name == $comment ||
					name == $dtdInlineOpen ||
					name == $dtdSimple ||
					name == $procInst ||
					name == $tagEmpty ||
					name == $tagOpen;
			} else if (state == $internalDTD) {
				isValid =
					name == $attListDecl ||
					name == $comment ||
					name == $dtdInlineClose ||
					name == $elemDecl ||
					name == $entityDecl ||
					name == $notationDecl ||
					name == $paramRef ||
					name == $procInst;
			} else if (state == $afterDTD) {
				isValid =
					name == $comment ||
					name == $procInst ||
					name == $tagEmpty ||
					name == $tagOpen;
			} else if (state == $afterRoot) {
				isValid = 
					name == $comment ||
					name == $procInst;
			}

			if (isValid)
				this[name](match);
			else if (strict)
				throw new ParseError();
			else
				this.emit('wat', new ParseError());

			return;
		}

		this[name](match);
	}

	[$attListDecl](str) {
		const pattern = this.strict ? attListDecl_strict : attListDecl_sloppy;

		const [ , n, body ] = str.match(pattern) || [];

		if (!n)
			throw new ParseError();

		const [ , namespace, name ] = n.match(nsPattern);

		const attList = new AttListDeclaration({ namespace, name });

		if (body) {

			attDefPattern.lastIndex = 0;

			let [ m, n, t1, t2, m, d1, d2, v1, v2 ] =
				attDefPattern.exec(body) || [];

			if (this.strict && !n)
				throw new ParseError();

			while (m) {

				const [ , namespace, name ] = n.match(nsPattern);
				const type = t1 || t2;
				const members = m.split(/|/).map(m => m.trim());
				const defaultType = d1 || d2;
				const defaultValue = v1 || v2;

				const attDef = new AttributeDefinition({
					namespace, name, type, members, defaultType, defaultValue
				});

				attList.defs.push(attDef);

				body = body.slice(m.length);

				[ m, n, t1, t2, m, d1, d2, v1, v2 ] =
					attDefPattern.exec(body) || [];
			}
		}

		this[$node].children.push(attList);
	}

	[$cdata](str) {
		const [ , content ] = str.match(cdataPattern) || [];

		if (this.normalize)
			content = content::norm();

		const cdata = new CDATASection({ content });

		this[$node].children.push(cdata);
	}

	[$comment](str) {
		const [ , content ] = str.match(commentPattern) || [];

		if (this.normalize)
			content = content::norm();

		const comment = new Comment(content);

		if (this.strict && comment.content != content)
			throw new ParseError();

		this[$node].children.push(comment);
	}

	[$dtdInlineOpen](str) {
		this[$dtdSimple](str);

		this[$state] = $internalDTD;
		this[$node]  = this[$node].children.last;
	}

	[$dtdInlineClose](str) {
		if (this[$node] instanceof Doctype) {
			this[$state] = $afterDTD;
			this[$node]  = this[$node].parent;
		} else if (this.strict) {
			throw new ParseError();
		} else {
			this.emit('wat', new ParseError());
		}
	}

	[$dtdSimple](str) {
		this[$state] = $afterDTD;

		const pattern = this.strict ? dtdOpen_strict : dtdOpen_sloppy;

		const [ , name, s1, s2, p1, p2, s3, s4 ] = str.match(pattern) || [];

		const systemID = s1 || s2 || s3 || s4;

		const publicID = p1 || p2;

		const dtd = new Doctype({ name, systemID, publicID });

		this[$node].children.push(dtd);
	}

	[$elemDecl](str) {
		const pattern = this.strict ? elemDecl_strict : elemDecl_sloppy;

		const [ , n, t, pc, pcm, m, quantifier ] = str.match(pattern) || [];

		const [ , namespace, name ] = n.match(nsPattern);

		let type = t || (pc && 'MIXED');

		let members = [];

		if (pcm) {
			if (this.strict && qualifier != '*') {
				throw new ParseError();
			} else {
				qualifier = '*';
				this.emit('wat', new ParseError());
			}

			pcm = pcm.split(/\s*\|\s*/g).slice(1);

			members = pcm.map(n => {
				const [ , namespace, name ] = n.match(nsPattern);

				return new ChildElementName({ namespace, name });
			});

		} else if (!pcm && pc) {
			if (this.strict && qualifier) {
				throw new ParseError();
			} else {
				this.emit('warning', new ParseError());
			}
		} else if (m) {
			members = toContentSpecList(m);
		}

		type = type || members.type;

		if (type != members.type)
			throw new ParseError();

		const elemDecl = new ElementDeclaration({
			namespace, name, quantifier, type
		});

		for (const member of members)
			elemDecl.contentSpec.push(member);

		this[$node].children.push(elemDecl);
	}

	[$entityDecl](str) {
		const pattern = this.strict ? entityDecl_strict : entityDecl_sloppy;

		const [ , isParameter, name, v1, v2, s1, s2, p1, p2, s3, s4, ndata ] =
			str.match(pattern) || [];

		if (!name)
			if (this.strict) throw new ParseError();
		else
			this.emit('wat', new ParseError());

		const systemID = s1 || s2 || s3 || s4;
		const publicID = p1 || p2;

		const entityDecl = new EntityDeclaration({
			isParameter, name, ndata, publicID, systemID, value
		});

		this[$node].children.push(entityDecl);
	}

	[$markedSectClose](str) {
		if (this[$node] instanceof ConditionalSection) {
			this[$node] = this[$node].parent;
		} else if (this.strict) {
			throw new ParseError();
		} else {
			this.emit('wat', new ParseError());
		}
	}

	[$markedSectOpen](str) {

		const [ , keyword ] = markedSectPattern || [];

		const markedSect = new ConditionalSection(keyword);

		this[$node].children.push(markedSect);

		this[$node] = markedSect;
	}

	[$notationDecl](str) {

		const pattern = this.strict ? notation_strict : notation_sloppy;

		const [ , n, s1, s2, p1, p2, s3, s4 ] = str.match(pattern) || [];

		if (n) {

			const [ , namespace, name ] = n.match(nsPattern);

			const systemID = s1 || s2 || s3 || s4;
			const publicID = p1 || p2;

			const notationDecl = new NotationDeclatation({
				name, namespace, publicID, systemID
			});

			this[$node].children.push(notationDecl);

		} else if (this.strict) {
			throw new ParseError();
		} else {
			this.emit('wat', new ParseError());
		}
	}

	[$paramRef](str) {
		const pr = new ParameterReference(str);

		this[$node].children.push(pr);
	}

	[$procInst](str) {

		const pattern = this.strict ? pi_strict : pi_sloppy;

		const [ , target, instruction ] = str.match(pattern);

		if (target) {

			const pi = new ProcessingInstruction({ target, instruction });

			this[$node].children.push(pi);

		} else if (strict) {
			throw new ParseError();
		} else {
			this.emit('wat', new ParseError());
		}
	}

	[$tagClose](str) {
		const pattern = this.strict ? tagClose_strict : tagClose_sloppy;

		const [ , n ] = str.match(pattern) || [];

		if (!n)
			throw new ParseError(); // unrecoverable, too weird

		if (this[$node].fullName == n) {
			this[$node] = this[$node].parent;
		} else if (strict) {
			throw new ParseError();
		} else {
			// In the event of a closing tag that doesn’t balance in sloppy mode
			// we can try to recover if it appears that intermediate closing
			// tags were accidentally omitted. This is a gambit: while that’s
			// a *possible* explanation, we (a) don’t know for sure and (b)
			// don’t know where the end tags really should have been positioned.

			// This is the approach taken by browsers when facing malformed HTML
			// though, so I think that it’s probably the recovery type that
			// people are accustomed to.

			// <a><b>text<c></a> would therefore become <a><b>text<c/></b></a>.

			const realNode = this[$node].parents.find(p => p.fullName == n);

			if (realNode) {
				this[$node] = realNode;

				this.emit('wat', new ParseError());
			} else {
				throw new ParseError();
			}
		}
	}

	[$tagEmpty](str) {
		const orig = str;

		if (this.strict)
			str = str.replace(/\/>$/, '>');
		else
			str = str.replace(/\/\s*>$/, '>');

		if (str == orig)
			throw new ParseError();

		this[$tagOpen](str);
		this[$node] = this[$node].parent;
	}

	[$tagOpen](str) {
		const pattern = this.strict ? tagOpen_strict : tagOpen_sloppy;

		let [ , n, body ] = str.match(pattern) || [];

		if (!n)
			throw new ParseError();

		const [ , namespace, name ] = n.match(nsPattern);

		const elem = new Element({ namespace, name });

		this[$node].children.push(elem);

		this[$node] = elem;

		if (body && !strict) {

			attr_sloppy.lastIndex = 0;

			let [ , k, val1, val2, val3 ] = attr_sloppy.exec(str) || [];

			while (k) {

				const value = val1 || val2 || val3 || '';

				const [ , namespace, key ] = key.match(nsPattern);

				elem.setAttribute({ namespace, key, value });

				[ , k, val1, val2, val3 ] = attr_sloppy.exec(str) || [];
			}

		} else if (body) {

			let [ match, k, val1, val2 ] = body.match(attr_strict) || [];

			while (match) {
				const value = val1 || val2;

				const [ , namespace, key ] = key.match(nsPattern);

				const attr = new Attribute({ namespace, key, value });

				if (attr.value != value)
					throw new ParseError();

				elem.attributes.push(attr);

				body = body.slice(match.length);

				[ match, key, val1, val2 ] = body.match(attr_strict) || [];
			}

			if (body && !isValid.whitespace(body))
				throw new ParseError();
		}
	}

	[$text](content) {
		if (this.normalize)
			content = content::norm();

		let before = content;
		let after;

		const prev = this[$node].children.last;

		if (prev && prev instanceof Text) {
			orig = prev.content + content;

			prev.content = orig;

			after = prev.content;
		} else {
			const text = new Text({ content });

			after = text.content;

			this[$node].children.push(text);
		}

		if (this.strict && (orig != after))
			throw new ParseError();
	}

	[$xmlDecl](str) {
		// At xml declaration, it’s possible that we still have an ambiguous
		// target. This may be cleared up if "standalone" exists; that means
		// this is a Document. But it also may remain ambiguous, in which case
		// we save the results to $opts for instantiating the correct type
		// later.

		let v1, v2, e1, e2, s1, s2;
		let version, encoding, standalone;

		if (this.strict) {
			[ , v1, v2, e1, e2, s1, s2 ] = str.match(xmlDecl_strict) || [];

			version    = v1 || v2;
			encoding   = e1 || e2;
			standalone = s1 || s2;

		} else {

			attr_sloppy.lastIndex = 0;

			let [ , key, val1, val2, val3 ] = attr_sloppy.exec(str) || [];

			while (key) {
				switch (key.toLowerCase()) {
					case 'version':
						version = val1 || val2 || val3;

						if (version) version = parseFloat(version);

						if (version && ((version < 1) || (version >= 2))) {
							version = null;
							this.emit('warning', new ParseError());
						}

						break;
					case 'encoding':
						encoding = val1 || val2 || val3;

						if (encoding && !isValid.encoding(encoding)) {
							encoding = null;
							this.emit('warning', new ParseError());
						}

						break;
					case 'standalone':
						standalone = val1 || val2 || val3;

						if (standalone) {
							standalone = standalone.trim.toLowerCase();

							if (standalone != 'yes' && standalone != 'no') {
								standalone = null;
								this.emit('warning', new ParseError());
							}
						}

						break;
				}

				[ , key, val1, val2, val3 ] = attr_sloppy.exec(str) || [];
			}

			const [ strictMatch ] = str.match(xmlDecl_strict) || [];

			if (!strictMatch)
				this.emit('warning', new ParseError());
		}

		if (standalone && !this.target)
			this[$target] = 'Document';
		else if (encoding && !version)
			this[$target] = 'DoctypeExternal';

		if (this.strict && (this.target == 'Document') && !version)
			throw new ParseError();
		else if (this.target == 'DoctypeVersion' && standalone) {
			if (strict)
				throw new ParseError();
			else
				this.emit('warning', new ParseError());
		}

		if (this.target == 'Document')
			this[$node] = this[$doc] =
				new Document({ version, encoding, standalone });
		else if (this.target == 'DoctypeExternal')
			this[$node] = this[$doc] =
				new DoctypeExternal({ version, encoding });
		else
			this[$opts] = { version, encoding };
	}
}
